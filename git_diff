Index: b/bundle/vim-colors-solarized/colors/.DS_Store
deleted file mode 100644
===================================================================
Binary files a/bundle/vim-colors-solarized/colors/.DS_Store and /dev/null differ
Index: b/bundle/vim-colors-solarized/colors/.solarized.vim.un~
deleted file mode 100644
===================================================================
Binary files a/bundle/vim-colors-solarized/colors/.solarized.vim.un~ and /dev/null differ
Index: b/colors/SolarizedDark.vim
deleted file mode 100644
===================================================================
--- a/colors/SolarizedDark.vim
+++ /dev/null
@@ -1,149 +0,0 @@
-" Vim color file - SolarizedDark
-" Generated by http://bytefluent.com/vivify 2014-01-04
-set background=dark
-if version > 580
-	hi clear
-	if exists("syntax_on")
-		syntax reset
-	endif
-endif
-
-set t_Co=256
-let g:colors_name = "SolarizedDark"
-
-hi IncSearch guifg=#cb4b16 guibg=NONE guisp=NONE gui=NONE ctermfg=166 ctermbg=NONE cterm=NONE
-hi WildMenu guifg=#eee8d5 guibg=#073642 guisp=#073642 gui=NONE ctermfg=230 ctermbg=23 cterm=NONE
-hi SignColumn guifg=#839496 guibg=#bebebe guisp=#bebebe gui=NONE ctermfg=66 ctermbg=7 cterm=NONE
-hi SpecialComment guifg=#dc322f guibg=NONE guisp=NONE gui=NONE ctermfg=160 ctermbg=NONE cterm=NONE
-hi Typedef guifg=#b58900 guibg=NONE guisp=NONE gui=NONE ctermfg=136 ctermbg=NONE cterm=NONE
-hi Title guifg=#cb4b16 guibg=NONE guisp=NONE gui=bold ctermfg=166 ctermbg=NONE cterm=bold
-hi Folded guifg=#839496 guibg=#073642 guisp=#073642 gui=bold ctermfg=66 ctermbg=23 cterm=bold
-hi PreCondit guifg=#cb4b16 guibg=NONE guisp=NONE gui=NONE ctermfg=166 ctermbg=NONE cterm=NONE
-hi Include guifg=#cb4b16 guibg=NONE guisp=NONE gui=NONE ctermfg=166 ctermbg=NONE cterm=NONE
-hi TabLineSel guifg=#586e75 guibg=#eee8d5 guisp=#eee8d5 gui=bold ctermfg=66 ctermbg=230 cterm=bold
-hi StatusLineNC guifg=#657b83 guibg=#073642 guisp=#073642 gui=NONE ctermfg=66 ctermbg=23 cterm=NONE
-hi CTagsMember guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi NonText guifg=#657b83 guibg=NONE guisp=NONE gui=bold ctermfg=66 ctermbg=NONE cterm=bold
-hi CTagsGlobalConstant guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi DiffText guifg=#2aa198 guibg=NONE guisp=NONE gui=NONE ctermfg=37 ctermbg=NONE cterm=NONE
-hi ErrorMsg guifg=#dc322f guibg=#0000c0 guisp=#0000c0 gui=NONE ctermfg=160 ctermbg=4 cterm=NONE
-hi Ignore guifg=#000000 guibg=NONE guisp=NONE gui=NONE ctermfg=NONE ctermbg=NONE cterm=NONE
-hi Debug guifg=#dc322f guibg=NONE guisp=NONE gui=NONE ctermfg=160 ctermbg=NONE cterm=NONE
-hi PMenuSbar guifg=#eee8d5 guibg=#839496 guisp=#839496 gui=NONE ctermfg=230 ctermbg=66 cterm=NONE
-hi Identifier guifg=#268bd2 guibg=NONE guisp=NONE gui=bold ctermfg=32 ctermbg=NONE cterm=bold
-hi SpecialChar guifg=#dc322f guibg=NONE guisp=NONE gui=NONE ctermfg=160 ctermbg=NONE cterm=NONE
-hi Conditional guifg=#719e07 guibg=NONE guisp=NONE gui=NONE ctermfg=106 ctermbg=NONE cterm=NONE
-hi StorageClass guifg=#b58900 guibg=NONE guisp=NONE gui=NONE ctermfg=136 ctermbg=NONE cterm=NONE
-hi Todo guifg=#d33682 guibg=#00ffff guisp=#00ffff gui=bold ctermfg=168 ctermbg=14 cterm=bold
-hi Special guifg=#dc322f guibg=NONE guisp=NONE gui=NONE ctermfg=160 ctermbg=NONE cterm=NONE
-hi LineNr guifg=#586e75 guibg=#073642 guisp=#073642 gui=NONE ctermfg=66 ctermbg=23 cterm=NONE
-hi StatusLine guifg=#93a1a1 guibg=#073642 guisp=#073642 gui=bold ctermfg=109 ctermbg=23 cterm=bold
-hi Normal guifg=#839496 guibg=#002b36 guisp=#002b36 gui=NONE ctermfg=66 ctermbg=23 cterm=NONE
-hi Label guifg=#719e07 guibg=NONE guisp=NONE gui=NONE ctermfg=106 ctermbg=NONE cterm=NONE
-hi CTagsImport guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi PMenuSel guifg=#586e75 guibg=#eee8d5 guisp=#eee8d5 gui=NONE ctermfg=66 ctermbg=230 cterm=NONE
-hi Search guifg=#b58900 guibg=#00ffff guisp=#00ffff gui=NONE ctermfg=136 ctermbg=14 cterm=NONE
-hi CTagsGlobalVariable guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi Delimiter guifg=#dc322f guibg=NONE guisp=NONE gui=NONE ctermfg=160 ctermbg=NONE cterm=NONE
-hi Statement guifg=#719e07 guibg=NONE guisp=NONE gui=NONE ctermfg=106 ctermbg=NONE cterm=NONE
-hi SpellRare guifg=#e2e4e5 guibg=#ff40ff guisp=#ff40ff gui=NONE ctermfg=254 ctermbg=13 cterm=NONE
-hi EnumerationValue guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi Comment guifg=#586e75 guibg=NONE guisp=NONE gui=italic ctermfg=66 ctermbg=NONE cterm=NONE
-hi Character guifg=#2aa198 guibg=NONE guisp=NONE gui=NONE ctermfg=37 ctermbg=NONE cterm=NONE
-hi Float guifg=#2aa198 guibg=NONE guisp=NONE gui=NONE ctermfg=37 ctermbg=NONE cterm=NONE
-hi Number guifg=#2aa198 guibg=NONE guisp=NONE gui=NONE ctermfg=37 ctermbg=NONE cterm=NONE
-hi Boolean guifg=#2aa198 guibg=NONE guisp=NONE gui=NONE ctermfg=37 ctermbg=NONE cterm=NONE
-hi Operator guifg=#719e07 guibg=NONE guisp=NONE gui=NONE ctermfg=106 ctermbg=NONE cterm=NONE
-hi CursorLine guifg=#e2e4e5 guibg=#073642 guisp=#073642 gui=underline ctermfg=254 ctermbg=23 cterm=underline
-hi Union guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi TabLineFill guifg=#839496 guibg=#073642 guisp=#073642 gui=underline ctermfg=66 ctermbg=23 cterm=underline
-hi Question guifg=#2aa198 guibg=NONE guisp=NONE gui=bold ctermfg=37 ctermbg=NONE cterm=bold
-hi WarningMsg guifg=#dc322f guibg=NONE guisp=NONE gui=bold ctermfg=160 ctermbg=NONE cterm=bold
-hi VisualNOS guifg=#e2e4e5 guibg=#073642 guisp=#073642 gui=bold ctermfg=254 ctermbg=23 cterm=bold
-hi DiffDelete guifg=#dc322f guibg=#073642 guisp=#073642 gui=bold ctermfg=160 ctermbg=23 cterm=bold
-hi ModeMsg guifg=#268bd2 guibg=NONE guisp=NONE gui=bold ctermfg=32 ctermbg=NONE cterm=bold
-hi CursorColumn guifg=#e2e4e5 guibg=#073642 guisp=#073642 gui=NONE ctermfg=254 ctermbg=23 cterm=NONE
-hi Define guifg=#cb4b16 guibg=NONE guisp=NONE gui=NONE ctermfg=166 ctermbg=NONE cterm=NONE
-hi Function guifg=#268bd2 guibg=NONE guisp=NONE gui=bold ctermfg=32 ctermbg=NONE cterm=bold
-hi FoldColumn guifg=#839496 guibg=#073642 guisp=#073642 gui=NONE ctermfg=66 ctermbg=23 cterm=NONE
-hi PreProc guifg=#cb4b16 guibg=NONE guisp=NONE gui=NONE ctermfg=166 ctermbg=NONE cterm=NONE
-hi EnumerationName guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi Visual guifg=#586e75 guibg=#002b36 guisp=#002b36 gui=NONE ctermfg=66 ctermbg=23 cterm=NONE
-hi MoreMsg guifg=#268bd2 guibg=NONE guisp=NONE gui=NONE ctermfg=32 ctermbg=NONE cterm=NONE
-hi SpellCap guifg=#e2e4e5 guibg=#ff6060 guisp=#ff6060 gui=NONE ctermfg=254 ctermbg=9 cterm=NONE
-hi VertSplit guifg=#657b83 guibg=#657b83 guisp=#657b83 gui=NONE ctermfg=66 ctermbg=66 cterm=NONE
-hi Exception guifg=#719e07 guibg=NONE guisp=NONE gui=NONE ctermfg=106 ctermbg=NONE cterm=NONE
-hi Keyword guifg=#719e07 guibg=NONE guisp=NONE gui=NONE ctermfg=106 ctermbg=NONE cterm=NONE
-hi Type guifg=#b58900 guibg=NONE guisp=NONE gui=NONE ctermfg=136 ctermbg=NONE cterm=NONE
-hi DiffChange guifg=#b58900 guibg=#073642 guisp=#073642 gui=bold ctermfg=136 ctermbg=23 cterm=bold
-hi Cursor guifg=#002b36 guibg=#839496 guisp=#839496 gui=NONE ctermfg=23 ctermbg=66 cterm=NONE
-hi SpellLocal guifg=#e2e4e5 guibg=#ffff00 guisp=#ffff00 gui=NONE ctermfg=254 ctermbg=11 cterm=NONE
-hi Error guifg=#dc322f guibg=#8080ff guisp=#8080ff gui=bold ctermfg=160 ctermbg=12 cterm=bold
-hi PMenu guifg=#839496 guibg=#073642 guisp=#073642 gui=NONE ctermfg=66 ctermbg=23 cterm=NONE
-hi SpecialKey guifg=#657b83 guibg=#073642 guisp=#073642 gui=bold ctermfg=66 ctermbg=23 cterm=bold
-hi Constant guifg=#2aa198 guibg=NONE guisp=NONE gui=NONE ctermfg=37 ctermbg=NONE cterm=NONE
-hi DefinedName guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi Tag guifg=#dc322f guibg=NONE guisp=NONE gui=NONE ctermfg=160 ctermbg=NONE cterm=NONE
-hi String guifg=#2aa198 guibg=NONE guisp=NONE gui=NONE ctermfg=37 ctermbg=NONE cterm=NONE
-hi PMenuThumb guifg=#839496 guibg=#002b36 guisp=#002b36 gui=NONE ctermfg=66 ctermbg=23 cterm=NONE
-hi MatchParen guifg=#dc322f guibg=#586e75 guisp=#586e75 gui=bold ctermfg=160 ctermbg=66 cterm=bold
-hi LocalVariable guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi Repeat guifg=#719e07 guibg=NONE guisp=NONE gui=NONE ctermfg=106 ctermbg=NONE cterm=NONE
-hi SpellBad guifg=#e2e4e5 guibg=#8080ff guisp=#8080ff gui=NONE ctermfg=254 ctermbg=12 cterm=NONE
-hi CTagsClass guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi Directory guifg=#268bd2 guibg=NONE guisp=NONE gui=NONE ctermfg=32 ctermbg=NONE cterm=NONE
-hi Structure guifg=#b58900 guibg=NONE guisp=NONE gui=NONE ctermfg=136 ctermbg=NONE cterm=NONE
-hi Macro guifg=#cb4b16 guibg=NONE guisp=NONE gui=NONE ctermfg=166 ctermbg=NONE cterm=NONE
-hi Underlined guifg=#6c71c4 guibg=NONE guisp=NONE gui=underline ctermfg=61 ctermbg=NONE cterm=underline
-hi DiffAdd guifg=#719e07 guibg=#073642 guisp=#073642 gui=bold ctermfg=106 ctermbg=23 cterm=bold
-hi TabLine guifg=#839496 guibg=#073642 guisp=#073642 gui=underline ctermfg=66 ctermbg=23 cterm=underline
-hi cursorim guifg=#404040 guibg=#8b8bff guisp=#8b8bff gui=NONE ctermfg=238 ctermbg=105 cterm=NONE
-"hi clear -- no settings --
-hi stringdelimiter guifg=#556633 guibg=NONE guisp=NONE gui=NONE ctermfg=101 ctermbg=NONE cterm=NONE
-hi rubyregexp guifg=#dd0093 guibg=NONE guisp=NONE gui=NONE ctermfg=162 ctermbg=NONE cterm=NONE
-hi string guifg=#99ad6a guibg=NONE guisp=NONE gui=NONE ctermfg=107 ctermbg=NONE cterm=NONE
-hi constant guifg=#cf6a4c guibg=NONE guisp=NONE gui=NONE ctermfg=173 ctermbg=NONE cterm=NONE
-hi normal guifg=#e8e8d3 guibg=#151515 guisp=#151515 gui=NONE ctermfg=187 ctermbg=233 cterm=NONE
-hi rubyinstancevariable guifg=#c6b6fe guibg=NONE guisp=NONE gui=NONE ctermfg=147 ctermbg=NONE cterm=NONE
-hi rubyclass guifg=#447799 guibg=NONE guisp=NONE gui=NONE ctermfg=67 ctermbg=NONE cterm=NONE
-hi identifier guifg=#c6b6ee guibg=NONE guisp=NONE gui=NONE ctermfg=183 ctermbg=NONE cterm=NONE
-hi comment guifg=#888888 guibg=NONE guisp=NONE gui=italic ctermfg=102 ctermbg=NONE cterm=NONE
-hi rubyregexpdelimiter guifg=#540063 guibg=NONE guisp=NONE gui=NONE ctermfg=53 ctermbg=NONE cterm=NONE
-hi rubyregexpspecial guifg=#a40073 guibg=NONE guisp=NONE gui=NONE ctermfg=126 ctermbg=NONE cterm=NONE
-hi rubypredefinedidentifier guifg=#de5577 guibg=NONE guisp=NONE gui=NONE ctermfg=168 ctermbg=NONE cterm=NONE
-hi function guifg=#fad07a guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi directory guifg=#dad085 guibg=NONE guisp=NONE gui=NONE ctermfg=186 ctermbg=NONE cterm=NONE
-hi rubysymbol guifg=#7697d6 guibg=NONE guisp=NONE gui=NONE ctermfg=110 ctermbg=NONE cterm=NONE
-hi rubycontrol guifg=#7597c6 guibg=NONE guisp=NONE gui=NONE ctermfg=110 ctermbg=NONE cterm=NONE
-hi rubyidentifier guifg=#c6b6fe guibg=NONE guisp=NONE gui=NONE ctermfg=147 ctermbg=NONE cterm=NONE
-hi mbenormal guifg=#cfbfad guibg=#2e2e3f guisp=#2e2e3f gui=NONE ctermfg=187 ctermbg=237 cterm=NONE
-hi perlspecialstring guifg=#c080d0 guibg=#404040 guisp=#404040 gui=NONE ctermfg=176 ctermbg=238 cterm=NONE
-hi doxygenspecial guifg=#fdd090 guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi mbechanged guifg=#eeeeee guibg=#2e2e3f guisp=#2e2e3f gui=NONE ctermfg=255 ctermbg=237 cterm=NONE
-hi mbevisiblechanged guifg=#eeeeee guibg=#4e4e8f guisp=#4e4e8f gui=NONE ctermfg=255 ctermbg=60 cterm=NONE
-hi doxygenparam guifg=#fdd090 guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi doxygensmallspecial guifg=#fdd090 guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi doxygenprev guifg=#fdd090 guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi perlspecialmatch guifg=#c080d0 guibg=#404040 guisp=#404040 gui=NONE ctermfg=176 ctermbg=238 cterm=NONE
-hi cformat guifg=#c080d0 guibg=#404040 guisp=#404040 gui=NONE ctermfg=176 ctermbg=238 cterm=NONE
-hi lcursor guifg=#404040 guibg=#8fff8b guisp=#8fff8b gui=NONE ctermfg=238 ctermbg=120 cterm=NONE
-hi doxygenspecialmultilinedesc guifg=#ad600b guibg=NONE guisp=NONE gui=NONE ctermfg=130 ctermbg=NONE cterm=NONE
-hi taglisttagname guifg=#808bed guibg=NONE guisp=NONE gui=NONE ctermfg=105 ctermbg=NONE cterm=NONE
-hi doxygenbrief guifg=#fdab60 guibg=NONE guisp=NONE gui=NONE ctermfg=215 ctermbg=NONE cterm=NONE
-hi mbevisiblenormal guifg=#cfcfcd guibg=#4e4e8f guisp=#4e4e8f gui=NONE ctermfg=252 ctermbg=60 cterm=NONE
-hi user2 guifg=#7070a0 guibg=#3e3e5e guisp=#3e3e5e gui=NONE ctermfg=103 ctermbg=60 cterm=NONE
-hi user1 guifg=#00ff8b guibg=#3e3e5e guisp=#3e3e5e gui=NONE ctermfg=48 ctermbg=60 cterm=NONE
-hi doxygenspecialonelinedesc guifg=#ad600b guibg=NONE guisp=NONE gui=NONE ctermfg=130 ctermbg=NONE cterm=NONE
-hi doxygencomment guifg=#ad7b20 guibg=NONE guisp=NONE gui=NONE ctermfg=130 ctermbg=NONE cterm=NONE
-hi cspecialcharacter guifg=#c080d0 guibg=#404040 guisp=#404040 gui=NONE ctermfg=176 ctermbg=238 cterm=NONE
-hi pythonimport guifg=#009000 guibg=NONE guisp=NONE gui=NONE ctermfg=28 ctermbg=NONE cterm=NONE
-hi pythonexception guifg=#f00000 guibg=NONE guisp=NONE gui=NONE ctermfg=196 ctermbg=NONE cterm=NONE
-hi pythonbuiltinfunction guifg=#009000 guibg=NONE guisp=NONE gui=NONE ctermfg=28 ctermbg=NONE cterm=NONE
-hi pythonoperator guifg=#7e8aa2 guibg=NONE guisp=NONE gui=NONE ctermfg=103 ctermbg=NONE cterm=NONE
-hi pythonexclass guifg=#009000 guibg=NONE guisp=NONE gui=NONE ctermfg=28 ctermbg=NONE cterm=NONE
-hi pythonbuiltin guifg=#839496 guibg=NONE guisp=NONE gui=NONE ctermfg=66 ctermbg=NONE cterm=NONE
-hi phpstringdouble guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi htmltagname guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi javascriptstrings guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi htmlstring guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
-hi phpstringsingle guifg=#e2e4e5 guibg=NONE guisp=NONE gui=NONE ctermfg=254 ctermbg=NONE cterm=NONE
Index: b/colors/jellybeans.vim
deleted file mode 100644
===================================================================
--- a/colors/jellybeans.vim
+++ /dev/null
@@ -1,149 +0,0 @@
-" Vim color file - jellybeans
-" Generated by http://bytefluent.com/vivify 2014-01-04
-set background=dark
-if version > 580
-	hi clear
-	if exists("syntax_on")
-		syntax reset
-	endif
-endif
-
-set t_Co=256
-let g:colors_name = "jellybeans"
-
-"hi IncSearch -- no settings --
-"hi WildMenu -- no settings --
-hi SignColumn guifg=#a0a8b0 guibg=#384048 guisp=#384048 gui=NONE ctermfg=103 ctermbg=238 cterm=NONE
-hi SpecialComment guifg=#799d6a guibg=NONE guisp=NONE gui=NONE ctermfg=65 ctermbg=NONE cterm=NONE
-hi Typedef guifg=#ffb964 guibg=NONE guisp=NONE gui=NONE ctermfg=215 ctermbg=NONE cterm=NONE
-hi Title guifg=#70b950 guibg=NONE guisp=NONE gui=bold ctermfg=107 ctermbg=NONE cterm=bold
-hi Folded guifg=#a0a8b0 guibg=#384048 guisp=#384048 gui=italic ctermfg=103 ctermbg=238 cterm=NONE
-hi PreCondit guifg=#8fbfdc guibg=NONE guisp=NONE gui=NONE ctermfg=110 ctermbg=NONE cterm=NONE
-hi Include guifg=#8fbfdc guibg=NONE guisp=NONE gui=NONE ctermfg=110 ctermbg=NONE cterm=NONE
-hi TabLineSel guifg=#000000 guibg=#f0f0f0 guisp=#f0f0f0 gui=italic ctermfg=NONE ctermbg=255 cterm=NONE
-hi StatusLineNC guifg=#a0a0a0 guibg=#181818 guisp=#181818 gui=italic ctermfg=247 ctermbg=234 cterm=NONE
-"hi CTagsMember -- no settings --
-hi NonText guifg=#808080 guibg=#151515 guisp=#151515 gui=NONE ctermfg=8 ctermbg=233 cterm=NONE
-"hi CTagsGlobalConstant -- no settings --
-hi DiffText guifg=NONE guibg=#000940 guisp=#000940 gui=NONE ctermfg=NONE ctermbg=17 cterm=NONE
-hi ErrorMsg guifg=NONE guibg=#902020 guisp=#902020 gui=NONE ctermfg=NONE ctermbg=88 cterm=NONE
-"hi Ignore -- no settings --
-hi Debug guifg=#799d6a guibg=NONE guisp=NONE gui=NONE ctermfg=65 ctermbg=NONE cterm=NONE
-hi PMenuSbar guifg=NONE guibg=#848688 guisp=#848688 gui=NONE ctermfg=NONE ctermbg=102 cterm=NONE
-hi Identifier guifg=#c6b6ee guibg=NONE guisp=NONE gui=NONE ctermfg=183 ctermbg=NONE cterm=NONE
-hi SpecialChar guifg=#799d6a guibg=NONE guisp=NONE gui=NONE ctermfg=65 ctermbg=NONE cterm=NONE
-hi Conditional guifg=#ffb964 guibg=NONE guisp=NONE gui=NONE ctermfg=215 ctermbg=NONE cterm=NONE
-hi StorageClass guifg=#c59f6f guibg=NONE guisp=NONE gui=NONE ctermfg=137 ctermbg=NONE cterm=NONE
-hi Todo guifg=#808080 guibg=NONE guisp=NONE gui=bold ctermfg=8 ctermbg=NONE cterm=bold
-hi Special guifg=#799d6a guibg=NONE guisp=NONE gui=NONE ctermfg=65 ctermbg=NONE cterm=NONE
-hi LineNr guifg=#605958 guibg=#151515 guisp=#151515 gui=NONE ctermfg=59 ctermbg=233 cterm=NONE
-hi StatusLine guifg=#f0f0f0 guibg=#101010 guisp=#101010 gui=italic ctermfg=255 ctermbg=233 cterm=NONE
-hi Normal guifg=#e8e8d3 guibg=#151515 guisp=#151515 gui=NONE ctermfg=187 ctermbg=233 cterm=NONE
-hi Label guifg=#ffb964 guibg=NONE guisp=NONE gui=NONE ctermfg=215 ctermbg=NONE cterm=NONE
-"hi CTagsImport -- no settings --
-hi PMenuSel guifg=#101010 guibg=#eeeeee guisp=#eeeeee gui=NONE ctermfg=233 ctermbg=255 cterm=NONE
-hi Search guifg=#f0a0c0 guibg=#302028 guisp=#302028 gui=underline ctermfg=218 ctermbg=236 cterm=underline
-"hi CTagsGlobalVariable -- no settings --
-hi Delimiter guifg=#668799 guibg=NONE guisp=NONE gui=NONE ctermfg=66 ctermbg=NONE cterm=NONE
-hi Statement guifg=#8197bf guibg=NONE guisp=NONE gui=NONE ctermfg=103 ctermbg=NONE cterm=NONE
-"hi SpellRare -- no settings --
-"hi EnumerationValue -- no settings --
-hi Comment guifg=#888888 guibg=NONE guisp=NONE gui=italic ctermfg=102 ctermbg=NONE cterm=NONE
-hi Character guifg=#cf6a4c guibg=NONE guisp=NONE gui=NONE ctermfg=173 ctermbg=NONE cterm=NONE
-"hi Float -- no settings --
-hi Number guifg=#cf6a4c guibg=NONE guisp=NONE gui=NONE ctermfg=173 ctermbg=NONE cterm=NONE
-hi Boolean guifg=#8197bf guibg=NONE guisp=NONE gui=NONE ctermfg=103 ctermbg=NONE cterm=NONE
-hi Operator guifg=#e8e8d3 guibg=#151515 guisp=#151515 gui=NONE ctermfg=187 ctermbg=233 cterm=NONE
-hi CursorLine guifg=NONE guibg=#1c1c1c guisp=#1c1c1c gui=NONE ctermfg=NONE ctermbg=234 cterm=NONE
-"hi Union -- no settings --
-hi TabLineFill guifg=#9098a0 guibg=NONE guisp=NONE gui=NONE ctermfg=247 ctermbg=NONE cterm=NONE
-"hi Question -- no settings --
-"hi WarningMsg -- no settings --
-"hi VisualNOS -- no settings --
-hi DiffDelete guifg=#220000 guibg=#220000 guisp=#220000 gui=NONE ctermfg=52 ctermbg=52 cterm=NONE
-"hi ModeMsg -- no settings --
-hi CursorColumn guifg=NONE guibg=#1c1c1c guisp=#1c1c1c gui=NONE ctermfg=NONE ctermbg=234 cterm=NONE
-hi Define guifg=#8fbfdc guibg=NONE guisp=NONE gui=NONE ctermfg=110 ctermbg=NONE cterm=NONE
-hi Function guifg=#fad07a guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi FoldColumn guifg=#a0a8b0 guibg=#384048 guisp=#384048 gui=NONE ctermfg=103 ctermbg=238 cterm=NONE
-hi PreProc guifg=#8fbfdc guibg=NONE guisp=NONE gui=NONE ctermfg=110 ctermbg=NONE cterm=NONE
-"hi EnumerationName -- no settings --
-hi Visual guifg=NONE guibg=#404040 guisp=#404040 gui=NONE ctermfg=NONE ctermbg=238 cterm=NONE
-"hi MoreMsg -- no settings --
-"hi SpellCap -- no settings --
-hi VertSplit guifg=#181818 guibg=#181818 guisp=#181818 gui=italic ctermfg=234 ctermbg=234 cterm=NONE
-hi Exception guifg=#ffb964 guibg=NONE guisp=NONE gui=NONE ctermfg=215 ctermbg=NONE cterm=NONE
-hi Keyword guifg=#ffb964 guibg=NONE guisp=NONE gui=NONE ctermfg=215 ctermbg=NONE cterm=NONE
-hi Type guifg=#ffb964 guibg=NONE guisp=NONE gui=NONE ctermfg=215 ctermbg=NONE cterm=NONE
-hi DiffChange guifg=NONE guibg=#100920 guisp=#100920 gui=NONE ctermfg=NONE ctermbg=234 cterm=NONE
-hi Cursor guifg=NONE guibg=#b0d0f0 guisp=#b0d0f0 gui=NONE ctermfg=NONE ctermbg=153 cterm=NONE
-"hi SpellLocal -- no settings --
-hi Error guifg=NONE guibg=#902020 guisp=#902020 gui=NONE ctermfg=NONE ctermbg=88 cterm=NONE
-hi PMenu guifg=#ffffff guibg=#000000 guisp=#000000 gui=NONE ctermfg=15 ctermbg=NONE cterm=NONE
-hi SpecialKey guifg=#808080 guibg=#343434 guisp=#343434 gui=NONE ctermfg=8 ctermbg=236 cterm=NONE
-hi Constant guifg=#cf6a4c guibg=NONE guisp=NONE gui=NONE ctermfg=173 ctermbg=NONE cterm=NONE
-"hi DefinedName -- no settings --
-hi Tag guifg=#799d6a guibg=NONE guisp=NONE gui=NONE ctermfg=65 ctermbg=NONE cterm=NONE
-hi String guifg=#99ad6a guibg=NONE guisp=NONE gui=NONE ctermfg=107 ctermbg=NONE cterm=NONE
-hi PMenuThumb guifg=NONE guibg=#a4a6a8 guisp=#a4a6a8 gui=NONE ctermfg=NONE ctermbg=248 cterm=NONE
-hi MatchParen guifg=#ffffff guibg=#80a090 guisp=#80a090 gui=bold ctermfg=15 ctermbg=108 cterm=bold
-"hi LocalVariable -- no settings --
-hi Repeat guifg=#ffb964 guibg=NONE guisp=NONE gui=NONE ctermfg=215 ctermbg=NONE cterm=NONE
-"hi SpellBad -- no settings --
-"hi CTagsClass -- no settings --
-hi Directory guifg=#dad085 guibg=NONE guisp=NONE gui=NONE ctermfg=186 ctermbg=NONE cterm=NONE
-hi Structure guifg=#8fbfdc guibg=NONE guisp=NONE gui=NONE ctermfg=110 ctermbg=NONE cterm=NONE
-hi Macro guifg=#8fbfdc guibg=NONE guisp=NONE gui=NONE ctermfg=110 ctermbg=NONE cterm=NONE
-"hi Underlined -- no settings --
-hi DiffAdd guifg=NONE guibg=#032218 guisp=#032218 gui=NONE ctermfg=NONE ctermbg=23 cterm=NONE
-hi TabLine guifg=#000000 guibg=#b0b8c0 guisp=#b0b8c0 gui=italic ctermfg=NONE ctermbg=7 cterm=NONE
-hi cursorim guifg=#404040 guibg=#8b8bff guisp=#8b8bff gui=NONE ctermfg=238 ctermbg=105 cterm=NONE
-"hi clear -- no settings --
-hi stringdelimiter guifg=#556633 guibg=NONE guisp=NONE gui=NONE ctermfg=101 ctermbg=NONE cterm=NONE
-hi rubyregexp guifg=#dd0093 guibg=NONE guisp=NONE gui=NONE ctermfg=162 ctermbg=NONE cterm=NONE
-hi string guifg=#99ad6a guibg=NONE guisp=NONE gui=NONE ctermfg=107 ctermbg=NONE cterm=NONE
-hi constant guifg=#cf6a4c guibg=NONE guisp=NONE gui=NONE ctermfg=173 ctermbg=NONE cterm=NONE
-hi normal guifg=#e8e8d3 guibg=#151515 guisp=#151515 gui=NONE ctermfg=187 ctermbg=233 cterm=NONE
-hi rubyinstancevariable guifg=#c6b6fe guibg=NONE guisp=NONE gui=NONE ctermfg=147 ctermbg=NONE cterm=NONE
-hi rubyclass guifg=#447799 guibg=NONE guisp=NONE gui=NONE ctermfg=67 ctermbg=NONE cterm=NONE
-hi identifier guifg=#c6b6ee guibg=NONE guisp=NONE gui=NONE ctermfg=183 ctermbg=NONE cterm=NONE
-hi comment guifg=#888888 guibg=NONE guisp=NONE gui=italic ctermfg=102 ctermbg=NONE cterm=NONE
-hi rubyregexpdelimiter guifg=#540063 guibg=NONE guisp=NONE gui=NONE ctermfg=53 ctermbg=NONE cterm=NONE
-hi rubyregexpspecial guifg=#a40073 guibg=NONE guisp=NONE gui=NONE ctermfg=126 ctermbg=NONE cterm=NONE
-hi rubypredefinedidentifier guifg=#de5577 guibg=NONE guisp=NONE gui=NONE ctermfg=168 ctermbg=NONE cterm=NONE
-hi function guifg=#fad07a guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi directory guifg=#dad085 guibg=NONE guisp=NONE gui=NONE ctermfg=186 ctermbg=NONE cterm=NONE
-hi rubysymbol guifg=#7697d6 guibg=NONE guisp=NONE gui=NONE ctermfg=110 ctermbg=NONE cterm=NONE
-hi rubycontrol guifg=#7597c6 guibg=NONE guisp=NONE gui=NONE ctermfg=110 ctermbg=NONE cterm=NONE
-hi rubyidentifier guifg=#c6b6fe guibg=NONE guisp=NONE gui=NONE ctermfg=147 ctermbg=NONE cterm=NONE
-hi mbenormal guifg=#cfbfad guibg=#2e2e3f guisp=#2e2e3f gui=NONE ctermfg=187 ctermbg=237 cterm=NONE
-hi perlspecialstring guifg=#c080d0 guibg=#404040 guisp=#404040 gui=NONE ctermfg=176 ctermbg=238 cterm=NONE
-hi doxygenspecial guifg=#fdd090 guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi mbechanged guifg=#eeeeee guibg=#2e2e3f guisp=#2e2e3f gui=NONE ctermfg=255 ctermbg=237 cterm=NONE
-hi mbevisiblechanged guifg=#eeeeee guibg=#4e4e8f guisp=#4e4e8f gui=NONE ctermfg=255 ctermbg=60 cterm=NONE
-hi doxygenparam guifg=#fdd090 guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi doxygensmallspecial guifg=#fdd090 guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi doxygenprev guifg=#fdd090 guibg=NONE guisp=NONE gui=NONE ctermfg=222 ctermbg=NONE cterm=NONE
-hi perlspecialmatch guifg=#c080d0 guibg=#404040 guisp=#404040 gui=NONE ctermfg=176 ctermbg=238 cterm=NONE
-hi cformat guifg=#c080d0 guibg=#404040 guisp=#404040 gui=NONE ctermfg=176 ctermbg=238 cterm=NONE
-hi lcursor guifg=#404040 guibg=#8fff8b guisp=#8fff8b gui=NONE ctermfg=238 ctermbg=120 cterm=NONE
-hi doxygenspecialmultilinedesc guifg=#ad600b guibg=NONE guisp=NONE gui=NONE ctermfg=130 ctermbg=NONE cterm=NONE
-hi taglisttagname guifg=#808bed guibg=NONE guisp=NONE gui=NONE ctermfg=105 ctermbg=NONE cterm=NONE
-hi doxygenbrief guifg=#fdab60 guibg=NONE guisp=NONE gui=NONE ctermfg=215 ctermbg=NONE cterm=NONE
-hi mbevisiblenormal guifg=#cfcfcd guibg=#4e4e8f guisp=#4e4e8f gui=NONE ctermfg=252 ctermbg=60 cterm=NONE
-hi user2 guifg=#7070a0 guibg=#3e3e5e guisp=#3e3e5e gui=NONE ctermfg=103 ctermbg=60 cterm=NONE
-hi user1 guifg=#00ff8b guibg=#3e3e5e guisp=#3e3e5e gui=NONE ctermfg=48 ctermbg=60 cterm=NONE
-hi doxygenspecialonelinedesc guifg=#ad600b guibg=NONE guisp=NONE gui=NONE ctermfg=130 ctermbg=NONE cterm=NONE
-hi doxygencomment guifg=#ad7b20 guibg=NONE guisp=NONE gui=NONE ctermfg=130 ctermbg=NONE cterm=NONE
-hi cspecialcharacter guifg=#c080d0 guibg=#404040 guisp=#404040 gui=NONE ctermfg=176 ctermbg=238 cterm=NONE
-hi pythonimport guifg=#919092 guibg=NONE guisp=NONE gui=NONE ctermfg=246 ctermbg=NONE cterm=NONE
-hi pythonexception guifg=#02cc89 guibg=NONE guisp=NONE gui=NONE ctermfg=42 ctermbg=NONE cterm=NONE
-hi pythonbuiltinfunction guifg=#919092 guibg=NONE guisp=NONE gui=NONE ctermfg=246 ctermbg=NONE cterm=NONE
-hi pythonoperator guifg=#a38282 guibg=NONE guisp=NONE gui=NONE ctermfg=138 ctermbg=NONE cterm=NONE
-hi pythonexclass guifg=#919092 guibg=NONE guisp=NONE gui=NONE ctermfg=246 ctermbg=NONE cterm=NONE
-hi pythonbuiltin guifg=#968388 guibg=NONE guisp=NONE gui=NONE ctermfg=246 ctermbg=NONE cterm=NONE
-hi phpstringdouble guifg=#0202cc guibg=NONE guisp=NONE gui=NONE ctermfg=20 ctermbg=NONE cterm=NONE
-hi htmltagname guifg=#0202cc guibg=NONE guisp=NONE gui=NONE ctermfg=20 ctermbg=NONE cterm=NONE
-hi javascriptstrings guifg=#0202cc guibg=NONE guisp=NONE gui=NONE ctermfg=20 ctermbg=NONE cterm=NONE
-hi htmlstring guifg=#0202cc guibg=NONE guisp=NONE gui=NONE ctermfg=20 ctermbg=NONE cterm=NONE
-hi phpstringsingle guifg=#0202cc guibg=NONE guisp=NONE gui=NONE ctermfg=20 ctermbg=NONE cterm=NONE
Index: b/doc/Powerline.txt
deleted file mode 100644
===================================================================
--- a/doc/Powerline.txt
+++ /dev/null
@@ -1,439 +0,0 @@
-*Powerline.txt*	For Vim version 7.3.	Last change: 2011 Nov 23
-
-                                            ______
-         _________                          \    /__
-         \_____   \______  _  _____________ /   /'__' ___   ____
-          |    ___/  _ \ \/ \/ / __ \_  ___\   / |  |/   \_/ __ \
-          |   |  |  (_) \  _  /  ___/|  |  /  /__|  |  |  \  ___/
-          '___'   \____/ \/ \/ \___  |__' /___  /'__'__|  /\___ \
-                                   \/        / /        \/     \/
-                                            | /
-                                            |/
-                                            '
-
-==============================================================================
-CONTENTS                                                  *Powerline-contents*
-
-    1. Introduction ....................... |Powerline-introduction|
-    2. Usage .............................. |Powerline-usage|
-    3. Requirements ....................... |Powerline-requirements|
-       3.1 Recommended settings ........... |Powerline-recommended-settings|
-    4. Configuration ...................... |Powerline-configuration|
-       4.1 Powerline_cache_file ........... |Powerline_cache_file|
-           4.1.1 Clearing the cache ....... |:PowerlineClearCache|
-           4.1.2 Powerline_cache_dir ...... |Powerline_cache_dir|
-       4.2 Powerline_cache_enabled ........ |Powerline_cache_enabled|
-       4.3 Powerline_symbols .............. |Powerline_symbols|
-           4.3.1 Compatible symbols ....... |Powerline-symbols-compatible|
-           4.3.2 Fancy symbols ............ |Powerline-symbols-fancy|
-           4.3.3 Overriding symbols ....... |Powerline_symbols_override|
-           4.3.4 Overriding dividers ...... |Powerline_dividers_override|
-       4.4 Powerline_theme ................ |Powerline_theme|
-       4.5 Powerline_colorscheme .......... |Powerline_colorscheme|
-       4.6 Powerline_stl_path_style ....... |Powerline_stl_path_style|
-    5. Fonts .............................. |Powerline-fonts|
-    6. Customization ...................... |Powerline-customization|
-       6.1 Basic customization ............ |Powerline-basic-customization|
-       6.2 Advanced customization ......... |Powerline-advanced-customization|
-           6.2.1 Colorschemes ............. |Powerline-cust-colorschemes|
-           6.2.2 Functions ................ |Powerline-cust-functions|
-           6.2.3 Segments ................. |Powerline-cust-segments|
-           6.2.4 Themes ................... |Powerline-cust-themes|
-    7. License ............................ |Powerline-license|
-    8. Known issues ....................... |Powerline-known-issues|
-    9. Contributing ....................... |Powerline-contributing|
-
-==============================================================================
-1. Introduction                           *Powerline* *Powerline-introduction*
-
-Powerline is a utility plugin which allows you to create better-looking, more 
-functional Vim statuslines.
-
-==============================================================================
-2. Usage                                                     *Powerline-usage*
-
-Powerline is automatically enabled when it's installed, either by unzipping 
-the provided archive or by adding it as a Pathogen/Vundle bundle.
-
-Powerline replaces the standard Vim 'statusline' with a custom statusline made 
-up of Powerline segments.
-
-Powerline ignores any 'statusline' customizations you have defined in your 
-|vimrc|. If you remove Powerline, your 'statusline' customizations are 
-restored.
-
-==============================================================================
-3. Requirements                                       *Powerline-requirements*
-
-Powerline has been developed and tested in Vim 7.3, but it should run without 
-any problems in Vim 7.2. The default configuration requires a Unix-like system 
-to work properly.
-
-The plugin only works with Vim running in an 88/256-color terminal or Gvim.
-
-Vi-compatible mode must be disabled.
-
-------------------------------------------------------------------------------
-3.1 Recommended settings                      *Powerline-recommended-settings*
-
-The following configuration options should be set in your |vimrc|: >
-
-    set nocompatible   " Disable vi-compatibility
-    set laststatus=2   " Always show the statusline
-    set encoding=utf-8 " Necessary to show Unicode glyphs
-
-Note: If you're using an 88/256-color terminal but still don't see the colored 
-statusline, you may have to set the following option as well: >
-
-    set t_Co=256 " Explicitly tell Vim that the terminal supports 256 colors
-
-==============================================================================
-4. Configuration                                     *Powerline-configuration*
-
-Powerline will work fine without any user configuration, but default behavior 
-can be overridden by setting configuration variables globally in your |vimrc| 
-file.
-
-------------------------------------------------------------------------------
-4.1 Powerline_cache_file                                *Powerline_cache_file*
-
-By default Powerline caches all the statuslines and colors in a cache file in 
-the plugin's directory (or the Vim directory, depending on the installation 
-method used).
-
-It's recommended that you enable the cache, as this dramatically improves Vim 
-startup time after the cache file has been generated (the plugin usually loads 
-within ~100ms without the cache and ~1ms with the cache).
-
-Note: The default cache filename includes the current theme, colorscheme and 
-symbol settings in order to tie the cache file to your current configuration, 
-so the cache file will be regenerated when you change any settings. This may 
-leave several old cache files in your Vim folder, and these may safely be 
-deleted.
-
-Defaults: "|Powerline_cache_dir|/Powerline_<theme>_<colorscheme>_<symbols>.cache"
-
-------------------------------------------------------------------------------
-4.1.1 Powerline_cache_dir                                *Powerline_cache_dir*
-
-This is the directory used for |Powerline_cache_file|.
-
-Default: Plugin directory: >
-
-    let g:Powerline_cache_dir = simplify(expand('<sfile>:p:h') .'/..')
-<
-------------------------------------------------------------------------------
-4.1.2 Clearing the cache                                *:PowerlineClearCache*
-
-Powerline provides a command to easily clear the cache after changing your 
-settings or updating your theme. Simply run the following command to clear 
-your cache, and restart Vim afterwards: >
-
-    :PowerlineClearCache
-<
-------------------------------------------------------------------------------
-4.2 Powerline_cache_enabled                          *Powerline_cache_enabled*
-
-It's possible to disable statusline caching by setting this option to 0. This 
-is mostly useful when developing statuslines.
-
-Example: >
-
-    let g:Powerline_cache_enabled = 0
-<
-
-Default: 1
-
-------------------------------------------------------------------------------
-4.3 Powerline_symbols                                      *Powerline_symbols*
-
-This option defines which set of symbols and dividers you want to use. There 
-are currently three available options: "compatible", "unicode" and "fancy".
-
-    TYPE           DESCRIPTION ~
-    compatible     Doesn't use any special characters.
-    unicode        Simulates icons and arrows using similar Unicode glyphs.
-    fancy          Custom icons and arrows. Requires a patched font.
-
-Example: >
-
-    let g:Powerline_symbols = 'fancy'
-<
-
-Default: "compatible"
-
-Symbols can be inserted into statuslines by using the following variables 
-(just insert the variables as text in your segments):
-
-    VARIABLE       DESCRIPTION ~
-    $BRANCH        Inserts a branch symbol
-    $RO            Inserts a read-only symbol
-    $FT            Inserts a filetype symbol
-    $LINE          Inserts a line number symbol
-
-------------------------------------------------------------------------------
-4.3.1 Compatible symbols                        *Powerline-symbols-compatible*
-
-These symbols will work in any configuration, and do not require a special 
-font to work. This option will replace the fancy icons with plain text, and 
-the pointy dividers with straight lines.
-
-------------------------------------------------------------------------------
-4.3.2 Fancy symbols                                  *Powerline-symbols-fancy*
-
-These symbols require a custom font to work. A font patcher is provided for 
-adding the required symbols to any outline font and some bitmap fonts, see 
-|Powerline-fonts| and the provided README file for usage details.
-
-------------------------------------------------------------------------------
-4.3.3 Overriding symbols                          *Powerline_symbols_override*
-
-You can override symbols by adding your symbols to the 
-g:Powerline_symbols_override dictionary. Example: If you want the branch 
-symbol to be "∓" (hex code 0x2213) and the line symbol to be "L" you can add 
-the following to your |vimrc|: >
-
-    let g:Powerline_symbols_override = {
-        \ 'BRANCH': [0x2213],
-        \ 'LINE': 'L',
-        \ }
-<
-------------------------------------------------------------------------------
-4.3.4 Overriding dividers                        *Powerline_dividers_override*
-
-If you for some reason want to override the dividers then you can set 
-g:Powerline_dividers_override to a list with exactly four elements:
-
-    1: Hard right-pointing arrow
-    2: Soft right-pointing arrow
-    3: Hard left-pointing arrow
-    4: Soft left-pointing arrow
-
-Example: >
-
-    let g:Powerline_dividers_override = ['>>', '>', '<<', '<']
-<
-
-------------------------------------------------------------------------------
-4.3.5 Overriding mode names                                   *Powerline_mode*
-
-You can change the names used for modes at the far left by setting some
-variables in your |vimrc|. For example you can change "N" to "NORMAL" with: >
-
-    let g:Powerline_mode_n = 'NORMAL'
-<
-The variables are all named beginning with 'g:Powerline_mode_', as follows:
-
-mode                name    default       note ~
-Normal              n       ' N '         (surrounded by spaces)
-Insert              i       INSERT
-Replace             R       REPLACE       |Replace-mode|
-Visual              v       VISUAL        |Visual-mode|
-Visual linewise     V       V⋅LINE
-Visual blockwise    cv      V⋅BLOCK
-Select              s       SELECT        |Select-mode|
-Select linewise     S       S⋅LINE
-Select blockwise    cs      S⋅BLOCK
-
------------------------------------------------------------------------------
-4.4 Powerline_theme                                          *Powerline_theme*
-
-This option defines the theme Powerline uses. The available themes are located 
-in autoload/Powerline/Themes/. A theme is a pre-defined set of Powerline 
-segments which make up the statusline.
-
-Example: >
-
-    let g:Powerline_theme = 'solarized256'
-<
-
-Default: "default"
-
-------------------------------------------------------------------------------
-4.5 Powerline_colorscheme                              *Powerline_colorscheme*
-
-This option defines the colorscheme Powerline uses. The available colorschemes 
-are located in autoload/Powerline/Colorschemes/.
-
-Example: >
-
-    let g:Powerline_colorscheme = 'solarized256'
-<
-
-Default: "default"
-
-------------------------------------------------------------------------------
-4.6 Powerline_stl_path_style                        *Powerline_stl_path_style*
-
-There are currently four ways to display the current path and file name. The 
-default is to only display the file name like the %t statusline item. By 
-setting this configuration value you can choose from the following ways 
-display the current path and file name:
-
-    VALUE      DESCRIPTION ~
-    filename   Display only the file name using the %t statusline item.
-    short      Display a short path. The home directory is substituted with
-               "~", the first directory is displayed with its full name, and
-               subsequent directories are shortened to their first letter.
-               I.e. "/home/user/foo/bar/baz.vim" becomes "~/f/b/baz.vim" and
-               "long/relative/path/foo/bar/baz.vim becomes
-               "long/r/p/f/b/baz.vim".
-    relative   Display a relative path, similar to the %f statusline item.
-    full       Display the full path, similar to the %F statusline item.
-
-Example: >
-
-    let g:Powerline_stl_path_style = 'full'
-<
-
-Default: "relative"
-
-==============================================================================
-5. Fonts                                                     *Powerline-fonts*
-
-TODO
-
-==============================================================================
-6. Customization                                     *Powerline-customization*
-
-There are currently two ways of customizing Powerline: Basic customization 
-using a couple of functions to insert and remove existing segments from the 
-statusline, and advanced customization using your own autoload files. The 
-customization features of Powerline allow you to create your own statuslines 
-without ever touching the original source code.
-
-------------------------------------------------------------------------------
-6.1 Basic customization                        *Powerline-basic-customization*
-
-Powerline provides the following functions to alter the default statusline 
-look. These functions should be called from your |vimrc| file or another file 
-which is sourced at Vim startup.
-
-Note: These functions are currently applied to all statuslines, so if you 
-insert a segment after a segment which is present in many statuslines (e.g.  
-the "filename" segment), all the statuslines will have the inserted segment.  
-This behavior may be changed in a future version of Powerline.
-
-Note: Remember to clear your cache with |:PowerlineClearCache| after changing 
-your statusline!
-
-Example: >
-
-    " Insert the charcode segment after the filetype segment
-    call Pl#Theme#InsertSegment('charcode', 'after', 'filetype')
-
-    " Replace the scrollpercent segment with the charcode segment
-    call Pl#Theme#ReplaceSegment('scrollpercent', 'fileinfo')
-<
-                                                      *Pl#Theme#InsertSegment*
-Pl#Theme#InsertSegment({newsegment}, {location}, {targetsegment})
-
-This function inserts {newsegment} before or after {targetsegment}. The 
-{location} parameter specifies the location of the new segment, valid values 
-are "before" and "after". You can see all the available segments in 
-autoload/Powerline/Segments.vim and the files specified in 
-|Powerline-cust-segments|.
-
-Pl#Theme#RemoveSegment({targetsegment})               *Pl#Theme#RemoveSegment*
-
-This function removes the {targetsegment} segment entirely.
-
-Pl#Theme#ReplaceSegment({oldsegment}, {newsegment})  *Pl#Theme#ReplaceSegment*
-
-This function replaces {oldsegment} with {newsegment}.
-
-------------------------------------------------------------------------------
-6.2 Advanced customization                  *Powerline-advanced-customization*
-
-Because Powerline utilizes Vim's autoload functionality, you can easily create 
-your own segments, themes, functions and colorschemes without touching the 
-original source code. This is a bit more complex than using the utility 
-functions, but it allows you to do a lot more with your statusline.
-
-Your custom autoload files should be stored in your |runtimepath| (usually in 
-"~/.vim/autoload/Powerline/*").
-
-Note: Remember to clear your cache with |:PowerlineClearCache| after changing 
-your statusline!
-
-6.2.1 Colorschemes                               *Powerline-cust-colorschemes*
-------------------------------------------------------------------------------
-
-Colorschemes should be stored as separate files in 
-{runtimepath}/autoload/Powerline/Colorschemes/.
-
-SYNTAX ~
-
-TODO
-
-EXAMPLE ~
-
-TODO
-
-6.2.2 Functions                                     *Powerline-cust-functions*
-------------------------------------------------------------------------------
-
-Functions should be stored as separate files in 
-{runtimepath}/autoload/Powerline/Functions/.
-
-SYNTAX ~
-
-TODO
-
-EXAMPLE ~
-
-TODO
-
-6.2.3 Segments                                       *Powerline-cust-segments*
-------------------------------------------------------------------------------
-
-Segments should be stored as separate files in 
-{runtimepath}/autoload/Powerline/Segments/.
-
-SYNTAX ~
-
-TODO
-
-EXAMPLE ~
-
-TODO
-
-6.2.4 Themes                                           *Powerline-cust-themes*
-------------------------------------------------------------------------------
-
-Themes should be stored as separate files in 
-{runtimepath}/autoload/Powerline/Themes/.
-
-SYNTAX ~
-
-TODO
-
-EXAMPLE ~
-
-TODO
-
-==============================================================================
-7. License                                                 *Powerline-license*
-
-Creative Commons Attribution-ShareAlike 3.0 Unported
-
-http://creativecommons.org/licenses/by-sa/3.0/
-
-==============================================================================
-8. Known issues                                       *Powerline-known-issues*
-
-See the issue tracker at
-https://github.com/Lokaltog/vim-powerline/issues
-
-==============================================================================
-9. Contributing                                       *Powerline-contributing*
-
-If you experience any bugs or have feature requests, please open an issue on
-GitHub. Fork the source repository on GitHub and send a pull request if you
-have any code improvements.
-
-Author: Kim Silkebækken <kim.silkebaekken+vim@gmail.com>
-Source repository: https://github.com/Lokaltog/vim-powerline
-
-==============================================================================
-vim:tw=78:sw=4:ts=8:ft=help:norl:
Index: b/doc/taglist.txt
deleted file mode 100644
===================================================================
--- a/doc/taglist.txt
+++ /dev/null
@@ -1,1501 +0,0 @@
-*taglist.txt*	Plugin for browsing source code
-
-Author: Yegappan Lakshmanan  (yegappan AT yahoo DOT com)
-For Vim version 6.0 and above
-Last change: 2007 May 24
-
-1. Overview 					|taglist-intro|
-2. Taglist on the internet			|taglist-internet|
-3. Requirements					|taglist-requirements|
-4. Installation 				|taglist-install|
-5. Usage 					|taglist-using|
-6. Options 					|taglist-options|
-7. Commands 					|taglist-commands|
-8. Global functions 				|taglist-functions|
-9. Extending 					|taglist-extend|
-10. FAQ 					|taglist-faq|
-11. License 					|taglist-license|
-12. Todo					|taglist-todo|
-
-==============================================================================
-						*taglist-intro*
-1. Overview~
-
-The "Tag List" plugin is a source code browser plugin for Vim. This plugin
-allows you to efficiently browse through source code files for different
-programming languages. The "Tag List" plugin provides the following features:
-
-    * Displays the tags (functions, classes, structures, variables, etc.) 
-      defined in a file in a vertically or horizontally split Vim window.
-    * In GUI Vim, optionally displays the tags in the Tags drop-down menu and
-      in the popup menu.
-    * Automatically updates the taglist window as you switch between
-      files/buffers. As you open new files, the tags defined in the new files
-      are added to the existing file list and the tags defined in all the
-      files are displayed grouped by the filename.
-    * When a tag name is selected from the taglist window, positions the
-      cursor at the definition of the tag in the source file.
-    * Automatically highlights the current tag name.
-    * Groups the tags by their type and displays them in a foldable tree.
-    * Can display the prototype and scope of a tag.
-    * Can optionally display the tag prototype instead of the tag name in the
-      taglist window.
-    * The tag list can be sorted either by name or by chronological order.
-    * Supports the following language files: Assembly, ASP, Awk, Beta, C,
-      C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp,
-      Lua, Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang,
-      SML, Sql, TCL, Verilog, Vim and Yacc.
-    * Can be easily extended to support new languages. Support for
-      existing languages can be modified easily.
-    * Provides functions to display the current tag name in the Vim status
-      line or the window title bar.
-    * The list of tags and files in the taglist can be saved and
-      restored across Vim sessions.
-    * Provides commands to get the name and prototype of the current tag.
-    * Runs in both console/terminal and GUI versions of Vim.
-    * Works with the winmanager plugin. Using the winmanager plugin, you
-      can use Vim plugins like the file explorer, buffer explorer and the
-      taglist plugin at the same time like an IDE.
-    * Can be used in both Unix and MS-Windows systems.
-
-==============================================================================
-						*taglist-internet*
-2. Taglist on the internet~
-
-The home page of the taglist plugin is at:
->
-	http://vim-taglist.sourceforge.net/
-<
-You can subscribe to the taglist mailing list to post your questions or
-suggestions for improvement or to send bug reports. Visit the following page
-for subscribing to the mailing list:
->
-	http://groups.yahoo.com/group/taglist
-<
-==============================================================================
-						*taglist-requirements*
-3. Requirements~
-
-The taglist plugin requires the following:
-
-    * Vim version 6.0 and above
-    * Exuberant ctags 5.0 and above
-
-The taglist plugin will work on all the platforms where the exuberant ctags
-utility and Vim are supported (this includes MS-Windows and Unix based
-systems).
-
-The taglist plugin relies on the exuberant ctags utility to dynamically
-generate the tag listing.  The exuberant ctags utility must be installed in
-your system to use this plugin.  The exuberant ctags utility is shipped with
-most of the Linux distributions.  You can download the exuberant ctags utility
-from
->
-	http://ctags.sourceforge.net
-<
-The taglist plugin doesn't use or create a tags file and there is no need to
-create a tags file to use this plugin. The taglist plugin will not work with
-the GNU ctags or the Unix ctags utility.
-
-This plugin relies on the Vim "filetype" detection mechanism to determine the
-type of the current file. You have to turn on the Vim filetype detection by
-adding the following line to your .vimrc file:
->
-	filetype on
-<
-The taglist plugin will not work if you run Vim in the restricted mode (using
-the -Z command-line argument).
-
-The taglist plugin uses the Vim system() function to invoke the exuberant
-ctags utility. If Vim is compiled without the system() function then you
-cannot use the taglist plugin. Some of the Linux distributions (Suse) compile
-Vim without the system() function for security reasons.
-
-==============================================================================
-						*taglist-install*
-4. Installation~
-
-1. Download the taglist.zip file and unzip the files to the $HOME/.vim or the
-   $HOME/vimfiles or the $VIM/vimfiles directory. After this step, you should
-   have the following two files (the directory structure should be preserved):
-
-	plugin/taglist.vim - main taglist plugin file
-	doc/taglist.txt    - documentation (help) file
-
-   Refer to the |add-plugin|and |'runtimepath'| Vim help pages for more
-   details about installing Vim plugins.
-2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or $VIM/vimfiles/doc
-   directory, start Vim and run the ":helptags ." command to process the
-   taglist help file. Without this step, you cannot jump to the taglist help
-   topics.
-3. If the exuberant ctags utility is not present in one of the directories in
-   the PATH environment variable, then set the 'Tlist_Ctags_Cmd' variable to
-   point to the location of the exuberant ctags utility (not to the directory)
-   in the .vimrc file.
-4. If you are running a terminal/console version of Vim and the terminal
-   doesn't support changing the window width then set the
-   'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
-5. Restart Vim.
-6. You can now use the ":TlistToggle" command to open/close the taglist
-   window. You can use the ":help taglist" command to get more information
-   about using the taglist plugin.
-
-To uninstall the taglist plugin, remove the plugin/taglist.vim and
-doc/taglist.txt files from the $HOME/.vim or $HOME/vimfiles directory.
-
-==============================================================================
-						*taglist-using*
-5. Usage~
-
-The taglist plugin can be used in several different ways.
-
-1. You can keep the taglist window open during the entire editing session. On
-   opening the taglist window, the tags defined in all the files in the Vim
-   buffer list will be displayed in the taglist window. As you edit files, the
-   tags defined in them will be added to the taglist window. You can select a
-   tag from the taglist window and jump to it. The current tag will be
-   highlighted in the taglist window. You can close the taglist window when
-   you no longer need the window.
-2. You can configure the taglist plugin to process the tags defined in all the
-   edited files always. In this configuration, even if the taglist window is
-   closed and the taglist menu is not displayed, the taglist plugin will
-   processes the tags defined in newly edited files. You can then open the
-   taglist window only when you need to select a tag and then automatically
-   close the taglist window after selecting the tag.
-3. You can configure the taglist plugin to display only the tags defined in
-   the current file in the taglist window. By default, the taglist plugin
-   displays the tags defined in all the files in the Vim buffer list. As you
-   switch between files, the taglist window will be refreshed to display only
-   the tags defined in the current file.
-4. In GUI Vim, you can use the Tags pull-down and popup menu created by the
-   taglist plugin to display the tags defined in the current file and select a
-   tag to jump to it. You can use the menu without opening the taglist window.
-   By default, the Tags menu is disabled.
-5. You can configure the taglist plugin to display the name of the current tag
-   in the Vim window status line or in the Vim window title bar. For this to
-   work without the taglist window or menu, you need to configure the taglist
-   plugin to process the tags defined in a file always.
-6. You can save the tags defined in multiple files to a taglist session file
-   and load it when needed. You can also configure the taglist plugin to not
-   update the taglist window when editing new files. You can then manually add
-   files to the taglist window.
-
-Opening the taglist window~
-You can open the taglist window using the ":TlistOpen" or the ":TlistToggle"
-commands. The ":TlistOpen" command opens the taglist window and jumps to it.
-The ":TlistToggle" command opens or closes (toggle) the taglist window and the
-cursor remains in the current window. If the 'Tlist_GainFocus_On_ToggleOpen'
-variable is set to 1, then the ":TlistToggle" command opens the taglist window
-and moves the cursor to the taglist window.
-
-You can map a key to invoke these commands. For example, the following command
-creates a normal mode mapping for the <F8> key to toggle the taglist window.
->
-	nnoremap <silent> <F8> :TlistToggle<CR>
-<
-Add the above mapping to your ~/.vimrc or $HOME/_vimrc file.
-
-To automatically open the taglist window on Vim startup, set the
-'Tlist_Auto_Open' variable to 1.
-
-You can also open the taglist window on startup using the following command
-line:
->
-	$ vim +TlistOpen
-<
-Closing the taglist window~
-You can close the taglist window from the taglist window by pressing 'q' or
-using the Vim ":q" command. You can also use any of the Vim window commands to
-close the taglist window. Invoking the ":TlistToggle" command when the taglist
-window is opened, closes the taglist window. You can also use the
-":TlistClose" command to close the taglist window.
-
-To automatically close the taglist window when a tag or file is selected, you
-can set the 'Tlist_Close_On_Select' variable to 1.  To exit Vim when only the
-taglist window is present, set the 'Tlist_Exit_OnlyWindow' variable to 1.
-
-Jumping to a tag or a file~
-You can select a tag in the taglist window either by pressing the <Enter> key
-or by double clicking the tag name using the mouse. To jump to a tag on a
-single mouse click set the 'Tlist_Use_SingleClick' variable to 1.
-
-If the selected file is already opened in a window, then the cursor is moved
-to that window. If the file is not currently opened in a window then the file
-is opened in the window used by the taglist plugin to show the previously
-selected file. If there are no usable windows, then the file is opened in a
-new window.  The file is not opened in special windows like the quickfix
-window, preview window and windows containing buffer with the 'buftype' option
-set.
-
-To jump to the tag in a new window, press the 'o' key. To open the file in the
-previous window (Ctrl-W_p) use the 'P' key. You can press the 'p' key to jump
-to the tag but still keep the cursor in the taglist window (preview).
-
-To open the selected file in a tab, use the 't' key.  If the file is already
-present in a tab then the cursor is moved to that tab otherwise the file is
-opened in a new tab. To jump to a tag in a new tab press Ctrl-t.  The taglist
-window is automatically opened in the newly created tab.
-
-Instead of jumping to a tag, you can open a file by pressing the <Enter> key
-or by double clicking the file name using the mouse.
-
-In the taglist window, you can use the [[ or <Backspace> key to jump to the
-beginning of the previous file. You can use the ]] or <Tab> key to jump to the
-beginning of the next file. When you reach the first or last file, the search
-wraps around and the jumps to the next/previous file.
-
-Highlighting the current tag~
-The taglist plugin automatically highlights the name of the current tag in the
-taglist window. The Vim |CursorHold| autocmd event is used for this. If the
-current tag name is not visible in the taglist window, then the taglist window
-contents are scrolled to make that tag name visible. You can also use the
-":TlistHighlightTag" command to force the highlighting of the current tag.
-
-The tag name is highlighted if no activity is performed for |'updatetime'|
-milliseconds. The default value for this Vim option is 4 seconds. To avoid
-unexpected problems, you should not set the |'updatetime'| option to a very
-low value.
-
-To disable the automatic highlighting of the current tag name in the taglist
-window, set the 'Tlist_Auto_Highlight_Tag' variable to zero.
-
-When entering a Vim buffer/window, the taglist plugin automatically highlights
-the current tag in that buffer/window.  If you like to disable the automatic
-highlighting of the current tag when entering a buffer, set the
-'Tlist_Highlight_Tag_On_BufEnter' variable to zero.
-
-Adding files to the taglist~
-When the taglist window is opened, all the files in the Vim buffer list are
-processed and the supported files are added to the taglist.  When you edit a
-file in Vim, the taglist plugin automatically processes this file and adds it
-to the taglist. If you close the taglist window, the tag information in the
-taglist is retained.
-
-To process files even when the taglist window is not open, set the
-'Tlist_Process_File_Always' variable to 1.
-
-You can manually add multiple files to the taglist without opening them using
-the ":TlistAddFiles" and the ":TlistAddFilesRecursive" commands.
-
-For example, to add all the C files in the /my/project/dir directory to the
-taglist, you can use the following command:
->
-	:TlistAddFiles /my/project/dir/*.c
-<
-Note that when adding several files with a large number of tags or a large
-number of files, it will take several seconds to several minutes for the
-taglist plugin to process all the files. You should not interrupt the taglist
-plugin by pressing <CTRL-C>.
-
-You can recursively add multiple files from a directory tree using the
-":TlistAddFilesRecursive" command:
->
-	:TlistAddFilesRecursive /my/project/dir *.c
-<
-This command takes two arguments. The first argument specifies the directory
-from which to recursively add the files. The second optional argument
-specifies the wildcard matching pattern for selecting the files to add. The
-default pattern is * and all the files are added.
-
-Displaying tags for only one file~
-The taglist window displays the tags for all the files in the Vim buffer list
-and all the manually added files. To display the tags for only the current
-active buffer, set the 'Tlist_Show_One_File' variable to 1.
-
-Removing files from the taglist~
-You can remove a file from the taglist window, by pressing the 'd' key when the
-cursor is on one of the tags listed for the file in the taglist window. The
-removed file will no longer be displayed in the taglist window in the current
-Vim session. To again display the tags for the file, open the file in a Vim
-window and then use the ":TlistUpdate" command or use ":TlistAddFiles" command
-to add the file to the taglist.
-
-When a buffer is removed from the Vim buffer list using the ":bdelete" or the
-":bwipeout" command, the taglist is updated to remove the stored information
-for this buffer.
-
-Updating the tags displayed for a file~
-The taglist plugin keeps track of the modification time of a file. When the
-modification time changes (the file is modified), the taglist plugin
-automatically updates the tags listed for that file. The modification time of
-a file is checked when you enter a window containing that file or when you
-load that file.
-
-You can also update or refresh the tags displayed for a file by pressing the
-"u" key in the taglist window. If an existing file is modified, after the file
-is saved, the taglist plugin automatically updates the tags displayed for the
-file.
-
-You can also use the ":TlistUpdate" command to update the tags for the current
-buffer after you made some changes to it. You should save the modified buffer
-before you update the taglist window. Otherwise the listed tags will not
-include the new tags created in the buffer. 
-
-If you have deleted the tags displayed for a file in the taglist window using
-the 'd' key, you can again display the tags for that file using the
-":TlistUpdate" command.
-
-Controlling the taglist updates~
-To disable the automatic processing of new files or modified files, you can
-set the 'Tlist_Auto_Update' variable to zero. When this variable is set to
-zero, the taglist is updated only when you use the ":TlistUpdate" command or
-the ":TlistAddFiles" or the ":TlistAddFilesRecursive" commands. You can use
-this option to control which files are added to the taglist.
-
-You can use the ":TlistLock" command to lock the taglist contents. After this
-command is executed, new files are not automatically added to the taglist.
-When the taglist is locked, you can use the ":TlistUpdate" command to add the
-current file or the ":TlistAddFiles" or ":TlistAddFilesRecursive" commands to
-add new files to the taglist.  To unlock the taglist, use the ":TlistUnlock"
-command.
-
-Displaying the tag prototype~
-To display the prototype of the tag under the cursor in the taglist window,
-press the space bar. If you place the cursor on a tag name in the taglist
-window, then the tag prototype is displayed at the Vim status line after
-|'updatetime'| milliseconds. The default value for the |'updatetime'| Vim
-option is 4 seconds.
-
-You can get the name and prototype of a tag without opening the taglist window
-and the taglist menu using the ":TlistShowTag" and the ":TlistShowPrototype"
-commands. These commands will work only if the current file is already present
-in the taglist. To use these commands without opening the taglist window, set
-the 'Tlist_Process_File_Always' variable to 1.
-
-You can use the ":TlistShowTag" command to display the name of the tag at or
-before the specified line number in the specified file.  If the file name and
-line number are not supplied, then this command will display the name of the
-current tag. For example,
->
-	:TlistShowTag
-	:TlistShowTag myfile.java 100
-<
-You can use the ":TlistShowPrototype" command to display the prototype of the
-tag at or before the specified line number in the specified file.  If the file
-name and the line number are not supplied, then this command will display the
-prototype of the current tag.  For example,
->
-	:TlistShowPrototype
-	:TlistShowPrototype myfile.c 50
-<
-In the taglist window, when the mouse is moved over a tag name, the tag
-prototype is displayed in a balloon. This works only in GUI versions where
-balloon evaluation is supported.
-
-Taglist window contents~
-The taglist window contains the tags defined in various files in the taglist
-grouped by the filename and by the tag type (variable, function, class, etc.).
-For tags with scope information (like class members, structures inside
-structures, etc.), the scope information is displayed in square brackets "[]"
-after the tag name.
-
-The contents of the taglist buffer/window are managed by the taglist plugin.
-The |'filetype'| for the taglist buffer is set to 'taglist'.  The Vim
-|'modifiable'| option is turned off for the taglist buffer. You should not
-manually edit the taglist buffer, by setting the |'modifiable'| flag. If you
-manually edit the taglist buffer contents, then the taglist plugin will be out
-of sync with the taglist buffer contents and the plugin will no longer work
-correctly. To redisplay the taglist buffer contents again, close the taglist
-window and reopen it.
-
-Opening and closing the tag and file tree~
-In the taglist window, the tag names are displayed as a foldable tree using
-the Vim folding support. You can collapse the tree using the '-' key or using
-the Vim |zc| fold command. You can open the tree using the '+' key or using
-the Vim |zo| fold command. You can open all the folds using the '*' key or
-using the Vim |zR| fold command. You can also use the mouse to open/close the
-folds. You can close all the folds using the '=' key. You should not manually
-create or delete the folds in the taglist window.
-
-To automatically close the fold for the inactive files/buffers and open only
-the fold for the current buffer in the taglist window, set the
-'Tlist_File_Fold_Auto_Close' variable to 1.
-
-Sorting the tags for a file~
-The tags displayed in the taglist window can be sorted either by their name or
-by their chronological order. The default sorting method is by the order in
-which the tags appear in a file. You can change the default sort method by
-setting the 'Tlist_Sort_Type' variable to either "name" or "order". You can
-sort the tags by their name by pressing the "s" key in the taglist window. You
-can again sort the tags by their chronological order using the "s" key. Each
-file in the taglist window can be sorted using different order.
-
-Zooming in and out of the taglist window~
-You can press the 'x' key in the taglist window to maximize the taglist
-window width/height. The window will be maximized to the maximum possible
-width/height without closing the other existing windows. You can again press
-'x' to restore the taglist window to the default width/height.
-
-						*taglist-session*
-Taglist Session~
-A taglist session refers to the group of files and their tags stored in the
-taglist in a Vim session.
-
-You can save and restore a taglist session (and all the displayed tags) using
-the ":TlistSessionSave" and ":TlistSessionLoad" commands.
-
-To save the information about the tags and files in the taglist to a file, use
-the ":TlistSessionSave" command and specify the filename:
->
-	:TlistSessionSave <file name>
-<
-To load a saved taglist session, use the ":TlistSessionLoad" command: >
-
-	:TlistSessionLoad <file name>
-<
-When you load a taglist session file, the tags stored in the file will be
-added to the tags already stored in the taglist.
-
-The taglist session feature can be used to save the tags for large files or a
-group of frequently used files (like a project). By using the taglist session
-file, you can minimize the amount to time it takes to load/refresh the taglist
-for multiple files.
-
-You can create more than one taglist session file for multiple groups of
-files.
-
-Displaying the tag name in the Vim status line or the window title bar~
-You can use the Tlist_Get_Tagname_By_Line() function provided by the taglist
-plugin to display the current tag name in the Vim status line or the window
-title bar. Similarly, you can use the Tlist_Get_Tag_Prototype_By_Line()
-function to display the current tag prototype in the Vim status line or the
-window title bar.
-
-For example, the following command can be used to display the current tag name
-in the status line:
->
-	:set statusline=%<%f%=%([%{Tlist_Get_Tagname_By_Line()}]%)
-<
-The following command can be used to display the current tag name in the
-window title bar:
->
-	:set title titlestring=%<%f\ %([%{Tlist_Get_Tagname_By_Line()}]%)
-<
-Note that the current tag name can be displayed only after the file is
-processed by the taglist plugin. For this, you have to either set the
-'Tlist_Process_File_Always' variable to 1 or open the taglist window or use
-the taglist menu. For more information about configuring the Vim status line,
-refer to the documentation for the Vim |'statusline'| option.
-
-Changing the taglist window highlighting~
-The following Vim highlight groups are defined and used to highlight the
-various entities in the taglist window:
-
-    TagListTagName  - Used for tag names
-    TagListTagScope - Used for tag scope
-    TagListTitle    - Used for tag titles
-    TagListComment  - Used for comments
-    TagListFileName - Used for filenames
-
-By default, these highlight groups are linked to the standard Vim highlight
-groups. If you want to change the colors used for these highlight groups,
-prefix the highlight group name with 'My' and define it in your .vimrc or
-.gvimrc file: MyTagListTagName, MyTagListTagScope, MyTagListTitle,
-MyTagListComment and MyTagListFileName.  For example, to change the colors
-used for tag names, you can use the following command:
->
-    :highlight MyTagListTagName guifg=blue ctermfg=blue
-<
-Controlling the taglist window~
-To use a horizontally split taglist window, instead of a vertically split
-window, set the 'Tlist_Use_Horiz_Window' variable to 1.
-
-To use a vertically split taglist window on the rightmost side of the Vim
-window, set the 'Tlist_Use_Right_Window' variable to 1.
-
-You can specify the width of the vertically split taglist window, by setting
-the 'Tlist_WinWidth' variable.  You can specify the height of the horizontally
-split taglist window, by setting the 'Tlist_WinHeight' variable.
-
-When opening a vertically split taglist window, the Vim window width is
-increased to accommodate the new taglist window. When the taglist window is
-closed, the Vim window is reduced. To disable this, set the
-'Tlist_Inc_Winwidth' variable to zero.
-
-To reduce the number of empty lines in the taglist window, set the
-'Tlist_Compact_Format' variable to 1.
-
-To not display the Vim fold column in the taglist window, set the
-'Tlist_Enable_Fold_Column' variable to zero.
-
-To display the tag prototypes instead of the tag names in the taglist window,
-set the 'Tlist_Display_Prototype' variable to 1.
-
-To not display the scope of the tags next to the tag names, set the
-'Tlist_Display_Tag_Scope' variable to zero.
-
-						*taglist-keys*
-Taglist window key list~
-The following table lists the description of the keys that can be used
-in the taglist window.
-
-  Key           Description~
-
-  <CR>          Jump to the location where the tag under cursor is
-                defined.
-  o             Jump to the location where the tag under cursor is
-                defined in a new window.
-  P             Jump to the tag in the previous (Ctrl-W_p) window.
-  p             Display the tag definition in the file window and
-                keep the cursor in the taglist window itself.
-  t             Jump to the tag in a new tab. If the file is already
-                opened in a tab, move to that tab.
-  Ctrl-t	Jump to the tag in a new tab.
-  <Space>       Display the prototype of the tag under the cursor.
-  		For file names, display the full path to the file,
-		file type and the number of tags. For tag types, display the
-		tag type and the number of tags.
-  u             Update the tags listed in the taglist window
-  s             Change the sort order of the tags (by name or by order)
-  d             Remove the tags for the file under the cursor
-  x             Zoom-in or Zoom-out the taglist window
-  +             Open a fold
-  -             Close a fold
-  *             Open all folds
-  =             Close all folds
-  [[		Jump to the beginning of the previous file
-  <Backspace>	Jump to the beginning of the previous file
-  ]]		Jump to the beginning of the next file
-  <Tab>		Jump to the beginning of the next file
-  q             Close the taglist window
-  <F1>          Display help
-
-The above keys will work in both the normal mode and the insert mode.
-
-						*taglist-menu*
-Taglist menu~
-When using GUI Vim, the taglist plugin can display the tags defined in the
-current file in the drop-down menu and the popup menu. By default, this
-feature is turned off. To turn on this feature, set the 'Tlist_Show_Menu'
-variable to 1.
-
-You can jump to a tag by selecting the tag name from the menu. You can use the
-taglist menu independent of the taglist window i.e. you don't need to open the
-taglist window to get the taglist menu.
-
-When you switch between files/buffers, the taglist menu is automatically
-updated to display the tags defined in the current file/buffer.
-
-The tags are grouped by their type (variables, functions, classes, methods,
-etc.) and displayed as a separate sub-menu for each type. If all the tags
-defined in a file are of the same type (e.g. functions), then the sub-menu is
-not used.
-
-If the number of items in a tag type submenu exceeds the value specified by
-the 'Tlist_Max_Submenu_Items' variable, then the submenu will be split into
-multiple submenus. The default setting for 'Tlist_Max_Submenu_Items' is 25.
-The first and last tag names in the submenu are used to form the submenu name.
-The menu items are prefixed by alpha-numeric characters for easy selection by
-keyboard.
-
-If the popup menu support is enabled (the |'mousemodel'| option contains
-"popup"), then the tags menu is added to the popup menu. You can access
-the popup menu by right clicking on the GUI window.
-
-You can regenerate the tags menu by selecting the 'Tags->Refresh menu' entry.
-You can sort the tags listed in the menu either by name or by order by
-selecting the 'Tags->Sort menu by->Name/Order' menu entry.
-
-You can tear-off the Tags menu and keep it on the side of the Vim window
-for quickly locating the tags.
-
-Using the taglist plugin with the winmanager plugin~
-You can use the taglist plugin with the winmanager plugin. This will allow you
-to use the file explorer, buffer explorer and the taglist plugin at the same
-time in different windows. To use the taglist plugin with the winmanager
-plugin, set 'TagList' in the 'winManagerWindowLayout' variable. For example,
-to use the file explorer plugin and the taglist plugin at the same time, use
-the following setting: >
-
-	let winManagerWindowLayout = 'FileExplorer|TagList'
-<
-Getting help~
-If you have installed the taglist help file (this file), then you can use the
-Vim ":help taglist-<keyword>" command to get help on the various taglist
-topics.
-
-You can press the <F1> key in the taglist window to display the help
-information about using the taglist window. If you again press the <F1> key,
-the help information is removed from the taglist window.
-
-						*taglist-debug*
-Debugging the taglist plugin~
-You can use the ":TlistDebug" command to enable logging of the debug messages
-from the taglist plugin. To display the logged debug messages, you can use the
-":TlistMessages" command. To disable the logging of the debug messages, use
-the ":TlistUndebug" command.
-
-You can specify a file name to the ":TlistDebug" command to log the debug
-messages to a file. Otherwise, the debug messages are stored in a script-local
-variable. In the later case, to minimize memory usage, only the last 3000
-characters from the debug messages are stored.
-
-==============================================================================
-						*taglist-options*
-6. Options~
-
-A number of Vim variables control the behavior of the taglist plugin. These
-variables are initialized to a default value. By changing these variables you
-can change the behavior of the taglist plugin. You need to change these
-settings only if you want to change the behavior of the taglist plugin. You
-should use the |:let| command in your .vimrc file to change the setting of any
-of these variables. 
-
-The configurable taglist variables are listed below. For a detailed
-description of these variables refer to the text below this table.
-
-|'Tlist_Auto_Highlight_Tag'|	Automatically highlight the current tag in the
-				taglist.
-|'Tlist_Auto_Open'|		Open the taglist window when Vim starts.
-|'Tlist_Auto_Update'|		Automatically update the taglist to include
-				newly edited files.
-|'Tlist_Close_On_Select'|	Close the taglist window when a file or tag is
-				selected.
-|'Tlist_Compact_Format'|	Remove extra information and blank lines from
-       				the taglist window.
-|'Tlist_Ctags_Cmd'|		Specifies the path to the ctags utility.
-|'Tlist_Display_Prototype'|	Show prototypes and not tags in the taglist
-				window.
-|'Tlist_Display_Tag_Scope'|	Show tag scope next to the tag name.
-|'Tlist_Enable_Fold_Column'|	Show the fold indicator column in the taglist
-				window.
-|'Tlist_Exit_OnlyWindow'|	Close Vim if the taglist is the only window.
-|'Tlist_File_Fold_Auto_Close'|	Close tag folds for inactive buffers.
-|'Tlist_GainFocus_On_ToggleOpen'|
-				Jump to taglist window on open.
-|'Tlist_Highlight_Tag_On_BufEnter'|
-				On entering a buffer, automatically highlight
-				the current tag.
-|'Tlist_Inc_Winwidth'|		Increase the Vim window width to accommodate
-				the taglist window.
-|'Tlist_Max_Submenu_Items'|	Maximum number of items in a tags sub-menu.
-|'Tlist_Max_Tag_Length'|	Maximum tag length used in a tag menu entry.
-|'Tlist_Process_File_Always'|	Process files even when the taglist window is
-				closed.
-|'Tlist_Show_Menu'|		Display the tags menu.
-|'Tlist_Show_One_File'|		Show tags for the current buffer only.
-|'Tlist_Sort_Type'|		Sort method used for arranging the tags.
-|'Tlist_Use_Horiz_Window'|	Use a horizontally split window for the
-				taglist window.
-|'Tlist_Use_Right_Window'|	Place the taglist window on the right side.
-|'Tlist_Use_SingleClick'|	Single click on a tag jumps to it.
-|'Tlist_WinHeight'|		Horizontally split taglist window height.
-|'Tlist_WinWidth'|		Vertically split taglist window width.
-
-						*'Tlist_Auto_Highlight_Tag'*
-Tlist_Auto_Highlight_Tag~
-The taglist plugin will automatically highlight the current tag in the taglist
-window. If you want to disable this, then you can set the
-'Tlist_Auto_Highlight_Tag' variable to zero. Note that even though the current
-tag highlighting is disabled, the tags for a new file will still be added to
-the taglist window.
->
-	let Tlist_Auto_Highlight_Tag = 0
-<
-With the above variable set to 1, you can use the ":TlistHighlightTag" command
-to highlight the current tag.
-
-						*'Tlist_Auto_Open'*
-Tlist_Auto_Open~
-To automatically open the taglist window, when you start Vim, you can set the
-'Tlist_Auto_Open' variable to 1. By default, this variable is set to zero and
-the taglist window will not be opened automatically on Vim startup.
->
-	let Tlist_Auto_Open = 1
-<
-The taglist window is opened only when a supported type of file is opened on
-Vim startup. For example, if you open text files, then the taglist window will
-not be opened.
-
-						*'Tlist_Auto_Update'*
-Tlist_Auto_Update~
-When a new file is edited, the tags defined in the file are automatically
-processed and added to the taglist. To stop adding new files to the taglist,
-set the 'Tlist_Auto_Update' variable to zero. By default, this variable is set
-to 1.
->
-	let Tlist_Auto_Update = 0
-<
-With the above variable set to 1, you can use the ":TlistUpdate" command to
-add the tags defined in the current file to the taglist.
-
-						*'Tlist_Close_On_Select'*
-Tlist_Close_On_Select~
-If you want to close the taglist window when a file or tag is selected, then
-set the 'Tlist_Close_On_Select' variable to 1. By default, this variable is
-set zero and when you select a tag or file from the taglist window, the window
-is not closed.
->
-	let Tlist_Close_On_Select = 1
-<
-						*'Tlist_Compact_Format'*
-Tlist_Compact_Format~
-By default, empty lines are used to separate different tag types displayed for
-a file and the tags displayed for different files in the taglist window. If
-you want to display as many tags as possible in the taglist window, you can
-set the 'Tlist_Compact_Format' variable to 1 to get a compact display.
->
-	let Tlist_Compact_Format = 1
-<
-						*'Tlist_Ctags_Cmd'*
-Tlist_Ctags_Cmd~
-The 'Tlist_Ctags_Cmd' variable specifies the location (path) of the exuberant
-ctags utility. If exuberant ctags is present in any one of the directories in
-the PATH environment variable, then there is no need to set this variable.
-
-The exuberant ctags tool can be installed under different names.  When the
-taglist plugin starts up, if the 'Tlist_Ctags_Cmd' variable is not set, it
-checks for the names exuberant-ctags, exctags, ctags, ctags.exe and tags in
-the PATH environment variable.  If any one of the named executable is found,
-then the Tlist_Ctags_Cmd variable is set to that name.
-
-If exuberant ctags is not present in one of the directories specified in the
-PATH environment variable, then set this variable to point to the location of
-the ctags utility in your system. Note that this variable should point to the
-fully qualified exuberant ctags location and NOT to the directory in which
-exuberant ctags is installed. If the exuberant ctags tool is not found in
-either PATH or in the specified location, then the taglist plugin will not be
-loaded. Examples:
->
-	let Tlist_Ctags_Cmd = 'd:\tools\ctags.exe'
-	let Tlist_Ctags_Cmd = '/usr/local/bin/ctags'
-<
-						*'Tlist_Display_Prototype'*
-Tlist_Display_Prototype~
-By default, only the tag name will be displayed in the taglist window. If you
-like to see tag prototypes instead of names, set the 'Tlist_Display_Prototype'
-variable to 1. By default, this variable is set to zero and only tag names
-will be displayed.
->
-	let Tlist_Display_Prototype = 1
-<
-						*'Tlist_Display_Tag_Scope'*
-Tlist_Display_Tag_Scope~
-By default, the scope of a tag (like a C++ class) will be displayed in
-square brackets next to the tag name. If you don't want the tag scopes
-to be displayed, then set the 'Tlist_Display_Tag_Scope' to zero. By default,
-this variable is set to 1 and the tag scopes will be displayed.
->
-	let Tlist_Display_Tag_Scope = 0
-<
-						*'Tlist_Enable_Fold_Column'*
-Tlist_Enable_Fold_Column~
-By default, the Vim fold column is enabled and displayed in the taglist
-window. If you wish to disable this (for example, when you are working with a
-narrow Vim window or terminal), you can set the 'Tlist_Enable_Fold_Column'
-variable to zero.
->
-	let Tlist_Enable_Fold_Column = 1
-<
-						*'Tlist_Exit_OnlyWindow'*
-Tlist_Exit_OnlyWindow~
-If you want to exit Vim if only the taglist window is currently opened, then
-set the 'Tlist_Exit_OnlyWindow' variable to 1. By default, this variable is
-set to zero and the Vim instance will not be closed if only the taglist window
-is present.
->
-	let Tlist_Exit_OnlyWindow = 1
-<
-						*'Tlist_File_Fold_Auto_Close'*
-Tlist_File_Fold_Auto_Close~
-By default, the tags tree displayed in the taglist window for all the files is
-opened. You can close/fold the tags tree for the files manually. To
-automatically close the tags tree for inactive files, you can set the
-'Tlist_File_Fold_Auto_Close' variable to 1. When this variable is set to 1,
-the tags tree for the current buffer is automatically opened and for all the
-other buffers is closed.
->
-	let Tlist_File_Fold_Auto_Close = 1
-<
-					    *'Tlist_GainFocus_On_ToggleOpen'*
-Tlist_GainFocus_On_ToggleOpen~
-When the taglist window is opened using the ':TlistToggle' command, this
-option controls whether the cursor is moved to the taglist window or remains
-in the current window. By default, this option is set to 0 and the cursor
-remains in the current window. When this variable is set to 1, the cursor
-moves to the taglist window after opening the taglist window.
->
-	let Tlist_GainFocus_On_ToggleOpen = 1
-<
-					    *'Tlist_Highlight_Tag_On_BufEnter'*
-Tlist_Highlight_Tag_On_BufEnter~
-When you enter a Vim buffer/window, the current tag in that buffer/window is
-automatically highlighted in the taglist window. If the current tag name is
-not visible in the taglist window, then the taglist window contents are
-scrolled to make that tag name visible. If you like to disable the automatic
-highlighting of the current tag when entering a buffer, you can set the
-'Tlist_Highlight_Tag_On_BufEnter' variable to zero. The default setting for
-this variable is 1.
->
-	let Tlist_Highlight_Tag_On_BufEnter = 0
-<
-						*'Tlist_Inc_Winwidth'*
-Tlist_Inc_Winwidth~
-By default, when the width of the window is less than 100 and a new taglist
-window is opened vertically, then the window width is increased by the value
-set in the 'Tlist_WinWidth' variable to accommodate the new window. The value
-of this variable is used only if you are using a vertically split taglist
-window.
-
-If your terminal doesn't support changing the window width from Vim (older
-version of xterm running in a Unix system) or if you see any weird problems in
-the screen due to the change in the window width or if you prefer not to
-adjust the window width then set the 'Tlist_Inc_Winwidth' variable to zero.
-CAUTION: If you are using the MS-Windows version of Vim in a MS-DOS command
-window then you must set this variable to zero, otherwise the system may hang
-due to a Vim limitation (explained in :help win32-problems)
->
-	let Tlist_Inc_Winwidth = 0
-<
-						*'Tlist_Max_Submenu_Items'*
-Tlist_Max_Submenu_Items~
-If a file contains too many tags of a particular type (function, variable,
-class, etc.), greater than that specified by the 'Tlist_Max_Submenu_Items'
-variable, then the menu for that tag type will be split into multiple
-sub-menus. The default setting for the 'Tlist_Max_Submenu_Items' variable is
-25.  This can be changed by setting the 'Tlist_Max_Submenu_Items' variable:
->
-	let Tlist_Max_Submenu_Items = 20
-<
-The name of the submenu is formed using the names of the first and the last
-tag entries in that submenu.
-
-						*'Tlist_Max_Tag_Length'*
-Tlist_Max_Tag_Length~
-Only the first 'Tlist_Max_Tag_Length' characters from the tag names will be
-used to form the tag type submenu name. The default value for this variable is
-10.  Change the 'Tlist_Max_Tag_Length' setting if you want to include more or
-less characters:
->
-	let Tlist_Max_Tag_Length = 10
-<
-						*'Tlist_Process_File_Always'*
-Tlist_Process_File_Always~
-By default, the taglist plugin will generate and process the tags defined in
-the newly opened files only when the taglist window is opened or when the
-taglist menu is enabled. When the taglist window is closed, the taglist plugin
-will stop processing the tags for newly opened files.
-
-You can set the 'Tlist_Process_File_Always' variable to 1 to generate the list
-of tags for new files even when the taglist window is closed and the taglist
-menu is disabled.
->
-	let Tlist_Process_File_Always = 1
-<
-To use the ":TlistShowTag" and the ":TlistShowPrototype" commands without the
-taglist window and the taglist menu, you should set this variable to 1.
-
-						*'Tlist_Show_Menu'*
-Tlist_Show_Menu~
-When using GUI Vim, you can display the tags defined in the current file in a
-menu named "Tags". By default, this feature is turned off. To turn on this
-feature, set the 'Tlist_Show_Menu' variable to 1:
->
-	let Tlist_Show_Menu = 1
-<
-						*'Tlist_Show_One_File'*
-Tlist_Show_One_File~
-By default, the taglist plugin will display the tags defined in all the loaded
-buffers in the taglist window. If you prefer to display the tags defined only
-in the current buffer, then you can set the 'Tlist_Show_One_File' to 1. When
-this variable is set to 1, as you switch between buffers, the taglist window
-will be refreshed to display the tags for the current buffer and the tags for
-the previous buffer will be removed.
->
-	let Tlist_Show_One_File = 1
-<
-						*'Tlist_Sort_Type'*
-Tlist_Sort_Type~
-The 'Tlist_Sort_Type' variable specifies the sort order for the tags in the
-taglist window. The tags can be sorted either alphabetically by their name or
-by the order of their appearance in the file (chronological order). By
-default, the tag names will be listed by the order in which they are defined
-in the file. You can change the sort type (from name to order or from order to
-name) by pressing the "s" key in the taglist window. You can also change the
-default sort order by setting 'Tlist_Sort_Type' to "name" or "order":
->
-	let Tlist_Sort_Type = "name"
-<
-						*'Tlist_Use_Horiz_Window'*
-Tlist_Use_Horiz_Window~
-Be default, the tag names are displayed in a vertically split window. If you
-prefer a horizontally split window, then set the 'Tlist_Use_Horiz_Window'
-variable to 1. If you are running MS-Windows version of Vim in a MS-DOS
-command window, then you should use a horizontally split window instead of a
-vertically split window. Also, if you are using an older version of xterm in a
-Unix system that doesn't support changing the xterm window width, you should
-use a horizontally split window.
->
-	let Tlist_Use_Horiz_Window = 1
-<
-						*'Tlist_Use_Right_Window'*
-Tlist_Use_Right_Window~
-By default, the vertically split taglist window will appear on the left hand
-side. If you prefer to open the window on the right hand side, you can set the
-'Tlist_Use_Right_Window' variable to 1:
->
-	let Tlist_Use_Right_Window = 1
-<
-						*'Tlist_Use_SingleClick'*
-Tlist_Use_SingleClick~
-By default, when you double click on the tag name using the left mouse 
-button, the cursor will be positioned at the definition of the tag. You 
-can set the 'Tlist_Use_SingleClick' variable to 1 to jump to a tag when
-you single click on the tag name using the mouse. By default this variable
-is set to zero.
->
-	let Tlist_Use_SingleClick = 1
-<
-Due to a bug in Vim, if you set 'Tlist_Use_SingleClick' to 1 and try to resize
-the taglist window using the mouse, then Vim will crash. This problem is fixed
-in Vim 6.3 and above. In the meantime, instead of resizing the taglist window
-using the mouse, you can use normal Vim window resizing commands to resize the
-taglist window.
-
-						*'Tlist_WinHeight'*
-Tlist_WinHeight~
-The default height of the horizontally split taglist window is 10. This can be
-changed by modifying the 'Tlist_WinHeight' variable:
->
-	let Tlist_WinHeight = 20
-<
-The |'winfixheight'| option is set for the taglist window, to maintain the
-height of the taglist window, when new Vim windows are opened and existing
-windows are closed.
-
-						*'Tlist_WinWidth'*
-Tlist_WinWidth~
-The default width of the vertically split taglist window is 30. This can be
-changed by modifying the 'Tlist_WinWidth' variable:
->
-	let Tlist_WinWidth = 20
-<
-Note that the value of the |'winwidth'| option setting determines the minimum
-width of the current window. If you set the 'Tlist_WinWidth' variable to a
-value less than that of the |'winwidth'| option setting, then Vim will use the
-value of the |'winwidth'| option.
-
-When new Vim windows are opened and existing windows are closed, the taglist
-plugin will try to maintain the width of the taglist window to the size
-specified by the 'Tlist_WinWidth' variable.
-
-==============================================================================
-						*taglist-commands*
-7. Commands~
-
-The taglist plugin provides the following ex-mode commands:
-
-|:TlistAddFiles|	Add multiple files to the taglist.
-|:TlistAddFilesRecursive|
-			Add files recursively to the taglist.
-|:TlistClose|		Close the taglist window.
-|:TlistDebug|		Start logging of taglist debug messages.
-|:TlistLock|		Stop adding new files to the taglist.
-|:TlistMessages|	Display the logged taglist plugin debug messages.
-|:TlistOpen|		Open and jump to the taglist window.
-|:TlistSessionSave|	Save the information about files and tags in the
-			taglist to a session file.
-|:TlistSessionLoad|	Load the information about files and tags stored
-			in a session file to taglist.
-|:TlistShowPrototype|	Display the prototype of the tag at or before the
-		    	specified line number.
-|:TlistShowTag|		Display the name of the tag defined at or before the
-			specified line number.
-|:TlistHighlightTag|	Highlight the current tag in the taglist window.
-|:TlistToggle|		Open or close (toggle) the taglist window.
-|:TlistUndebug|		Stop logging of taglist debug messages.
-|:TlistUnlock|		Start adding new files to the taglist.
-|:TlistUpdate|		Update the tags for the current buffer.
-
-						*:TlistAddFiles*
-:TlistAddFiles {file(s)} [file(s) ...]
-		Add one or more specified files to the taglist. You can
-		specify multiple filenames using wildcards. To specify a
-		file name with space character, you should escape the space
-		character with a backslash.
-		Examples:
->
-		    :TlistAddFiles *.c *.cpp
-		    :TlistAddFiles file1.html file2.html
-<
-		If you specify a large number of files, then it will take some
-		time for the taglist plugin to process all of them. The
-		specified files will not be edited in a Vim window and will
-		not be added to the Vim buffer list.
-
-						*:TlistAddFilesRecursive*
-:TlistAddFilesRecursive {directory} [ {pattern} ]
-		Add files matching {pattern} recursively from the specified
-		{directory} to the taglist. If {pattern} is not specified,
-		then '*' is assumed. To specify the current directory, use "."
-		for {directory}. To specify a directory name with space
-		character, you should escape the space character with a
-		backslash.
-		Examples:
->
-		    :TlistAddFilesRecursive myproject *.java
-		    :TlistAddFilesRecursive smallproject
-<
-		If large number of files are present in the specified
-		directory tree, then it will take some time for the taglist
-		plugin to process all of them.
-
-						*:TlistClose*
-:TlistClose	Close the taglist window. This command can be used from any
-		one of the Vim windows.
-
-						*:TlistDebug*
-:TlistDebug [filename]
-		Start logging of debug messages from the taglist plugin.
-		If {filename} is specified, then the debug messages are stored
-		in the specified file. Otherwise, the debug messages are
-		stored in a script local variable. If the file {filename} is
-		already present, then it is overwritten.
-
-						*:TlistLock*
-:TlistLock
-		Lock the taglist and don't process new files. After this
-		command is executed, newly edited files will not be added to
-		the taglist.
-
-						*:TlistMessages*
-:TlistMessages
-		Display the logged debug messages from the taglist plugin
-		in a window.  This command works only when logging to a
-		script-local variable.
-
-						*:TlistOpen*
-:TlistOpen	Open and jump to the taglist window. Creates the taglist
-		window, if the window is not opened currently. After executing
-		this command, the cursor is moved to the taglist window.  When
-		the taglist window is opened for the first time, all the files
-		in the buffer list are processed and the tags defined in them
-		are displayed in the taglist window.
-
-						*:TlistSessionSave*
-:TlistSessionSave {filename}
-		Saves the information about files and tags in the taglist to
-		the specified file. This command can be used to save and
-		restore the taglist contents across Vim sessions.
-
-						*:TlistSessionLoad*
-:TlistSessionLoad {filename}
-		Load the information about files and tags stored in the
-		specified session file to the taglist.
-
-						*:TlistShowPrototype*
-:TlistShowPrototype [filename] [linenumber]
-		Display the prototype of the tag at or before the specified
-		line number. If the file name and the line number are not
-		specified, then the current file name and line number are
-		used. A tag spans multiple lines starting from the line where
-		it is defined to the line before the next tag. This command
-		displays the prototype for the tag for any line number in this
-		range. 
-
-						*:TlistShowTag*
-:TlistShowTag [filename] [linenumber]
-		Display the name of the tag defined at or before the specified
-		line number. If the file name and the line number are not
-		specified, then the current file name and line number are
-		used. A tag spans multiple lines starting from the line where
-		it is defined to the line before the next tag. This command
-		displays the tag name for any line number in this range. 
-
-						*:TlistHighlightTag*
-:TlistHighlightTag
-		Highlight the current tag in the taglist window. By default,
-		the taglist plugin periodically updates the taglist window to
-		highlight the current tag. This command can be used to force
-		the taglist plugin to highlight the current tag.
-
-						*:TlistToggle*
-:TlistToggle	Open or close (toggle) the taglist window. Opens the taglist
-		window, if the window is not opened currently. Closes the
-		taglist window, if the taglist window is already opened. When
-		the taglist window is opened for the first time, all the files
-		in the buffer list are processed and the tags are displayed in
-		the taglist window. After executing this command, the cursor
-		is not moved from the current window to the taglist window.
-
-						*:TlistUndebug*
-:TlistUndebug
-		Stop logging of debug messages from the taglist plugin.
-
-						*:TlistUnlock*
-:TlistUnlock
-		Unlock the taglist and start processing newly edited files.
-
-						*:TlistUpdate*
-:TlistUpdate	Update the tags information for the current buffer. This
-		command can be used to re-process the current file/buffer and
-		get the tags information. As the taglist plugin uses the file
-		saved in the disk (instead of the file displayed in a Vim
-		buffer), you should save a modified buffer before you update
-		the taglist. Otherwise the listed tags will not include the
-		new tags created in the buffer. You can use this command even
-		when the taglist window is not opened.
-
-==============================================================================
-						*taglist-functions*
-8. Global functions~
-
-The taglist plugin provides several global functions that can be used from
-other Vim plugins to interact with the taglist plugin. These functions are
-described below.
-
-|Tlist_Update_File_Tags()|		Update the tags for the specified file
-|Tlist_Get_Tag_Prototype_By_Line()|	Return the prototype of the tag at or
-				    	before the specified line number in the
-				    	specified file.
-|Tlist_Get_Tagname_By_Line()|		Return the name of the tag at or
-					before the specified line number in
-					the specified file.
-|Tlist_Set_App()|			Set the name of the application
-					controlling the taglist window.
-
-					    *Tlist_Update_File_Tags()*
-Tlist_Update_File_Tags({filename}, {filetype})
-		Update the tags for the file {filename}. The second argument
-		specifies the Vim filetype for the file. If the taglist plugin
-		has not processed the file previously, then the exuberant
-		ctags tool is invoked to generate the tags for the file.
-
-					    *Tlist_Get_Tag_Prototype_By_Line()*
-Tlist_Get_Tag_Prototype_By_Line([{filename}, {linenumber}])
-		Return the prototype of the tag at or before the specified
-		line number in the specified file. If the filename and line
-		number are not specified, then the current buffer name and the
-		current line number are used.
-
-					    *Tlist_Get_Tagname_By_Line()*
-Tlist_Get_Tagname_By_Line([{filename}, {linenumber}])
-		Return the name of the tag at or before the specified line
-		number in the specified file. If the filename and line number
-		are not specified, then the current buffer name and the
-		current line number are used.
-
-					    *Tlist_Set_App()*
-Tlist_Set_App({appname})
-		Set the name of the plugin that controls the taglist plugin
-		window and buffer. This can be used to integrate the taglist
-		plugin with other Vim plugins.
-		
-		For example, the winmanager plugin and the Cream package use
-		this function and specify the appname as "winmanager" and
-		"cream" respectively.
-		
-		By default, the taglist plugin is a stand-alone plugin and
-		controls the taglist window and buffer. If the taglist window
-		is controlled by an external plugin, then the appname should
-		be set appropriately.
-
-==============================================================================
-						*taglist-extend*
-9. Extending~
-
-The taglist plugin supports all the languages supported by the exuberant ctags
-tool, which includes the following languages: Assembly, ASP, Awk, Beta, C,
-C++, C#, Cobol, Eiffel, Erlang, Fortran, HTML, Java, Javascript, Lisp, Lua,
-Make, Pascal, Perl, PHP, Python, Rexx, Ruby, Scheme, Shell, Slang, SML, Sql,
-TCL, Verilog, Vim and Yacc.
-
-You can extend the taglist plugin to add support for new languages and also
-modify the support for the above listed languages.
-
-You should NOT make modifications to the taglist plugin script file to add
-support for new languages. You will lose these changes when you upgrade to the
-next version of the taglist plugin. Instead you should follow the below
-described instructions to extend the taglist plugin.
-
-You can extend the taglist plugin by setting variables in the .vimrc or _vimrc
-file. The name of these variables depends on the language name and is
-described below.
-
-Modifying support for an existing language~
-To modify the support for an already supported language, you have to set the
-tlist_xxx_settings variable in the ~/.vimrc or $HOME/_vimrc file. Replace xxx
-with the Vim filetype name for the language file.  For example, to modify the
-support for the perl language files, you have to set the tlist_perl_settings
-variable. To modify the support for java files, you have to set the
-tlist_java_settings variable.
-
-To determine the filetype name used by Vim for a file, use the following
-command in the buffer containing the file:
-
-	:set filetype
-
-The above command will display the Vim filetype for the current buffer.
-
-The format of the value set in the tlist_xxx_settings variable is
-
-    <language_name>;flag1:name1;flag2:name2;flag3:name3
-
-The different fields in the value are separated by the ';' character.
-
-The first field 'language_name' is the name used by exuberant ctags to refer
-to this language file. This name can be different from the file type name used
-by Vim. For example, for C++, the language name used by ctags is 'c++' but the
-filetype name used by Vim is 'cpp'. To get the list of language names
-supported by exuberant ctags, use the following command:
-
-	$ ctags --list-maps=all
-
-The remaining fields follow the format "flag:name". The sub-field 'flag' is
-the language specific flag used by exuberant ctags to generate the
-corresponding tags. For example, for the C language, to list only the
-functions, the 'f' flag is used. To get the list of flags supported by
-exuberant ctags for the various languages use the following command:
-
-	$ ctags --list-kinds=all
-
-The sub-field 'name' specifies the title text to use for displaying the tags
-of a particular type. For example, 'name' can be set to 'functions'. This
-field can be set to any text string name.
-
-For example, to list only the classes and functions defined in a C++ language
-file, add the following line to your .vimrc file:
-
-	let tlist_cpp_settings = 'c++;c:class;f:function'
-
-In the above setting, 'cpp' is the Vim filetype name and 'c++' is the name
-used by the exuberant ctags tool. 'c' and 'f' are the flags passed to
-exuberant ctags to list C++ classes and functions and 'class' is the title
-used for the class tags and 'function' is the title used for the function tags
-in the taglist window.
-
-For example, to display only functions defined in a C file and to use "My
-Functions" as the title for the function tags, use
-
-	let tlist_c_settings = 'c;f:My Functions'
-
-When you set the tlist_xxx_settings variable, you will override the default
-setting used by the taglist plugin for the 'xxx' language. You cannot add to
-the default options used by the taglist plugin for a particular file type. To
-add to the options used by the taglist plugin for a language, copy the option
-values from the taglist plugin file to your .vimrc file and modify it.
-
-Adding support for a new language~
-If you want to add support for a new language to the taglist plugin, you need
-to first extend the exuberant ctags tool. For more information about extending
-exuberant ctags, visit the following page:
-
-    http://ctags.sourceforge.net/EXTENDING.html
-
-To add support for a new language, set the tlist_xxx_settings variable in the
-~/.vimrc file appropriately as described above. Replace 'xxx' in the variable
-name with the Vim filetype name for the new language.
-
-For example, to extend the taglist plugin to support the latex language, you
-can use the following line (assuming, you have already extended exuberant
-ctags to support the latex language):
-
-	let tlist_tex_settings='latex;b:bibitem;c:command;l:label'
-
-With the above line, when you edit files of filetype "tex" in Vim, the taglist
-plugin will invoke the exuberant ctags tool passing the "latex" filetype and
-the flags b, c and l to generate the tags. The text heading 'bibitem',
-'command' and 'label' will be used in the taglist window for the tags which
-are generated for the flags b, c and l respectively.
-
-==============================================================================
-						*taglist-faq*
-10. Frequently Asked Questions~
-
-Q. The taglist plugin doesn't work. The taglist window is empty and the tags
-   defined in a file are not displayed. 
-A. Are you using Vim version 6.0 and above? The taglist plugin relies on the
-   features supported by Vim version 6.0 and above. You can use the following
-   command to get the Vim version:
->
-	$ vim --version
-<
-   Are you using exuberant ctags version 5.0 and above? The taglist plugin
-   relies on the features supported by exuberant ctags and will not work with
-   GNU ctags or the Unix ctags utility. You can use the following command to
-   determine whether the ctags installed in your system is exuberant ctags:
->
-	$ ctags --version
-<
-   Is exuberant ctags present in one of the directories in your PATH? If not,
-   you need to set the Tlist_Ctags_Cmd variable to point to the location of
-   exuberant ctags. Use the following Vim command to verify that this is setup
-   correctly:
->
-	:echo system(Tlist_Ctags_Cmd . ' --version')
-<
-   The above command should display the version information for exuberant
-   ctags.
-
-   Did you turn on the Vim filetype detection? The taglist plugin relies on
-   the filetype detected by Vim and passes the filetype to the exuberant ctags
-   utility to parse the tags. Check the output of the following Vim command:
->
-	:filetype
-<
-   The output of the above command should contain "filetype detection:ON".
-   To turn on the filetype detection, add the following line to the .vimrc or
-   _vimrc file:
->
-	filetype on
-<
-   Is your version of Vim compiled with the support for the system() function?
-   The following Vim command should display 1:
->
-	:echo exists('*system')
-<
-   In some Linux distributions (particularly Suse Linux), the default Vim
-   installation is built without the support for the system() function. The
-   taglist plugin uses the system() function to invoke the exuberant ctags
-   utility. You need to rebuild Vim after enabling the support for the
-   system() function. If you use the default build options, the system()
-   function will be supported. 
-
-   Do you have the |'shellslash'| option set? You can try disabling the
-   |'shellslash'| option. When the taglist plugin invokes the exuberant ctags
-   utility with the path to the file, if the incorrect slashes are used, then
-   you will see errors.
-   
-   Check the shell related Vim options values using the following command:
->
-	:set shell? shellcmdflag? shellpipe?
-	:set shellquote? shellredir? shellxquote?
-<
-   If these options are set in your .vimrc or _vimrc file, try removing those
-   lines.
-
-   Are you using a Unix shell in a MS-Windows environment? For example,
-   the Unix shell from the MKS-toolkit. Do you have the SHELL environment
-   set to point to this shell? You can try resetting the SHELL environment
-   variable.
-
-   If you are using a Unix shell on MS-Windows, you should try to use
-   exuberant ctags that is compiled for Unix-like environments so that
-   exuberant ctags will understand path names with forward slash characters.
-
-   Is your filetype supported by the exuberant ctags utility? The file types
-   supported by the exuberant ctags utility are listed in the ctags help. If a
-   file type is not supported, you have to extend exuberant ctags. You can use
-   the following command to list the filetypes supported by exuberant ctags:
->
-	ctags --list-languages
-<
-   Run the following command from the shell prompt and check whether the tags
-   defined in your file are listed in the output from exuberant ctags:
->
-	ctags -f - --format=2 --excmd=pattern --fields=nks <filename>
-<
-   If you see your tags in the output from the above command, then the
-   exuberant ctags utility is properly parsing your file.
-
-   Do you have the .ctags or _ctags or the ctags.cnf file in your home
-   directory for specifying default options or for extending exuberant ctags?
-   If you do have this file, check the options in this file and make sure
-   these options are not interfering with the operation of the taglist plugin.
-
-   If you are using MS-Windows, check the value of the TEMP and TMP
-   environment variables. If these environment variables are set to a path
-   with space characters in the name, then try using the DOS 8.3 short name
-   for the path or set them to a path without the space characters in the
-   name. For example, if the temporary directory name is "C:\Documents and
-   Settings\xyz\Local Settings\Temp", then try setting the TEMP variable to
-   the following:
->
-	set TEMP=C:\DOCUMEN~1\xyz\LOCALS~1\Temp
-<
-   If exuberant ctags is installed in a directory with space characters in the
-   name, then try adding the directory to the PATH environment variable or try
-   setting the 'Tlist_Ctags_Cmd' variable to the shortest path name to ctags
-   or try copying the exuberant ctags to a path without space characters in
-   the name. For example, if exuberant ctags is installed in the directory
-   "C:\Program Files\Ctags", then try setting the 'Tlist_Ctags_Cmd' variable
-   as below:
->
-	let Tlist_Ctags_Cmd='C:\Progra~1\Ctags\ctags.exe'
-<
-   If you are using a cygwin compiled version of exuberant ctags on MS-Windows,
-   make sure that either you have the cygwin compiled sort utility installed
-   and available in your PATH or compile exuberant ctags with internal sort
-   support. Otherwise, when exuberant ctags sorts the tags output by invoking
-   the sort utility, it may end up invoking the MS-Windows version of
-   sort.exe, thereby resulting in failure.
-
-Q. When I try to open the taglist window, I am seeing the following error
-   message. How do I fix this problem?
-
-   Taglist: Failed to generate tags for /my/path/to/file
-   ctags: illegal option -- -^@usage: ctags [-BFadtuwvx] [-f tagsfile] file ...
-
-A. The taglist plugin will work only with the exuberant ctags tool. You
-   cannot use the GNU ctags or the Unix ctags program with the taglist plugin.
-   You will see an error message similar to the one shown above, if you try
-   use a non-exuberant ctags program with Vim. To fix this problem, either add
-   the exuberant ctags tool location to the PATH environment variable or set
-   the 'Tlist_Ctags_Cmd' variable.
-
-Q. A file has more than one tag with the same name. When I select a tag name
-   from the taglist window, the cursor is positioned at the incorrect tag
-   location. 
-A. The taglist plugin uses the search pattern generated by the exuberant ctags
-   utility to position the cursor at the location of a tag definition. If a
-   file has more than one tag with the same name and same prototype, then the
-   search pattern will be the same. In this case, when searching for the tag
-   pattern, the cursor may be positioned at the incorrect location. 
-
-Q. I have made some modifications to my file and introduced new
-   functions/classes/variables. I have not yet saved my file. The taglist
-   plugin is not displaying the new tags when I update the taglist window.
-A. The exuberant ctags utility will process only files that are present in the
-   disk. To list the tags defined in a file, you have to save the file and
-   then update the taglist window. 
-
-Q. I have created a ctags file using the exuberant ctags utility for my source
-   tree. How do I configure the taglist plugin to use this tags file? 
-A. The taglist plugin doesn't use a tags file stored in disk. For every opened
-   file, the taglist plugin invokes the exuberant ctags utility to get the
-   list of tags dynamically. The Vim system() function is used to invoke
-   exuberant ctags and get the ctags output. This function internally uses a
-   temporary file to store the output. This file is deleted after the output
-   from the command is read. So you will never see the file that contains the
-   output of exuberant ctags.
-
-Q. When I set the |'updatetime'| option to a low value (less than 1000) and if
-   I keep pressing a key with the taglist window open, the current buffer
-   contents are changed. Why is this?
-A. The taglist plugin uses the |CursorHold| autocmd to highlight the current
-   tag. The CursorHold autocmd triggers for every |'updatetime'| milliseconds.
-   If the |'updatetime'| option is set to a low value, then the CursorHold
-   autocmd will be triggered frequently. As the taglist plugin changes
-   the focus to the taglist window to highlight the current tag, this could
-   interfere with the key movement resulting in changing the contents of
-   the current buffer. The workaround for this problem is to not set the
-   |'updatetime'| option to a low value.
-
-==============================================================================
-						*taglist-license*
-11. License~
-Permission is hereby granted to use and distribute the taglist plugin, with or
-without modifications, provided that this copyright notice is copied with it.
-Like anything else that's free, taglist.vim is provided *as is* and comes with
-no warranty of any kind, either expressed or implied. In no event will the
-copyright holder be liable for any damamges resulting from the use of this
-software.
-
-==============================================================================
-						*taglist-todo*
-12. Todo~
-
-1. Group tags according to the scope and display them. For example,
-   group all the tags belonging to a C++/Java class 
-2. Support for displaying tags in a modified (not-yet-saved) file. 
-3. Automatically open the taglist window only for selected filetypes.
-   For other filetypes, close the taglist window. 
-4. When using the shell from the MKS toolkit, the taglist plugin 
-   doesn't work.
-5. The taglist plugin doesn't work with files edited remotely using the
-   netrw plugin. The exuberant ctags utility cannot process files over
-   scp/rcp/ftp, etc.
-
-==============================================================================
-
-vim:tw=78:ts=8:noet:ft=help:
Index: b/doc/winmanager.txt
deleted file mode 100644
===================================================================
--- a/doc/winmanager.txt
+++ /dev/null
@@ -1,503 +0,0 @@
-*winmanager*       Plugin for a classical Windows style IDE for Vim 6.0
-                         For Vim version 6.0.
-              Last Change: Sun Mar 31 11:00 PM 2002 PST
-
-                            By Srinath Avadhanula
-                            (srinath@fastmail.fm)
-
-                                                         *winmanager-plugin*
-
-winmanager.vim is a plugin which implements a classical windows type IDE in
-Vim-6.0, where the directory and buffer browsers are displayed in 2 windows on
-the left and the current editing is done on the right. When you open up a new
-vim window, simply type in :WMToggle. This will start up winmanager.
-
-Note This plugin is available only if 'compatible' is not set
-     You can avoid loading this plugin by setting the "loaded_winmanager"
-     variable >
-        :let loaded_winmanager = 1
-
-{Vi does not have any of this}
-===========================================================================
-OVERVIEW                                              *winmanager-overview*
-
-|winmanager-installing|  Please follow these instructions for installing
-                         winmanager. 
-
-|winmanager-customizing| Describes ways of customizing the window layout, i.e
-                         how to club various explorers into groups, how to
-                         change their relative position, etc.
-
-|winmanager-details|     details of using winmanager. keyboard shortcuts
-                         and other usage details.
-
-|winmanager-commands|    commands provided to the user. its useful to
-                         set keyboard shortcuts to these commands.
-
-|winmanager-settings|    settings (typically made in ~/.vimrc) which
-                         affect the behavior of winmanager.
-
-|winmanager-adding|      one of the most important new features of this
-                         version is the creation of a framework whereby adding
-                         other plugins like explorer.vim or bufexplorer.vim to
-                         winmanager. This section describes briefly the
-                         implementation of winmanager and then describes how
-                         to add a new plugin to winmanager
-
-|add-local-help|         how to use this text file as a vim help file.
-|winmanager-bug|         bug reports are welcome.
-|winmanager-thanks|      thanks to the many people who helped!
-
-===========================================================================
-UPDATES                                                *winmanager-updates*
-
-The official releases can be found at: >
-    http://vim.sourceforge.net/scripts/script.php?script_id=95
-However, I will only update the vim.sf.net version of winmanager.zip in case
-of a major bug or new feature. For small (and not so bothersome) bug-fixes, I
-will put the latest version at: >
-    http://robotics.eecs.berkeley.edu/~srinath/vim/winmanager-2.0.htm
-and also announce it in vim@vim.org when an update occurs.
-Therefore if you want to keep to be kept abreast of updates, you could
-check occassionally at vim@vim.org. (you can also use your mail server's
-filtering capability to effectively subscribe to the announcement).
-
-============================================================================
-INSTALLING                                          *winmanager-installing*
-
-winmanager.vim should start working as soon as you restart vim after unzipping
-the .zip file you got this from into ~/.vim (unix) or ~\vimfiles (dos)
-
-winmanager only recognizes plugins whose name appears in the global variable >
-    g:winManagerWindowLayout
-<  
-By default this global variable has the value >
-    g:winManagerWindowLayout = 'FileExplorer,TagsExplorer|BufExplorer'
-<
-(which is the value which winmanager uses if its not set in the user's .vimrc)
-
-This global variable is responsible for making winmanager recognize the
-existence of the explorers and simultaneously custome the window layout.  See
-the next section for how to set this variable for various custom layouts of
-winmanager.
-
-============================================================================
-CUSTOMIZING                                         *winmanager-customizing*
-
-The layout of winmanager is controlled by changing the value of the
-"g:winManagerWindowLayout" variable. The general form of this variable is
->
-   g:winManagerWindowLayout =
-   'Group1_Member1,Group1_Member2|Group2_Member_1,Group2_Member_2'
-<
-i.e, explorer "groups" are seperated by the '|' character. Within each group,
-individual explorer plugin names are seperated by the comma (',') character.
-What winmanager does is display only 1 member from each group in a window. The
-user can go to a window and press <C-n> to display the next explorer belonging
-to that group. This ability to "group" windows is valuable to preserve screen
-real-estate by using them only as needed.
-
-Thus for the default value of 'g:winManagerWindowLayout', winmanager will
-split the vim window as follows:
-        +-----------+-------------------+
-        |           |                   |
-        | File      |                   |
-        | explorer  |    File being     |
-        |           |     edited        |
-        |           |                   |
-        +-----------+                   |
-        | Buffer    |                   |
-        | explorer  |                   |
-        |           |                   |
-        +-----------+-------------------+
-
-The user can go the [File List] window and press <C-n> to goto the
-'TagsExplorer' view. 
-
-Removing a plugin name from the 'g:winManagerWindowLayout' variable means
-winmanager no longer sees that variable.
-
-============================================================================
-COMMANDS                                               *winmanager-commands*
-
-:WMToggle                 :toggles the visibility of winmanager. This can
-                           also be used to start winmanager for the first
-                           time. A handy mapping is: >
-            :map <c-w><c-t> :WMToggle<cr> 
-<                          mnemonic: window-toggle : <c-W><c-T>
-
-:FirstExplorerWindow      :directly takes you to the first explorer window
-                           from the top left corner which is visible. >
-            :map <c-w><c-f> :FirstExplorerWindow<cr>
-<                          mnemonic: window-first  : <c-W><c-F>
-
-:BottomExplorerWindow     :directly takes you to the last explorere window
-                           from the top-left which is visible. >
-            :map <c-w><c-b> :BottomExplorerWindow<cr>
-<                          mnemonic: window-last   : <c-W><c-B>
-
-NOTE: winmanager does not provide any mappings by default. These have to set
-in the user's .vimrc if you want to use mappings.
-
-============================================================================
-SETTINGS                                               *winmanager-settings*
-
-The values of the following global variables should be set in your .vimrc
-file if you want a different value than the default:
-
-g:persistentBehaviour: if set to 0, then as soon as you quit all the files
-    and only the explorer windows are the ones left, vim will quit. the
-    default is 1, which means that the explorer windows persist even if
-    they are the only ones visible.
-
-g:winManagerWidth: the width of the explorer areas. 
-    (default 25)
-
-g:defaultExplorer:  If you want winmanager to assume the functioning of the
-    default explorer.vim which ships with vim, set this variable to 0.
-    (default 1). If this variable is set to 1, then winmanager will behave as
-    follows:
-    . if the user starts off vim with a command such as
-      ":vim some/dir/" then winmanager starts off the window layout with
-      FileExplorer at the top left window. as of now it changes the
-      g:windowLayout variable so that file explorer appears in the top left
-      window.
-    . if on the other hand the user does ":e some/dir/" while _inside_ vim,
-      then the behavior is consistent with the original behavior of the
-      explorer.vim plugin which ships with vim, i.e, the directory is opened
-      in a buffer and the user can use that to open a file in that window.
-    Note that the commands ":Explore" and ":Sexplore" are still available if
-    you set this variable to 1.
-    winfileexplorer.vim, the modification of explorer.vim which ships with
-    this version is different from the standard explorer.vim in that it has
-    display caching. i.e, the directory is read and sorted only the first
-    time. From the second time on, the directory list is cached in a script
-    variable so display is faster.
-
-                                            *winmanager-fileexplorer-settings*
-See |explorer| for details. 
-NOTE: Some of the settings used in explorer.vim are not utlized in
-winmanager.
-                                            *winmanager-bufexplorer-settings*
-g:bufExplorerMaxHeight: the buffer list window dynamicall rescales itself to
-    occupy only the minimum space required to display all the windows. you
-    can set a maximum number of lines for this window. (defualt 15)
-See |bufexplorer| for details on additional options. 
-NOTE: Some of the settings used in bufexplorer.vim are not utlized in
-winmanager.
-
-=============================================================================
-DETAILED HELP                                            *winmanager-details*
-
-When winmanager starts up, it divides up the whole vim window into 2
-"regions". The region on the left is the "explorer area" where the various
-explorer plugins are displayed. The region on the right is the "file editing
-area", where the user works on his current editing session. 
-
-        +--------+-------------------+
-        |        |                   |
-        |        |      2(i)         |
-        | 1(i)   |                   |
-        |        +-------------------+
-        |        |                   |
-        +--------+      2(ii)        |
-        | 1(ii)  |                   |
-        +--------+-------------------+
-
-The explorer area (area 1) might contain multiple windows each of which might
-contain multiple explorers. In the default configuration (for
-g:winManagerWindowLayout = 'FileExplorer,TagsExplorer|BufExplorer'), the first
-window can be thought of as containing 2 explorers, the file explorer plugin
-and the tags explorer plugin, while the bottom window contains bufexplorer by
-itself.
-
-When a window contains multiple explorers, then the user can cycle between
-them by pressing <c-n> (mnemonic: next) or <c-p> (mnemonic: previous). 
-
-This section describes the various keyboard shortcuts for the 3 plugins which
-are used with winmanager by default.
-NOTE: Other plugins might be distributed as add-ins to winmanager. In that
-case, please refer to the help which ships with that plugin.
- 
-1. File Explorer plugin
-This plugin displays the current directory. Its a modification of the standard
-explorer.vim which ships with vim6.0. The following keyboard shortcuts are
-available with this plugin:
-<enter>          if on a directory, enters it and displays it in the same
-                 area. If on a file, then opens it in the File Editing Area.
-                 Attempts to open in the same window as the one visited
-                 before, otherwise split open a new window horizontally. if
-                 this sounds a bit confusing, it isnt. its the most intuitive
-                 behaviour that one expects.
-<2-leftmouse>   (doubleclick) the same as <enter>
-<tab>            open the file or directory in a new window in the FileEditing
-                 area. 
-c                change the pwd to the directory currently displayed 
-C                change the currently displayed directory to pwd (converse of
-                 c) this helps in changing to different drives in windows.
-                 i.e, if you are currently on the c: drive and you want to
-                 change to the d: drive, you will have to do 
-                 cd d:\
-                 and then press 'C' in the file explorer area.
-s                select sort field (size, date, name) 
-r                reverse direction of sort 
-f                add current directory to list of favorites.
-R                rename file 
-D                delete file (or range of files in visual mode)
--                move up one level
-<F5>             refresh the file list
-
-2. Buffer Explorer plugin
-See |bufexplorer-usage| for details.
-NOTE: In addition to those shortcuts, winmanager adds the following:
-<tab>             Opens the buffer under the cursor in a split window even if
-                  the current buffer is not modified.
-
-This window is dynamically rescaled and re-displayed. i.e, when a new window
-opens somehwere, the buffer list is automatically updated. also, it tries to
-occupy the minimum possible space required to display the files. 
-
-3. File Editing Area
-The area where normal editing takes place. The commands in the File Explorer
-and Buffer Explorer shouldnt affect the layout of the windows here. Some
-mappings which I find useful (which should be placed in your .vimrc if you
-plan on using WManager often) is 
->
-    map <c-w><c-b> :BottomExplorerWindow<cr>
-    map <c-w><c-f> :FirstExplorerWindow<cr>
-    map <c-w><c-t> :WMToggle<cr>
-
-Pressing CTRL-W-B should then take you directly to the last explorer window
-Similarly pressing CTRL-W-F should take you to the first explorer window.
-CTRL-W-T will toggle between the winmanager visible and invisible.
-
-=============================================================================
-ADDING NEW PLUGINS                                        *winmanager-adding*
-
-This section is of interest only to people who might want to extend winmanager
-by adding other plugins to it. The casual user can skip it.
-
-One of the most important new features of winmanager2.x is the ability to let
-other users add IDE type plugins to winmanager.vim with a minimum of effort.
-The way winmanager ships, it usually contains the following plugins:
->
-    (FileExplorer, TagsExplorer)
-    (BufExplorer)
-
-i.e, FileExplorer and TagsExplorer occupy one window as a single group, while
-BufExplorer occupies another window. "Adding" a plugin means that you will be
-able to add a seperate IDE plugin, (call it "YourPlugin" henceforth) either to
-one of these groups or seperately by itself. This section describes how to
-accomplish this. Although the section is somewhat lengthy, please rest assured
-that its really quite simple to do. Have a look at |wintagexplorer|.vim for a
-small plugin which accomplishes this.
-
-To better understand the process, its helpful to give a short description of
-the workings of winmanager. When a user wants to use your plugin, he
-"registers" it with winmanager, i.e he adds the "name" of the plugin to the
-variable g:winManagerWindowLayout in his .vimrc as:
-
-    " this line goes in the user's .vimrc
-    let g:winManagerWindowLayout = "FileExplorer,TagsExplorer|YourPlugin"
-
-When winmanager starts up, it remembers the string "YourPlugin" internally as
-the plugins "name". (The reason for making this a part of the user's .vimrc
-is that that way, he can customize the window layout according to his
-preferences).
-
-In addition to registering, the plugin itself initializes a variable called
-the "title" which starts with the name, such as: >
-
-    " this line goes in your script file.
-    let g:YourPlugin_title = "[My Plugin Title]"
-
-<
-NOTE: Just like the rest of the hooks provided by your plugin, this global
-variable name is formed according the rule: g:<YourPluginName>_title.
-
-When winmanager starts up, it performs the following 2 actions:
-    1. It opens a new file with the "title" provided by the plugin. This
-       automatically ensures that the same buffer is opened for multiple
-       invokations of the plugin.
-       NOTE: It is very important for this reason that the plugin's name be
-       distinct so that there is a low (ideally zero) probability of a file
-       with the same name existing on a user's system.
-    2. It modifies the "name" string (in this case "YourPlugin") to form 
-       "call YourPlugin_Start()" and then |exec|s this string. Thus winmanager
-       communicates with your plugin by using a number of such "hooks" or
-       global functions which all start with the string "YourPlugin" which are
-       defined in the script file you create.
-
-In order to enable the dynamic nature of winmanager, where you can have your
-plugin change its display every time a |BufEnter| or |BufDelete| event occurs,
-it is necessary to provide a few other hooks. Every time a BufEnter or
-BufDelete event occurs, winmanager makes a loop over all the visible buffers.
-Then it "refreshes" the display of that plugin if it is "invalid". The
-following paragraphs describe the hooks that have to be provided to enable
-this.
-
-                                                           *winmanager-hooks*
-
-The following is a list of hooks which should be provided. A few of them are
-optional. Consider the case where you want to add a plugin which you have
-named "YourPlugin". In the following discussion, a "hook" simply refers to a
-globally visible function which is formed according to the rule that it start
-with the string "YourPlugin_", where "YourPlugin" is the name of your plugin.
-
-                                                       *winmanager-hook-start* 
-YourPlugin_Start()       This function is called during initialization.  It
-{Mandatory}              can be assumed (and _should_ be) that the focus is
-                         already in the buffer where stuff needs to be
-                         displayed. i.e, the plugin shouldnt open some other
-                         buffer during this function. (i.e, commands such as
-                         ":e", ":vsplit", ":wincmd h" etc in this stage are
-                         bad. If however, you absolutely need to switch
-                         buffers or something which will cause |BufEnter| or
-                         |BufDelete| events, then you need to temporarily
-                         switch winmanager off by using
-                         |WinManagerSuspendAUs|)
-
-                                                    *winmanager-hook-isvalid*
-YourPlugin_IsValid()     winmanager is dynamic in the sense that it allows the
-{Mandatory}              plugins to change their displays when a BufEnter event
-                         occurs. At each BufEnter event, winmanager will cycle
-                         through all the visible explorers asking them if
-                         their display is "valid". If it isn't, then they will
-                         be redrawn by calling the next function.
-
-                         For plugins such as bufexplorer which change with
-                         every BufEnter, it is sufficient to make this always
-                         return 1. For plugins such as fileexplorer, the
-                         display never changes with the BufEnter even. hence
-                         in its case, it will always return 0.
-
-                                                     *winmanager-hook-refresh*
-YourPlugin_Refresh()      If the YourPlugin_IsValid() function returns 0, then
-{Optional}                this function is called to update the display. if the
-                          first function always returns 1, then this function
-                          need not be defined.
-                          NOTE: It is not clear at this time whether this
-                          function is really necessary. It might be obsoleted
-                          in the future. Future versions might call the
-                          _Start() function instead.
-                          NOTE: It has been obsoleted as of version 2.1
-
-                                                      *winmanager-hook-resize*
-YourPlugin_ReSize()       The plugins can also be dynamically resizable.  (the
-{Optional}                current bufexplorer which ships with the winmanager
-                          exhibits this behavior).  If a plugin creates such a
-                          function, then it will be called after its Refresh()
-                          function. The reason for not letting the plugin make
-                          this a part of its Refresh() function is that
-                          sometimes resizing is not allowed, such as in
-                          instances where there is no window above or below the
-                          plugin to take the slack of a resize.
-
-
-In addition, the plugin should also initialize the following global variable
-
-                                                       *winmanager-hook-title*
-g:YourPlugin_title        This is the name of the buffer associated with
-                          this plugin. The reason for a title in addition to a
-                          name is that the name should be such that a global
-                          function of that name can be defined.  However, the
-                          title can be more descriptive and contain spaces
-                          etc. For example, the present distribution of
-                          FileExplorer has the title "[File List]". Also,
-                          winmanager opens a file with this name (using an
-                          equivalent of ":e g:YourPlugin_title"), which
-                          automatically ensures that new buffers are not eaten
-                          up in multiple invokations of winmanager, toggling
-                          visibility of buffers, etc. 
-                          NOTE: It is very important for this reason that the
-                          plugin's name be distinct so that there is a low
-                          (ideally zero) probability of a file with the same
-                          name existing on a user's system. 
-
-In addition to YourPlugin providing winmanager with hooks, winmanager also
-provides the following hooks for use by YourPlugin:
-
-                                                        *WinManagerFileEdit*
-WinManagerFileEdit({filename}, {split})
-                          This function _must_ be used when the plugin wants
-                          to open a new file in the file editing area for
-                          editing. Its not sufficient to do something like
-                          ":wincmd p" and then ":e filename", because first of
-                          all the ":wincmd p" command gets screwed
-                          (unfortunately) in the presence of winmanager
-                          because of the (sometimes) large movement winmanager
-                          does over all visible windows to maintain the
-                          dynamic nature. Secondly, doing a simple ":e
-                          filename" will not preserve the @# and the @%
-                          registers properly, causing handy commands such as
-                          |CTRL-^| to totally mis-behave.
-
-                          The first argument should be (preferably) the
-                          (complete) name of the file to be opened (including
-                          the full path to it if possible).  The second
-                          argument decides whether winmanager should attempt
-                          to open the file in the same window as the last
-                          window or to split a new window to open the file.
-
-                                                     *WinManagerSuspendAUs*
-WinManagerSuspendAUs()    This makes winmanager stop responding to the
-                          |BufEnter| or |BufDelete| autocommands like it
-                          normally does. Please use this function with care.
-                          You will need to use this when you are performing
-                          some action which causes these events but you dont
-                          want to have winmanager go through the whole
-                          isvalid/refresh cycle. NOTE: Take care to definitely
-                          reset the behavior by using the next function.
-
-                                                     *WinManagerResumeAUs*
-WinManagerResumeAUs()     This is the converse of |WinManagerSuspendAUs()|. It
-                          makes winmanager start responding to events with the
-                          usual isvalid/refresh cycle.
-
-                                                   *WinManagerForceReSize* 
-WinManagerForceReSize()   Normally, winmanager calls the YourPlugin_ReSize()
-                          function after the YourPlugin_Refresh(). However,
-                          this happens only every |BufEnter| event. When the
-                          plugin performs some function which requires it to
-                          resize even when there was no |BufEnter| or
-                          |BufDelete| event, use this function. Please avoid
-                          making a call to YourPlugin_ReSize() because a
-                          number of safety checks have to be performed before
-                          a resizing is "legal".
-                          
-Finally, if you do plan on making an addin to winmanager, feel free to contact
-me for help/comments/suggestions. You might also want to take a look at: >
-    http://robotics.eecs.berkeley.edu/~srinath/vim/explorerSample.vim
-for a simple template of an add-in plugin.
-
-=============================================================================
-BUGS                                                         *winmanager-bug*
-
-Please send any comments for improvements or bug-reports to >
-    srinath@fastmail.fm
-If the bug is repeatable, then it will be of great help if a short description
-of the events leading to the bug are also given.
-
-Note "I dont like winmanager" is not a bug report, only an opinion ;-)
-
-=============================================================================
-THANKS                                                    *winmanager-thanks*
-
-I am really grateful to all those who emailed me with bug-reports and comments
-for improvement. Most of all, a huge thanks to Xiangjiang Ma for his enormous
-support and extremeley helpful QA. 
-
-Other people who helped greatly:
-   Madoka Machitani: fixed a couple of typos and gave some ideas for making
-      things more robust.
-   Colin Dearing: gave many useful suggestions for improvement which lead to
-      the fast redraw capability of winmanager
-   Jeff Lanzarotta: for agreeing to make changes to bufexplorer.vim so that
-      bufexplorer.vim would be compatible with the latest version of
-      winmanager.vim
-
-   and finally all the great support I got from vim@vim.org and comp.editors
-   helped a lot.
-
-
-vim:tw=78:et:ts=4:ft=help:norl:
Index: b/plugin/taglist.vim
deleted file mode 100644
===================================================================
--- a/plugin/taglist.vim
+++ /dev/null
@@ -1,4546 +0,0 @@
-" File: taglist.vim
-" Author: Yegappan Lakshmanan (yegappan AT yahoo DOT com)
-" Version: 4.5
-" Last Modified: September 21, 2007
-" Copyright: Copyright (C) 2002-2007 Yegappan Lakshmanan
-"            Permission is hereby granted to use and distribute this code,
-"            with or without modifications, provided that this copyright
-"            notice is copied with it. Like anything else that's free,
-"            taglist.vim is provided *as is* and comes with no warranty of any
-"            kind, either expressed or implied. In no event will the copyright
-"            holder be liable for any damamges resulting from the use of this
-"            software.
-"
-" The "Tag List" plugin is a source code browser plugin for Vim and provides
-" an overview of the structure of the programming language files and allows
-" you to efficiently browse through source code files for different
-" programming languages.  You can visit the taglist plugin home page for more
-" information:
-"
-"       http://vim-taglist.sourceforge.net
-"
-" You can subscribe to the taglist mailing list to post your questions
-" or suggestions for improvement or to report bugs. Visit the following
-" page for subscribing to the mailing list:
-"
-"       http://groups.yahoo.com/group/taglist/
-"
-" For more information about using this plugin, after installing the
-" taglist plugin, use the ":help taglist" command.
-"
-" Installation
-" ------------
-" 1. Download the taglist.zip file and unzip the files to the $HOME/.vim
-"    or the $HOME/vimfiles or the $VIM/vimfiles directory. This should
-"    unzip the following two files (the directory structure should be
-"    preserved):
-"
-"       plugin/taglist.vim - main taglist plugin file
-"       doc/taglist.txt    - documentation (help) file
-"
-"    Refer to the 'add-plugin', 'add-global-plugin' and 'runtimepath'
-"    Vim help pages for more details about installing Vim plugins.
-" 2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or
-"    $VIM/vimfiles/doc directory, start Vim and run the ":helptags ."
-"    command to process the taglist help file.
-" 3. If the exuberant ctags utility is not present in your PATH, then set the
-"    Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
-"    utility (not to the directory) in the .vimrc file.
-" 4. If you are running a terminal/console version of Vim and the
-"    terminal doesn't support changing the window width then set the
-"    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
-" 5. Restart Vim.
-" 6. You can now use the ":TlistToggle" command to open/close the taglist
-"    window. You can use the ":help taglist" command to get more
-"    information about using the taglist plugin.
-"
-" ****************** Do not modify after this line ************************
-
-" Line continuation used here
-let s:cpo_save = &cpo
-set cpo&vim
-
-if !exists('loaded_taglist')
-    " First time loading the taglist plugin
-    "
-    " To speed up the loading of Vim, the taglist plugin uses autoload
-    " mechanism to load the taglist functions.
-    " Only define the configuration variables, user commands and some
-    " auto-commands and finish sourcing the file
-
-    " The taglist plugin requires the built-in Vim system() function. If this
-    " function is not available, then don't load the plugin.
-    if !exists('*system')
-        echomsg 'Taglist: Vim system() built-in function is not available. ' .
-                    \ 'Plugin is not loaded.'
-        let loaded_taglist = 'no'
-        let &cpo = s:cpo_save
-        finish
-    endif
-
-    " Location of the exuberant ctags tool
-    if !exists('Tlist_Ctags_Cmd')
-        if executable('exuberant-ctags')
-            " On Debian Linux, exuberant ctags is installed
-            " as exuberant-ctags
-            let Tlist_Ctags_Cmd = 'exuberant-ctags'
-        elseif executable('exctags')
-            " On Free-BSD, exuberant ctags is installed as exctags
-            let Tlist_Ctags_Cmd = 'exctags'
-        elseif executable('ctags')
-            let Tlist_Ctags_Cmd = 'ctags'
-        elseif executable('ctags.exe')
-            let Tlist_Ctags_Cmd = 'ctags.exe'
-        elseif executable('tags')
-            let Tlist_Ctags_Cmd = 'tags'
-        else
-            echomsg 'Taglist: Exuberant ctags (http://ctags.sf.net) ' .
-                        \ 'not found in PATH. Plugin is not loaded.'
-            " Skip loading the plugin
-            let loaded_taglist = 'no'
-            let &cpo = s:cpo_save
-            finish
-        endif
-    endif
-
-
-    " Automatically open the taglist window on Vim startup
-    if !exists('Tlist_Auto_Open')
-        let Tlist_Auto_Open = 0
-    endif
-
-    " When the taglist window is toggle opened, move the cursor to the
-    " taglist window
-    if !exists('Tlist_GainFocus_On_ToggleOpen')
-        let Tlist_GainFocus_On_ToggleOpen = 0
-    endif
-
-    " Process files even when the taglist window is not open
-    if !exists('Tlist_Process_File_Always')
-        let Tlist_Process_File_Always = 0
-    endif
-
-    if !exists('Tlist_Show_Menu')
-        let Tlist_Show_Menu = 0
-    endif
-
-    " Tag listing sort type - 'name' or 'order'
-    if !exists('Tlist_Sort_Type')
-        let Tlist_Sort_Type = 'order'
-    endif
-
-    " Tag listing window split (horizontal/vertical) control
-    if !exists('Tlist_Use_Horiz_Window')
-        let Tlist_Use_Horiz_Window = 0
-    endif
-
-    " Open the vertically split taglist window on the left or on the right
-    " side.  This setting is relevant only if Tlist_Use_Horiz_Window is set to
-    " zero (i.e.  only for vertically split windows)
-    if !exists('Tlist_Use_Right_Window')
-        let Tlist_Use_Right_Window = 0
-    endif
-
-    " Increase Vim window width to display vertically split taglist window.
-    " For MS-Windows version of Vim running in a MS-DOS window, this must be
-    " set to 0 otherwise the system may hang due to a Vim limitation.
-    if !exists('Tlist_Inc_Winwidth')
-        if (has('win16') || has('win95')) && !has('gui_running')
-            let Tlist_Inc_Winwidth = 0
-        else
-            let Tlist_Inc_Winwidth = 1
-        endif
-    endif
-
-    " Vertically split taglist window width setting
-    if !exists('Tlist_WinWidth')
-        let Tlist_WinWidth = 30
-    endif
-
-    " Horizontally split taglist window height setting
-    if !exists('Tlist_WinHeight')
-        let Tlist_WinHeight = 10
-    endif
-
-    " Display tag prototypes or tag names in the taglist window
-    if !exists('Tlist_Display_Prototype')
-        let Tlist_Display_Prototype = 0
-    endif
-
-    " Display tag scopes in the taglist window
-    if !exists('Tlist_Display_Tag_Scope')
-        let Tlist_Display_Tag_Scope = 1
-    endif
-
-    " Use single left mouse click to jump to a tag. By default this is disabled.
-    " Only double click using the mouse will be processed.
-    if !exists('Tlist_Use_SingleClick')
-        let Tlist_Use_SingleClick = 0
-    endif
-
-    " Control whether additional help is displayed as part of the taglist or
-    " not.  Also, controls whether empty lines are used to separate the tag
-    " tree.
-    if !exists('Tlist_Compact_Format')
-        let Tlist_Compact_Format = 0
-    endif
-
-    " Exit Vim if only the taglist window is currently open. By default, this is
-    " set to zero.
-    if !exists('Tlist_Exit_OnlyWindow')
-        let Tlist_Exit_OnlyWindow = 0
-    endif
-
-    " Automatically close the folds for the non-active files in the taglist
-    " window
-    if !exists('Tlist_File_Fold_Auto_Close')
-        let Tlist_File_Fold_Auto_Close = 0
-    endif
-
-    " Close the taglist window when a tag is selected
-    if !exists('Tlist_Close_On_Select')
-        let Tlist_Close_On_Select = 0
-    endif
-
-    " Automatically update the taglist window to display tags for newly
-    " edited files
-    if !exists('Tlist_Auto_Update')
-        let Tlist_Auto_Update = 1
-    endif
-
-    " Automatically highlight the current tag
-    if !exists('Tlist_Auto_Highlight_Tag')
-        let Tlist_Auto_Highlight_Tag = 1
-    endif
-    
-    " Automatically highlight the current tag on entering a buffer
-    if !exists('Tlist_Highlight_Tag_On_BufEnter')
-        let Tlist_Highlight_Tag_On_BufEnter = 1
-    endif
-
-    " Enable fold column to display the folding for the tag tree
-    if !exists('Tlist_Enable_Fold_Column')
-        let Tlist_Enable_Fold_Column = 1
-    endif
-
-    " Display the tags for only one file in the taglist window
-    if !exists('Tlist_Show_One_File')
-        let Tlist_Show_One_File = 0
-    endif
-
-    if !exists('Tlist_Max_Submenu_Items')
-        let Tlist_Max_Submenu_Items = 20
-    endif
-
-    if !exists('Tlist_Max_Tag_Length')
-        let Tlist_Max_Tag_Length = 10
-    endif
-
-    " Do not change the name of the taglist title variable. The winmanager
-    " plugin relies on this name to determine the title for the taglist
-    " plugin.
-    let TagList_title = "__Tag_List__"
-
-    " Taglist debug messages
-    let s:tlist_msg = ''
-
-    " Define the taglist autocommand to automatically open the taglist window
-    " on Vim startup
-    if g:Tlist_Auto_Open
-        autocmd VimEnter * nested call s:Tlist_Window_Check_Auto_Open()
-    endif
-
-    " Refresh the taglist
-    if g:Tlist_Process_File_Always
-        autocmd BufEnter * call s:Tlist_Refresh()
-    endif
-
-    if g:Tlist_Show_Menu
-        autocmd GUIEnter * call s:Tlist_Menu_Init()
-    endif
-
-    " When the taglist buffer is created when loading a Vim session file,
-    " the taglist buffer needs to be initialized. The BufFilePost event
-    " is used to handle this case.
-    autocmd BufFilePost __Tag_List__ call s:Tlist_Vim_Session_Load()
-
-    " Define the user commands to manage the taglist window
-    command! -nargs=0 -bar TlistToggle call s:Tlist_Window_Toggle()
-    command! -nargs=0 -bar TlistOpen call s:Tlist_Window_Open()
-    " For backwards compatiblity define the Tlist command
-    command! -nargs=0 -bar Tlist TlistToggle
-    command! -nargs=+ -complete=file TlistAddFiles
-                \  call s:Tlist_Add_Files(<f-args>)
-    command! -nargs=+ -complete=dir TlistAddFilesRecursive
-                \ call s:Tlist_Add_Files_Recursive(<f-args>)
-    command! -nargs=0 -bar TlistClose call s:Tlist_Window_Close()
-    command! -nargs=0 -bar TlistUpdate call s:Tlist_Update_Current_File()
-    command! -nargs=0 -bar TlistHighlightTag call s:Tlist_Window_Highlight_Tag(
-                        \ fnamemodify(bufname('%'), ':p'), line('.'), 2, 1)
-    " For backwards compatiblity define the TlistSync command
-    command! -nargs=0 -bar TlistSync TlistHighlightTag
-    command! -nargs=* -complete=buffer TlistShowPrototype
-                \ echo Tlist_Get_Tag_Prototype_By_Line(<f-args>)
-    command! -nargs=* -complete=buffer TlistShowTag
-                \ echo Tlist_Get_Tagname_By_Line(<f-args>)
-    command! -nargs=* -complete=file TlistSessionLoad
-                \ call s:Tlist_Session_Load(<q-args>)
-    command! -nargs=* -complete=file TlistSessionSave
-                \ call s:Tlist_Session_Save(<q-args>)
-    command! -bar TlistLock let Tlist_Auto_Update=0
-    command! -bar TlistUnlock let Tlist_Auto_Update=1
-
-    " Commands for enabling/disabling debug and to display debug messages
-    command! -nargs=? -complete=file -bar TlistDebug
-                \ call s:Tlist_Debug_Enable(<q-args>)
-    command! -nargs=0 -bar TlistUndebug  call s:Tlist_Debug_Disable()
-    command! -nargs=0 -bar TlistMessages call s:Tlist_Debug_Show()
-
-    " Define autocommands to autoload the taglist plugin when needed.
-
-    " Trick to get the current script ID
-    map <SID>xx <SID>xx
-    let s:tlist_sid = substitute(maparg('<SID>xx'), '<SNR>\(\d\+_\)xx$',
-                                \ '\1', '')
-    unmap <SID>xx
-
-    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_* source ' .
-                \ escape(expand('<sfile>'), ' ')
-    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Window_* source ' .
-                \ escape(expand('<sfile>'), ' ')
-    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Menu_* source ' .
-                \ escape(expand('<sfile>'), ' ')
-    exe 'autocmd FuncUndefined Tlist_* source ' .
-                \ escape(expand('<sfile>'), ' ')
-    exe 'autocmd FuncUndefined TagList_* source ' .
-                \ escape(expand('<sfile>'), ' ')
-
-    let loaded_taglist = 'fast_load_done'
-
-    if g:Tlist_Show_Menu && has('gui_running')
-        call s:Tlist_Menu_Init()
-    endif
-
-    " restore 'cpo'
-    let &cpo = s:cpo_save
-    finish
-endif
-
-if !exists('s:tlist_sid')
-    " Two or more versions of taglist plugin are installed. Don't
-    " load this version of the plugin.
-    finish
-endif
-
-unlet! s:tlist_sid
-
-if loaded_taglist != 'fast_load_done'
-    " restore 'cpo'
-    let &cpo = s:cpo_save
-    finish
-endif
-
-" Taglist plugin functionality is available
-let loaded_taglist = 'available'
-
-"------------------- end of user configurable options --------------------
-
-" Default language specific settings for supported file types and tag types
-"
-" Variable name format:
-"
-"       s:tlist_def_{vim_ftype}_settings
-" 
-" vim_ftype - Filetype detected by Vim
-"
-" Value format:
-"
-"       <ctags_ftype>;<flag>:<name>;<flag>:<name>;...
-"
-" ctags_ftype - File type supported by exuberant ctags
-" flag        - Flag supported by exuberant ctags to generate a tag type
-" name        - Name of the tag type used in the taglist window to display the
-"               tags of this type
-"
-
-" assembly language
-let s:tlist_def_asm_settings = 'asm;d:define;l:label;m:macro;t:type'
-
-" aspperl language
-let s:tlist_def_aspperl_settings = 'asp;f:function;s:sub;v:variable'
-
-" aspvbs language
-let s:tlist_def_aspvbs_settings = 'asp;f:function;s:sub;v:variable'
-
-" awk language
-let s:tlist_def_awk_settings = 'awk;f:function'
-
-" beta language
-let s:tlist_def_beta_settings = 'beta;f:fragment;s:slot;v:pattern'
-
-" c language
-let s:tlist_def_c_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;' .
-                           \ 'v:variable;f:function'
-
-" c++ language
-let s:tlist_def_cpp_settings = 'c++;n:namespace;v:variable;d:macro;t:typedef;' .
-                             \ 'c:class;g:enum;s:struct;u:union;f:function'
-
-" c# language
-let s:tlist_def_cs_settings = 'c#;d:macro;t:typedef;n:namespace;c:class;' .
-                             \ 'E:event;g:enum;s:struct;i:interface;' .
-                             \ 'p:properties;m:method'
-
-" cobol language
-let s:tlist_def_cobol_settings = 'cobol;d:data;f:file;g:group;p:paragraph;' .
-                               \ 'P:program;s:section'
-
-" eiffel language
-let s:tlist_def_eiffel_settings = 'eiffel;c:class;f:feature'
-
-" erlang language
-let s:tlist_def_erlang_settings = 'erlang;d:macro;r:record;m:module;f:function'
-
-" expect (same as tcl) language
-let s:tlist_def_expect_settings = 'tcl;c:class;f:method;p:procedure'
-
-" fortran language
-let s:tlist_def_fortran_settings = 'fortran;p:program;b:block data;' .
-                    \ 'c:common;e:entry;i:interface;k:type;l:label;m:module;' .
-                    \ 'n:namelist;t:derived;v:variable;f:function;s:subroutine'
-
-" HTML language
-let s:tlist_def_html_settings = 'html;a:anchor;f:javascript function'
-
-" java language
-let s:tlist_def_java_settings = 'java;p:package;c:class;i:interface;' .
-                              \ 'f:field;m:method'
-
-" javascript language
-let s:tlist_def_javascript_settings = 'javascript;f:function'
-
-" lisp language
-let s:tlist_def_lisp_settings = 'lisp;f:function'
-
-" lua language
-let s:tlist_def_lua_settings = 'lua;f:function'
-
-" makefiles
-let s:tlist_def_make_settings = 'make;m:macro'
-
-" pascal language
-let s:tlist_def_pascal_settings = 'pascal;f:function;p:procedure'
-
-" perl language
-let s:tlist_def_perl_settings = 'perl;c:constant;l:label;p:package;s:subroutine'
-
-" php language
-let s:tlist_def_php_settings = 'php;c:class;d:constant;v:variable;f:function'
-
-" python language
-let s:tlist_def_python_settings = 'python;c:class;m:member;f:function'
-
-" rexx language
-let s:tlist_def_rexx_settings = 'rexx;s:subroutine'
-
-" ruby language
-let s:tlist_def_ruby_settings = 'ruby;c:class;f:method;F:function;' .
-                              \ 'm:singleton method'
-
-" scheme language
-let s:tlist_def_scheme_settings = 'scheme;s:set;f:function'
-
-" shell language
-let s:tlist_def_sh_settings = 'sh;f:function'
-
-" C shell language
-let s:tlist_def_csh_settings = 'sh;f:function'
-
-" Z shell language
-let s:tlist_def_zsh_settings = 'sh;f:function'
-
-" slang language
-let s:tlist_def_slang_settings = 'slang;n:namespace;f:function'
-
-" sml language
-let s:tlist_def_sml_settings = 'sml;e:exception;c:functor;s:signature;' .
-                             \ 'r:structure;t:type;v:value;f:function'
-
-" sql language
-let s:tlist_def_sql_settings = 'sql;c:cursor;F:field;P:package;r:record;' .
-            \ 's:subtype;t:table;T:trigger;v:variable;f:function;p:procedure'
-
-" tcl language
-let s:tlist_def_tcl_settings = 'tcl;c:class;f:method;m:method;p:procedure'
-
-" vera language
-let s:tlist_def_vera_settings = 'vera;c:class;d:macro;e:enumerator;' .
-                                \ 'f:function;g:enum;m:member;p:program;' .
-                                \ 'P:prototype;t:task;T:typedef;v:variable;' .
-                                \ 'x:externvar'
-
-"verilog language
-let s:tlist_def_verilog_settings = 'verilog;m:module;c:constant;P:parameter;' .
-            \ 'e:event;r:register;t:task;w:write;p:port;v:variable;f:function'
-
-" vim language
-let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'
-
-" yacc language
-let s:tlist_def_yacc_settings = 'yacc;l:label'
-
-"------------------- end of language specific options --------------------
-
-" Vim window size is changed by the taglist plugin or not
-let s:tlist_winsize_chgd = -1
-" Taglist window is maximized or not
-let s:tlist_win_maximized = 0
-" Name of files in the taglist
-let s:tlist_file_names=''
-" Number of files in the taglist
-let s:tlist_file_count = 0
-" Number of filetypes supported by taglist
-let s:tlist_ftype_count = 0
-" Is taglist part of other plugins like winmanager or cream?
-let s:tlist_app_name = "none"
-" Are we displaying brief help text
-let s:tlist_brief_help = 1
-" List of files removed on user request
-let s:tlist_removed_flist = ""
-" Index of current file displayed in the taglist window
-let s:tlist_cur_file_idx = -1
-" Taglist menu is empty or not
-let s:tlist_menu_empty = 1
-
-" An autocommand is used to refresh the taglist window when entering any
-" buffer. We don't want to refresh the taglist window if we are entering the
-" file window from one of the taglist functions. The 'Tlist_Skip_Refresh'
-" variable is used to skip the refresh of the taglist window and is set
-" and cleared appropriately.
-let s:Tlist_Skip_Refresh = 0
-
-" Tlist_Window_Display_Help()
-function! s:Tlist_Window_Display_Help()
-    if s:tlist_app_name == "winmanager"
-        " To handle a bug in the winmanager plugin, add a space at the
-        " last line
-        call setline('$', ' ')
-    endif
-
-    if s:tlist_brief_help
-        " Add the brief help
-        call append(0, '" Press <F1> to display help text')
-    else
-        " Add the extensive help
-        call append(0, '" <enter> : Jump to tag definition')
-        call append(1, '" o : Jump to tag definition in new window')
-        call append(2, '" p : Preview the tag definition')
-        call append(3, '" <space> : Display tag prototype')
-        call append(4, '" u : Update tag list')
-        call append(5, '" s : Select sort field')
-        call append(6, '" d : Remove file from taglist')
-        call append(7, '" x : Zoom-out/Zoom-in taglist window')
-        call append(8, '" + : Open a fold')
-        call append(9, '" - : Close a fold')
-        call append(10, '" * : Open all folds')
-        call append(11, '" = : Close all folds')
-        call append(12, '" [[ : Move to the start of previous file')
-        call append(13, '" ]] : Move to the start of next file')
-        call append(14, '" q : Close the taglist window')
-        call append(15, '" <F1> : Remove help text')
-    endif
-endfunction
-
-" Tlist_Window_Toggle_Help_Text()
-" Toggle taglist plugin help text between the full version and the brief
-" version
-function! s:Tlist_Window_Toggle_Help_Text()
-    if g:Tlist_Compact_Format
-        " In compact display mode, do not display help
-        return
-    endif
-
-    " Include the empty line displayed after the help text
-    let brief_help_size = 1
-    let full_help_size = 16
-
-    setlocal modifiable
-
-    " Set report option to a huge value to prevent informational messages
-    " while deleting the lines
-    let old_report = &report
-    set report=99999
-
-    " Remove the currently highlighted tag. Otherwise, the help text
-    " might be highlighted by mistake
-    match none
-
-    " Toggle between brief and full help text
-    if s:tlist_brief_help
-        let s:tlist_brief_help = 0
-
-        " Remove the previous help
-        exe '1,' . brief_help_size . ' delete _'
-
-        " Adjust the start/end line numbers for the files
-        call s:Tlist_Window_Update_Line_Offsets(0, 1, full_help_size - brief_help_size)
-    else
-        let s:tlist_brief_help = 1
-
-        " Remove the previous help
-        exe '1,' . full_help_size . ' delete _'
-
-        " Adjust the start/end line numbers for the files
-        call s:Tlist_Window_Update_Line_Offsets(0, 0, full_help_size - brief_help_size)
-    endif
-
-    call s:Tlist_Window_Display_Help()
-
-    " Restore the report option
-    let &report = old_report
-
-    setlocal nomodifiable
-endfunction
-
-" Taglist debug support
-let s:tlist_debug = 0
-
-" File for storing the debug messages
-let s:tlist_debug_file = ''
-
-" Tlist_Debug_Enable
-" Enable logging of taglist debug messages.
-function! s:Tlist_Debug_Enable(...)
-    let s:tlist_debug = 1
-
-    " Check whether a valid file name is supplied.
-    if a:1 != ''
-        let s:tlist_debug_file = fnamemodify(a:1, ':p')
-
-        " Empty the log file
-        exe 'redir! > ' . s:tlist_debug_file
-        redir END
-
-        " Check whether the log file is present/created
-        if !filewritable(s:tlist_debug_file)
-            call s:Tlist_Warning_Msg('Taglist: Unable to create log file '
-                        \ . s:tlist_debug_file)
-            let s:tlist_debug_file = ''
-        endif
-    endif
-endfunction
-
-" Tlist_Debug_Disable
-" Disable logging of taglist debug messages.
-function! s:Tlist_Debug_Disable(...)
-    let s:tlist_debug = 0
-    let s:tlist_debug_file = ''
-endfunction
-
-" Tlist_Debug_Show
-" Display the taglist debug messages in a new window
-function! s:Tlist_Debug_Show()
-    if s:tlist_msg == ''
-        call s:Tlist_Warning_Msg('Taglist: No debug messages')
-        return
-    endif
-
-    " Open a new window to display the taglist debug messages
-    new taglist_debug.txt
-    " Delete all the lines (if the buffer already exists)
-    silent! %delete _
-    " Add the messages
-    silent! put =s:tlist_msg
-    " Move the cursor to the first line
-    normal! gg
-endfunction
-
-" Tlist_Log_Msg
-" Log the supplied debug message along with the time
-function! s:Tlist_Log_Msg(msg)
-    if s:tlist_debug
-        if s:tlist_debug_file != ''
-            exe 'redir >> ' . s:tlist_debug_file
-            silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
-            redir END
-        else
-            " Log the message into a variable
-            " Retain only the last 3000 characters
-            let len = strlen(s:tlist_msg)
-            if len > 3000
-                let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
-            endif
-            let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' . 
-                        \ a:msg . "\n"
-        endif
-    endif
-endfunction
-
-" Tlist_Warning_Msg()
-" Display a message using WarningMsg highlight group
-function! s:Tlist_Warning_Msg(msg)
-    echohl WarningMsg
-    echomsg a:msg
-    echohl None
-endfunction
-
-" Last returned file index for file name lookup.
-" Used to speed up file lookup
-let s:tlist_file_name_idx_cache = -1
-
-" Tlist_Get_File_Index()
-" Return the index of the specified filename
-function! s:Tlist_Get_File_Index(fname)
-    if s:tlist_file_count == 0 || a:fname == ''
-        return -1
-    endif
-
-    " If the new filename is same as the last accessed filename, then
-    " return that index
-    if s:tlist_file_name_idx_cache != -1 &&
-                \ s:tlist_file_name_idx_cache < s:tlist_file_count
-        if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
-            " Same as the last accessed file
-            return s:tlist_file_name_idx_cache
-        endif
-    endif
-
-    " First, check whether the filename is present
-    let s_fname = a:fname . "\n"
-    let i = stridx(s:tlist_file_names, s_fname)
-    if i == -1
-        let s:tlist_file_name_idx_cache = -1
-        return -1
-    endif
-
-    " Second, compute the file name index
-    let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
-    let s:tlist_file_name_idx_cache = strlen(nl_txt)
-    return s:tlist_file_name_idx_cache
-endfunction
-
-" Last returned file index for line number lookup.
-" Used to speed up file lookup
-let s:tlist_file_lnum_idx_cache = -1
-
-" Tlist_Window_Get_File_Index_By_Linenum()
-" Return the index of the filename present in the specified line number
-" Line number refers to the line number in the taglist window
-function! s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
-    call s:Tlist_Log_Msg('Tlist_Window_Get_File_Index_By_Linenum (' . a:lnum . ')')
-
-    " First try to see whether the new line number is within the range
-    " of the last returned file
-    if s:tlist_file_lnum_idx_cache != -1 &&
-                \ s:tlist_file_lnum_idx_cache < s:tlist_file_count
-        if a:lnum >= s:tlist_{s:tlist_file_lnum_idx_cache}_start &&
-                    \ a:lnum <= s:tlist_{s:tlist_file_lnum_idx_cache}_end
-            return s:tlist_file_lnum_idx_cache
-        endif
-    endif
-
-    let fidx = -1
-
-    if g:Tlist_Show_One_File
-        " Displaying only one file in the taglist window. Check whether
-        " the line is within the tags displayed for that file
-        if s:tlist_cur_file_idx != -1
-            if a:lnum >= s:tlist_{s:tlist_cur_file_idx}_start
-                        \ && a:lnum <= s:tlist_{s:tlist_cur_file_idx}_end
-                let fidx = s:tlist_cur_file_idx
-            endif
-
-        endif
-    else
-        " Do a binary search in the taglist
-        let left = 0
-        let right = s:tlist_file_count - 1
-
-        while left < right
-            let mid = (left + right) / 2
-
-            if a:lnum >= s:tlist_{mid}_start && a:lnum <= s:tlist_{mid}_end
-                let s:tlist_file_lnum_idx_cache = mid
-                return mid
-            endif
-
-            if a:lnum < s:tlist_{mid}_start
-                let right = mid - 1
-            else
-                let left = mid + 1
-            endif
-        endwhile
-
-        if left >= 0 && left < s:tlist_file_count
-                    \ && a:lnum >= s:tlist_{left}_start
-                    \ && a:lnum <= s:tlist_{left}_end
-            let fidx = left
-        endif
-    endif
-
-    let s:tlist_file_lnum_idx_cache = fidx
-
-    return fidx
-endfunction
-
-" Tlist_Exe_Cmd_No_Acmds
-" Execute the specified Ex command after disabling autocommands
-function! s:Tlist_Exe_Cmd_No_Acmds(cmd)
-    let old_eventignore = &eventignore
-    set eventignore=all
-    exe a:cmd
-    let &eventignore = old_eventignore
-endfunction
-
-" Tlist_Skip_File()
-" Check whether tag listing is supported for the specified file
-function! s:Tlist_Skip_File(filename, ftype)
-    " Skip buffers with no names and buffers with filetype not set
-    if a:filename == '' || a:ftype == ''
-        return 1
-    endif
-
-    " Skip files which are not supported by exuberant ctags
-    " First check whether default settings for this filetype are available.
-    " If it is not available, then check whether user specified settings are
-    " available. If both are not available, then don't list the tags for this
-    " filetype
-    let var = 's:tlist_def_' . a:ftype . '_settings'
-    if !exists(var)
-        let var = 'g:tlist_' . a:ftype . '_settings'
-        if !exists(var)
-            return 1
-        endif
-    endif
-
-    " Skip files which are not readable or files which are not yet stored
-    " to the disk
-    if !filereadable(a:filename)
-        return 1
-    endif
-
-    return 0
-endfunction
-
-" Tlist_User_Removed_File
-" Returns 1 if a file is removed by a user from the taglist
-function! s:Tlist_User_Removed_File(filename)
-    return stridx(s:tlist_removed_flist, a:filename . "\n") != -1
-endfunction
-
-" Tlist_Update_Remove_List
-" Update the list of user removed files from the taglist
-" add == 1, add the file to the removed list
-" add == 0, delete the file from the removed list
-function! s:Tlist_Update_Remove_List(filename, add)
-    if a:add
-        let s:tlist_removed_flist = s:tlist_removed_flist . a:filename . "\n"
-    else
-        let idx = stridx(s:tlist_removed_flist, a:filename . "\n")
-        let text_before = strpart(s:tlist_removed_flist, 0, idx)
-        let rem_text = strpart(s:tlist_removed_flist, idx)
-        let next_idx = stridx(rem_text, "\n")
-        let text_after = strpart(rem_text, next_idx + 1)
-
-        let s:tlist_removed_flist = text_before . text_after
-    endif
-endfunction
-
-" Tlist_FileType_Init
-" Initialize the ctags arguments and tag variable for the specified
-" file type
-function! s:Tlist_FileType_Init(ftype)
-    call s:Tlist_Log_Msg('Tlist_FileType_Init (' . a:ftype . ')')
-    " If the user didn't specify any settings, then use the default
-    " ctags args. Otherwise, use the settings specified by the user
-    let var = 'g:tlist_' . a:ftype . '_settings'
-    if exists(var)
-        " User specified ctags arguments
-        let settings = {var} . ';'
-    else
-        " Default ctags arguments
-        let var = 's:tlist_def_' . a:ftype . '_settings'
-        if !exists(var)
-            " No default settings for this file type. This filetype is
-            " not supported
-            return 0
-        endif
-        let settings = s:tlist_def_{a:ftype}_settings . ';'
-    endif
-
-    let msg = 'Taglist: Invalid ctags option setting - ' . settings
-
-    " Format of the option that specifies the filetype and ctags arugments:
-    "
-    "       <language_name>;flag1:name1;flag2:name2;flag3:name3
-    "
-
-    " Extract the file type to pass to ctags. This may be different from the
-    " file type detected by Vim
-    let pos = stridx(settings, ';')
-    if pos == -1
-        call s:Tlist_Warning_Msg(msg)
-        return 0
-    endif
-    let ctags_ftype = strpart(settings, 0, pos)
-    if ctags_ftype == ''
-        call s:Tlist_Warning_Msg(msg)
-        return 0
-    endif
-    " Make sure a valid filetype is supplied. If the user didn't specify a
-    " valid filetype, then the ctags option settings may be treated as the
-    " filetype
-    if ctags_ftype =~ ':'
-        call s:Tlist_Warning_Msg(msg)
-        return 0
-    endif
-
-    " Remove the file type from settings
-    let settings = strpart(settings, pos + 1)
-    if settings == ''
-        call s:Tlist_Warning_Msg(msg)
-        return 0
-    endif
-
-    " Process all the specified ctags flags. The format is
-    " flag1:name1;flag2:name2;flag3:name3
-    let ctags_flags = ''
-    let cnt = 0
-    while settings != ''
-        " Extract the flag
-        let pos = stridx(settings, ':')
-        if pos == -1
-            call s:Tlist_Warning_Msg(msg)
-            return 0
-        endif
-        let flag = strpart(settings, 0, pos)
-        if flag == ''
-            call s:Tlist_Warning_Msg(msg)
-            return 0
-        endif
-        " Remove the flag from settings
-        let settings = strpart(settings, pos + 1)
-
-        " Extract the tag type name
-        let pos = stridx(settings, ';')
-        if pos == -1
-            call s:Tlist_Warning_Msg(msg)
-            return 0
-        endif
-        let name = strpart(settings, 0, pos)
-        if name == ''
-            call s:Tlist_Warning_Msg(msg)
-            return 0
-        endif
-        let settings = strpart(settings, pos + 1)
-
-        let cnt = cnt + 1
-
-        let s:tlist_{a:ftype}_{cnt}_name = flag
-        let s:tlist_{a:ftype}_{cnt}_fullname = name
-        let ctags_flags = ctags_flags . flag
-    endwhile
-
-    let s:tlist_{a:ftype}_ctags_args = '--language-force=' . ctags_ftype .
-                            \ ' --' . ctags_ftype . '-types=' . ctags_flags
-    let s:tlist_{a:ftype}_count = cnt
-    let s:tlist_{a:ftype}_ctags_flags = ctags_flags
-
-    " Save the filetype name
-    let s:tlist_ftype_{s:tlist_ftype_count}_name = a:ftype
-    let s:tlist_ftype_count = s:tlist_ftype_count + 1
-
-    return 1
-endfunction
-
-" Tlist_Detect_Filetype
-" Determine the filetype for the specified file using the filetypedetect
-" autocmd.
-function! s:Tlist_Detect_Filetype(fname)
-    " Ignore the filetype autocommands
-    let old_eventignore = &eventignore
-    set eventignore=FileType
-
-    " Save the 'filetype', as this will be changed temporarily
-    let old_filetype = &filetype
-
-    " Run the filetypedetect group of autocommands to determine
-    " the filetype
-    exe 'doautocmd filetypedetect BufRead ' . a:fname
-
-    " Save the detected filetype
-    let ftype = &filetype
-
-    " Restore the previous state
-    let &filetype = old_filetype
-    let &eventignore = old_eventignore
-
-    return ftype
-endfunction
-
-" Tlist_Get_Buffer_Filetype
-" Get the filetype for the specified buffer
-function! s:Tlist_Get_Buffer_Filetype(bnum)
-    let buf_ft = getbufvar(a:bnum, '&filetype')
-
-    if bufloaded(a:bnum)
-        " For loaded buffers, the 'filetype' is already determined
-        return buf_ft
-    endif
-
-    " For unloaded buffers, if the 'filetype' option is set, return it
-    if buf_ft != ''
-        return buf_ft
-    endif
-
-    " Skip non-existent buffers
-    if !bufexists(a:bnum)
-        return ''
-    endif
-
-    " For buffers whose filetype is not yet determined, try to determine
-    " the filetype
-    let bname = bufname(a:bnum)
-
-    return s:Tlist_Detect_Filetype(bname)
-endfunction
-
-" Tlist_Discard_TagInfo
-" Discard the stored tag information for a file
-function! s:Tlist_Discard_TagInfo(fidx)
-    call s:Tlist_Log_Msg('Tlist_Discard_TagInfo (' .
-                \ s:tlist_{a:fidx}_filename . ')')
-    let ftype = s:tlist_{a:fidx}_filetype
-
-    " Discard information about the tags defined in the file
-    let i = 1
-    while i <= s:tlist_{a:fidx}_tag_count
-        let fidx_i = 's:tlist_' . a:fidx . '_' . i
-        unlet! {fidx_i}_tag
-        unlet! {fidx_i}_tag_name
-        unlet! {fidx_i}_tag_type
-        unlet! {fidx_i}_ttype_idx
-        unlet! {fidx_i}_tag_proto
-        unlet! {fidx_i}_tag_searchpat
-        unlet! {fidx_i}_tag_linenum
-        let i = i + 1
-    endwhile
-
-    let s:tlist_{a:fidx}_tag_count = 0
-
-    " Discard information about tag type groups
-    let i = 1
-    while i <= s:tlist_{ftype}_count
-        let ttype = s:tlist_{ftype}_{i}_name
-        if s:tlist_{a:fidx}_{ttype} != ''
-            let fidx_ttype = 's:tlist_' . a:fidx . '_' . ttype
-            let {fidx_ttype} = ''
-            let {fidx_ttype}_offset = 0
-            let cnt = {fidx_ttype}_count
-            let {fidx_ttype}_count = 0
-            let j = 1
-            while j <= cnt
-                unlet! {fidx_ttype}_{j}
-                let j = j + 1
-            endwhile
-        endif
-        let i = i + 1
-    endwhile
-
-    " Discard the stored menu command also
-    let s:tlist_{a:fidx}_menu_cmd = ''
-endfunction
-
-" Tlist_Window_Update_Line_Offsets
-" Update the line offsets for tags for files starting from start_idx
-" and displayed in the taglist window by the specified offset
-function! s:Tlist_Window_Update_Line_Offsets(start_idx, increment, offset)
-    let i = a:start_idx
-
-    while i < s:tlist_file_count
-        if s:tlist_{i}_visible
-            " Update the start/end line number only if the file is visible
-            if a:increment
-                let s:tlist_{i}_start = s:tlist_{i}_start + a:offset
-                let s:tlist_{i}_end = s:tlist_{i}_end + a:offset
-            else
-                let s:tlist_{i}_start = s:tlist_{i}_start - a:offset
-                let s:tlist_{i}_end = s:tlist_{i}_end - a:offset
-            endif
-        endif
-        let i = i + 1
-    endwhile
-endfunction
-
-" Tlist_Discard_FileInfo
-" Discard the stored information for a file
-function! s:Tlist_Discard_FileInfo(fidx)
-    call s:Tlist_Log_Msg('Tlist_Discard_FileInfo (' .
-                \ s:tlist_{a:fidx}_filename . ')')
-    call s:Tlist_Discard_TagInfo(a:fidx)
-
-    let ftype = s:tlist_{a:fidx}_filetype
-
-    let i = 1
-    while i <= s:tlist_{ftype}_count
-        let ttype = s:tlist_{ftype}_{i}_name
-        unlet! s:tlist_{a:fidx}_{ttype}
-        unlet! s:tlist_{a:fidx}_{ttype}_offset
-        unlet! s:tlist_{a:fidx}_{ttype}_count
-        let i = i + 1
-    endwhile
-
-    unlet! s:tlist_{a:fidx}_filename
-    unlet! s:tlist_{a:fidx}_sort_type
-    unlet! s:tlist_{a:fidx}_filetype
-    unlet! s:tlist_{a:fidx}_mtime
-    unlet! s:tlist_{a:fidx}_start
-    unlet! s:tlist_{a:fidx}_end
-    unlet! s:tlist_{a:fidx}_valid
-    unlet! s:tlist_{a:fidx}_visible
-    unlet! s:tlist_{a:fidx}_tag_count
-    unlet! s:tlist_{a:fidx}_menu_cmd
-endfunction
-
-" Tlist_Window_Remove_File_From_Display
-" Remove the specified file from display
-function! s:Tlist_Window_Remove_File_From_Display(fidx)
-    call s:Tlist_Log_Msg('Tlist_Window_Remove_File_From_Display (' .
-                \ s:tlist_{a:fidx}_filename . ')')
-    " If the file is not visible then no need to remove it
-    if !s:tlist_{a:fidx}_visible
-        return
-    endif
-
-    " Remove the tags displayed for the specified file from the window
-    let start = s:tlist_{a:fidx}_start
-    " Include the empty line after the last line also
-    if g:Tlist_Compact_Format
-        let end = s:tlist_{a:fidx}_end
-    else
-        let end = s:tlist_{a:fidx}_end + 1
-    endif
-
-    setlocal modifiable
-    exe 'silent! ' . start . ',' . end . 'delete _'
-    setlocal nomodifiable
-
-    " Correct the start and end line offsets for all the files following
-    " this file, as the tags for this file are removed
-    call s:Tlist_Window_Update_Line_Offsets(a:fidx + 1, 0, end - start + 1)
-endfunction
-
-" Tlist_Remove_File
-" Remove the file under the cursor or the specified file index
-" user_request - User requested to remove the file from taglist
-function! s:Tlist_Remove_File(file_idx, user_request)
-    let fidx = a:file_idx
-
-    if fidx == -1
-        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
-        if fidx == -1
-            return
-        endif
-    endif
-    call s:Tlist_Log_Msg('Tlist_Remove_File (' .
-                \ s:tlist_{fidx}_filename . ', ' . a:user_request . ')')
-
-    let save_winnr = winnr()
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum != -1
-        " Taglist window is open, remove the file from display
-
-        if save_winnr != winnum
-            let old_eventignore = &eventignore
-            set eventignore=all
-            exe winnum . 'wincmd w'
-        endif
-
-        call s:Tlist_Window_Remove_File_From_Display(fidx)
-
-        if save_winnr != winnum
-            exe save_winnr . 'wincmd w'
-            let &eventignore = old_eventignore
-        endif
-    endif
-
-    let fname = s:tlist_{fidx}_filename
-
-    if a:user_request
-        " As the user requested to remove the file from taglist,
-        " add it to the removed list
-        call s:Tlist_Update_Remove_List(fname, 1)
-    endif
-
-    " Remove the file name from the taglist list of filenames
-    let idx = stridx(s:tlist_file_names, fname . "\n")
-    let text_before = strpart(s:tlist_file_names, 0, idx)
-    let rem_text = strpart(s:tlist_file_names, idx)
-    let next_idx = stridx(rem_text, "\n")
-    let text_after = strpart(rem_text, next_idx + 1)
-    let s:tlist_file_names = text_before . text_after
-
-    call s:Tlist_Discard_FileInfo(fidx)
-
-    " Shift all the file variables by one index
-    let i = fidx + 1
-
-    while i < s:tlist_file_count
-        let j = i - 1
-
-        let s:tlist_{j}_filename = s:tlist_{i}_filename
-        let s:tlist_{j}_sort_type = s:tlist_{i}_sort_type
-        let s:tlist_{j}_filetype = s:tlist_{i}_filetype
-        let s:tlist_{j}_mtime = s:tlist_{i}_mtime
-        let s:tlist_{j}_start = s:tlist_{i}_start
-        let s:tlist_{j}_end = s:tlist_{i}_end
-        let s:tlist_{j}_valid = s:tlist_{i}_valid
-        let s:tlist_{j}_visible = s:tlist_{i}_visible
-        let s:tlist_{j}_tag_count = s:tlist_{i}_tag_count
-        let s:tlist_{j}_menu_cmd = s:tlist_{i}_menu_cmd
-
-        let k = 1
-        while k <= s:tlist_{j}_tag_count
-            let s:tlist_{j}_{k}_tag = s:tlist_{i}_{k}_tag
-            let s:tlist_{j}_{k}_tag_name = s:tlist_{i}_{k}_tag_name
-            let s:tlist_{j}_{k}_tag_type = s:Tlist_Get_Tag_Type_By_Tag(i, k)
-            let s:tlist_{j}_{k}_ttype_idx = s:tlist_{i}_{k}_ttype_idx
-            let s:tlist_{j}_{k}_tag_proto = s:Tlist_Get_Tag_Prototype(i, k)
-            let s:tlist_{j}_{k}_tag_searchpat = s:Tlist_Get_Tag_SearchPat(i, k)
-            let s:tlist_{j}_{k}_tag_linenum = s:Tlist_Get_Tag_Linenum(i, k)
-            let k = k + 1
-        endwhile
-
-        let ftype = s:tlist_{i}_filetype
-
-        let k = 1
-        while k <= s:tlist_{ftype}_count
-            let ttype = s:tlist_{ftype}_{k}_name
-            let s:tlist_{j}_{ttype} = s:tlist_{i}_{ttype}
-            let s:tlist_{j}_{ttype}_offset = s:tlist_{i}_{ttype}_offset
-            let s:tlist_{j}_{ttype}_count = s:tlist_{i}_{ttype}_count
-            if s:tlist_{j}_{ttype} != ''
-                let l = 1
-                while l <= s:tlist_{j}_{ttype}_count
-                    let s:tlist_{j}_{ttype}_{l} = s:tlist_{i}_{ttype}_{l}
-                    let l = l + 1
-                endwhile
-            endif
-            let k = k + 1
-        endwhile
-
-        " As the file and tag information is copied to the new index,
-        " discard the previous information
-        call s:Tlist_Discard_FileInfo(i)
-
-        let i = i + 1
-    endwhile
-
-    " Reduce the number of files displayed
-    let s:tlist_file_count = s:tlist_file_count - 1
-
-    if g:Tlist_Show_One_File
-        " If the tags for only one file is displayed and if we just
-        " now removed that file, then invalidate the current file idx
-        if s:tlist_cur_file_idx == fidx
-            let s:tlist_cur_file_idx = -1
-        endif
-    endif
-endfunction
-
-" Tlist_Window_Goto_Window
-" Goto the taglist window
-function! s:Tlist_Window_Goto_Window()
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum != -1
-        if winnr() != winnum
-            call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
-        endif
-    endif
-endfunction
-
-" Tlist_Window_Create
-" Create a new taglist window. If it is already open, jump to it
-function! s:Tlist_Window_Create()
-    call s:Tlist_Log_Msg('Tlist_Window_Create()')
-    " If the window is open, jump to it
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum != -1
-        " Jump to the existing window
-        if winnr() != winnum
-            exe winnum . 'wincmd w'
-        endif
-        return
-    endif
-
-    " If used with winmanager don't open windows. Winmanager will handle
-    " the window/buffer management
-    if s:tlist_app_name == "winmanager"
-        return
-    endif
-
-    " Create a new window. If user prefers a horizontal window, then open
-    " a horizontally split window. Otherwise open a vertically split
-    " window
-    if g:Tlist_Use_Horiz_Window
-        " Open a horizontally split window
-        let win_dir = 'botright'
-        " Horizontal window height
-        let win_size = g:Tlist_WinHeight
-    else
-        if s:tlist_winsize_chgd == -1
-            " Open a vertically split window. Increase the window size, if
-            " needed, to accomodate the new window
-            if g:Tlist_Inc_Winwidth &&
-                        \ &columns < (80 + g:Tlist_WinWidth)
-                " Save the original window position
-                let s:tlist_pre_winx = getwinposx()
-                let s:tlist_pre_winy = getwinposy()
-
-                " one extra column is needed to include the vertical split
-                let &columns= &columns + g:Tlist_WinWidth + 1
-
-                let s:tlist_winsize_chgd = 1
-            else
-                let s:tlist_winsize_chgd = 0
-            endif
-        endif
-
-        if g:Tlist_Use_Right_Window
-            " Open the window at the rightmost place
-            let win_dir = 'botright vertical'
-        else
-            " Open the window at the leftmost place
-            let win_dir = 'topleft vertical'
-        endif
-        let win_size = g:Tlist_WinWidth
-    endif
-
-    " If the tag listing temporary buffer already exists, then reuse it.
-    " Otherwise create a new buffer
-    let bufnum = bufnr(g:TagList_title)
-    if bufnum == -1
-        " Create a new buffer
-        let wcmd = g:TagList_title
-    else
-        " Edit the existing buffer
-        let wcmd = '+buffer' . bufnum
-    endif
-
-    " Create the taglist window
-    exe 'silent! ' . win_dir . ' ' . win_size . 'split ' . wcmd
-
-    " Save the new window position
-    let s:tlist_winx = getwinposx()
-    let s:tlist_winy = getwinposy()
-
-    " Initialize the taglist window
-    call s:Tlist_Window_Init()
-endfunction
-
-" Tlist_Window_Zoom
-" Zoom (maximize/minimize) the taglist window
-function! s:Tlist_Window_Zoom()
-    if s:tlist_win_maximized
-        " Restore the window back to the previous size
-        if g:Tlist_Use_Horiz_Window
-            exe 'resize ' . g:Tlist_WinHeight
-        else
-            exe 'vert resize ' . g:Tlist_WinWidth
-        endif
-        let s:tlist_win_maximized = 0
-    else
-        " Set the window size to the maximum possible without closing other
-        " windows
-        if g:Tlist_Use_Horiz_Window
-            resize
-        else
-            vert resize
-        endif
-        let s:tlist_win_maximized = 1
-    endif
-endfunction
-
-" Tlist_Ballon_Expr
-" When the mouse cursor is over a tag in the taglist window, display the
-" tag prototype (balloon)
-function! Tlist_Ballon_Expr()
-    " Get the file index
-    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(v:beval_lnum)
-    if fidx == -1
-        return ''
-    endif
-
-    " Get the tag output line for the current tag
-    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, v:beval_lnum)
-    if tidx == 0
-        return ''
-    endif
-
-    " Get the tag search pattern and display it
-    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
-endfunction
-
-" Tlist_Window_Check_Width
-" Check the width of the taglist window. For horizontally split windows, the
-" 'winfixheight' option is used to fix the height of the window. For
-" vertically split windows, Vim doesn't support the 'winfixwidth' option. So
-" need to handle window width changes from this function.
-function! s:Tlist_Window_Check_Width()
-    let tlist_winnr = bufwinnr(g:TagList_title)
-    if tlist_winnr == -1
-        return
-    endif
-
-    let width = winwidth(tlist_winnr)
-    if width != g:Tlist_WinWidth
-        call s:Tlist_Log_Msg("Tlist_Window_Check_Width: Changing window " .
-                    \ "width from " . width . " to " . g:Tlist_WinWidth)
-        let save_winnr = winnr()
-        if save_winnr != tlist_winnr
-            call s:Tlist_Exe_Cmd_No_Acmds(tlist_winnr . 'wincmd w')
-        endif
-        exe 'vert resize ' . g:Tlist_WinWidth
-        if save_winnr != tlist_winnr
-            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
-        endif
-    endif
-endfunction
-
-" Tlist_Window_Exit_Only_Window
-" If the 'Tlist_Exit_OnlyWindow' option is set, then exit Vim if only the
-" taglist window is present.
-function! s:Tlist_Window_Exit_Only_Window()
-    " Before quitting Vim, delete the taglist buffer so that
-    " the '0 mark is correctly set to the previous buffer.
-    if v:version < 700
-	if winbufnr(2) == -1
-	    bdelete
-	    quit
-	endif
-    else
-	if winbufnr(2) == -1
-	    if tabpagenr('$') == 1
-		" Only one tag page is present
-		bdelete
-		quit
-	    else
-		" More than one tab page is present. Close only the current
-		" tab page
-		close
-	    endif
-	endif
-    endif
-endfunction
-
-" Tlist_Window_Init
-" Set the default options for the taglist window
-function! s:Tlist_Window_Init()
-    call s:Tlist_Log_Msg('Tlist_Window_Init()')
-
-    " The 'readonly' option should not be set for the taglist buffer.
-    " If Vim is started as "view/gview" or if the ":view" command is
-    " used, then the 'readonly' option is set for all the buffers.
-    " Unset it for the taglist buffer
-    setlocal noreadonly
-
-    " Set the taglist buffer filetype to taglist
-    setlocal filetype=taglist
-
-    " Define taglist window element highlighting
-    syntax match TagListComment '^" .*'
-    syntax match TagListFileName '^[^" ].*$'
-    syntax match TagListTitle '^  \S.*$'
-    syntax match TagListTagScope  '\s\[.\{-\}\]$'
-
-    " Define the highlighting only if colors are supported
-    if has('gui_running') || &t_Co > 2
-        " Colors to highlight various taglist window elements
-        " If user defined highlighting group exists, then use them.
-        " Otherwise, use default highlight groups.
-        if hlexists('MyTagListTagName')
-            highlight link TagListTagName MyTagListTagName
-        else
-            highlight default link TagListTagName Search
-        endif
-        " Colors to highlight comments and titles
-        if hlexists('MyTagListComment')
-            highlight link TagListComment MyTagListComment
-        else
-            highlight clear TagListComment
-            highlight default link TagListComment Comment
-        endif
-        if hlexists('MyTagListTitle')
-            highlight link TagListTitle MyTagListTitle
-        else
-            highlight clear TagListTitle
-            highlight default link TagListTitle Title
-        endif
-        if hlexists('MyTagListFileName')
-            highlight link TagListFileName MyTagListFileName
-        else
-            highlight clear TagListFileName
-            highlight default TagListFileName guibg=Grey ctermbg=darkgray
-                        \ guifg=white ctermfg=white
-        endif
-        if hlexists('MyTagListTagScope')
-            highlight link TagListTagScope MyTagListTagScope
-        else
-            highlight clear TagListTagScope
-            highlight default link TagListTagScope Identifier
-        endif
-    else
-        highlight default TagListTagName term=reverse cterm=reverse
-    endif
-
-    " Folding related settings
-    setlocal foldenable
-    setlocal foldminlines=0
-    setlocal foldmethod=manual
-    setlocal foldlevel=9999
-    if g:Tlist_Enable_Fold_Column
-        setlocal foldcolumn=3
-    else
-        setlocal foldcolumn=0
-    endif
-    setlocal foldtext=v:folddashes.getline(v:foldstart)
-
-    if s:tlist_app_name != "winmanager"
-        " Mark buffer as scratch
-        silent! setlocal buftype=nofile
-        if s:tlist_app_name == "none"
-            silent! setlocal bufhidden=delete
-        endif
-        silent! setlocal noswapfile
-        " Due to a bug in Vim 6.0, the winbufnr() function fails for unlisted
-        " buffers. So if the taglist buffer is unlisted, multiple taglist
-        " windows will be opened. This bug is fixed in Vim 6.1 and above
-        if v:version >= 601
-            silent! setlocal nobuflisted
-        endif
-    endif
-
-    silent! setlocal nowrap
-
-    " If the 'number' option is set in the source window, it will affect the
-    " taglist window. So forcefully disable 'number' option for the taglist
-    " window
-    silent! setlocal nonumber
-
-    " Use fixed height when horizontally split window is used
-    if g:Tlist_Use_Horiz_Window
-        if v:version >= 602
-            set winfixheight
-        endif
-    endif
-    if !g:Tlist_Use_Horiz_Window && v:version >= 700
-        set winfixwidth
-    endif
-
-    " Setup balloon evaluation to display tag prototype
-    if v:version >= 700 && has('balloon_eval')
-        setlocal balloonexpr=Tlist_Ballon_Expr()
-        set ballooneval
-    endif
-
-    " Setup the cpoptions properly for the maps to work
-    let old_cpoptions = &cpoptions
-    set cpoptions&vim
-
-    " Create buffer local mappings for jumping to the tags and sorting the list
-    nnoremap <buffer> <silent> <CR>
-                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
-    nnoremap <buffer> <silent> o
-                \ :call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
-    nnoremap <buffer> <silent> p
-                \ :call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
-    nnoremap <buffer> <silent> P
-                \ :call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
-    if v:version >= 700
-    nnoremap <buffer> <silent> t
-                \ :call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
-    nnoremap <buffer> <silent> <C-t>
-                \ :call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
-    endif
-    nnoremap <buffer> <silent> <2-LeftMouse>
-                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
-    nnoremap <buffer> <silent> s
-                \ :call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
-    nnoremap <buffer> <silent> + :silent! foldopen<CR>
-    nnoremap <buffer> <silent> - :silent! foldclose<CR>
-    nnoremap <buffer> <silent> * :silent! %foldopen!<CR>
-    nnoremap <buffer> <silent> = :silent! %foldclose<CR>
-    nnoremap <buffer> <silent> <kPlus> :silent! foldopen<CR>
-    nnoremap <buffer> <silent> <kMinus> :silent! foldclose<CR>
-    nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!<CR>
-    nnoremap <buffer> <silent> <Space> :call <SID>Tlist_Window_Show_Info()<CR>
-    nnoremap <buffer> <silent> u :call <SID>Tlist_Window_Update_File()<CR>
-    nnoremap <buffer> <silent> d :call <SID>Tlist_Remove_File(-1, 1)<CR>
-    nnoremap <buffer> <silent> x :call <SID>Tlist_Window_Zoom()<CR>
-    nnoremap <buffer> <silent> [[ :call <SID>Tlist_Window_Move_To_File(-1)<CR>
-    nnoremap <buffer> <silent> <BS> :call <SID>Tlist_Window_Move_To_File(-1)<CR>
-    nnoremap <buffer> <silent> ]] :call <SID>Tlist_Window_Move_To_File(1)<CR>
-    nnoremap <buffer> <silent> <Tab> :call <SID>Tlist_Window_Move_To_File(1)<CR>
-    nnoremap <buffer> <silent> <F1> :call <SID>Tlist_Window_Toggle_Help_Text()<CR>
-    nnoremap <buffer> <silent> q :close<CR>
-
-    " Insert mode mappings
-    inoremap <buffer> <silent> <CR>
-                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
-    " Windows needs return
-    inoremap <buffer> <silent> <Return>
-                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
-    inoremap <buffer> <silent> o
-                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
-    inoremap <buffer> <silent> p
-                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
-    inoremap <buffer> <silent> P
-                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
-    if v:version >= 700
-    inoremap <buffer> <silent> t
-                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
-    inoremap <buffer> <silent> <C-t>
-                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
-    endif
-    inoremap <buffer> <silent> <2-LeftMouse>
-                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
-    inoremap <buffer> <silent> s
-                \ <C-o>:call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
-    inoremap <buffer> <silent> +             <C-o>:silent! foldopen<CR>
-    inoremap <buffer> <silent> -             <C-o>:silent! foldclose<CR>
-    inoremap <buffer> <silent> *             <C-o>:silent! %foldopen!<CR>
-    inoremap <buffer> <silent> =             <C-o>:silent! %foldclose<CR>
-    inoremap <buffer> <silent> <kPlus>       <C-o>:silent! foldopen<CR>
-    inoremap <buffer> <silent> <kMinus>      <C-o>:silent! foldclose<CR>
-    inoremap <buffer> <silent> <kMultiply>   <C-o>:silent! %foldopen!<CR>
-    inoremap <buffer> <silent> <Space>       <C-o>:call
-                                    \ <SID>Tlist_Window_Show_Info()<CR>
-    inoremap <buffer> <silent> u
-                            \ <C-o>:call <SID>Tlist_Window_Update_File()<CR>
-    inoremap <buffer> <silent> d    <C-o>:call <SID>Tlist_Remove_File(-1, 1)<CR>
-    inoremap <buffer> <silent> x    <C-o>:call <SID>Tlist_Window_Zoom()<CR>
-    inoremap <buffer> <silent> [[   <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
-    inoremap <buffer> <silent> <BS> <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
-    inoremap <buffer> <silent> ]]   <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
-    inoremap <buffer> <silent> <Tab> <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
-    inoremap <buffer> <silent> <F1>  <C-o>:call <SID>Tlist_Window_Toggle_Help_Text()<CR>
-    inoremap <buffer> <silent> q    <C-o>:close<CR>
-
-    " Map single left mouse click if the user wants this functionality
-    if g:Tlist_Use_SingleClick == 1
-        " Contributed by Bindu Wavell
-        " attempt to perform single click mapping, it would be much
-        " nicer if we could nnoremap <buffer> ... however vim does
-        " not fire the <buffer> <leftmouse> when you use the mouse
-        " to enter a buffer.
-        let clickmap = ':if bufname("%") =~ "__Tag_List__" <bar> ' .
-                    \ 'call <SID>Tlist_Window_Jump_To_Tag("useopen") ' .
-                    \ '<bar> endif <CR>'
-        if maparg('<leftmouse>', 'n') == ''
-            " no mapping for leftmouse
-            exe ':nnoremap <silent> <leftmouse> <leftmouse>' . clickmap
-        else
-            " we have a mapping
-            let mapcmd = ':nnoremap <silent> <leftmouse> <leftmouse>'
-            let mapcmd = mapcmd . substitute(substitute(
-                        \ maparg('<leftmouse>', 'n'), '|', '<bar>', 'g'),
-                        \ '\c^<leftmouse>', '', '')
-            let mapcmd = mapcmd . clickmap
-            exe mapcmd
-        endif
-    endif
-
-    " Define the taglist autocommands
-    augroup TagListAutoCmds
-        autocmd!
-        " Display the tag prototype for the tag under the cursor.
-        autocmd CursorHold __Tag_List__ call s:Tlist_Window_Show_Info()
-        " Highlight the current tag periodically
-        autocmd CursorHold * silent call s:Tlist_Window_Highlight_Tag(
-                            \ fnamemodify(bufname('%'), ':p'), line('.'), 1, 0)
-
-        " Adjust the Vim window width when taglist window is closed
-        autocmd BufUnload __Tag_List__ call s:Tlist_Post_Close_Cleanup()
-        " Close the fold for this buffer when leaving the buffer
-        if g:Tlist_File_Fold_Auto_Close
-            autocmd BufEnter * silent
-                \ call s:Tlist_Window_Open_File_Fold(expand('<abuf>'))
-        endif
-        " Exit Vim itself if only the taglist window is present (optional)
-        if g:Tlist_Exit_OnlyWindow
-	    autocmd BufEnter __Tag_List__ nested
-			\ call s:Tlist_Window_Exit_Only_Window()
-        endif
-        if s:tlist_app_name != "winmanager" &&
-                    \ !g:Tlist_Process_File_Always &&
-                    \ (!has('gui_running') || !g:Tlist_Show_Menu)
-            " Auto refresh the taglist window
-            autocmd BufEnter * call s:Tlist_Refresh()
-        endif
-
-        if !g:Tlist_Use_Horiz_Window
-            if v:version < 700
-                autocmd WinEnter * call s:Tlist_Window_Check_Width()
-            endif
-        endif
-        if v:version >= 700
-            "autocmd TabEnter * silent call s:Tlist_Refresh_Folds()
-        endif
-    augroup end
-
-    " Restore the previous cpoptions settings
-    let &cpoptions = old_cpoptions
-endfunction
-
-" Tlist_Window_Refresh
-" Display the tags for all the files in the taglist window
-function! s:Tlist_Window_Refresh()
-    call s:Tlist_Log_Msg('Tlist_Window_Refresh()')
-    " Set report option to a huge value to prevent informational messages
-    " while deleting the lines
-    let old_report = &report
-    set report=99999
-
-    " Mark the buffer as modifiable
-    setlocal modifiable
-
-    " Delete the contents of the buffer to the black-hole register
-    silent! %delete _
-
-    " As we have cleared the taglist window, mark all the files
-    " as not visible
-    let i = 0
-    while i < s:tlist_file_count
-        let s:tlist_{i}_visible = 0
-        let i = i + 1
-    endwhile
-
-    if g:Tlist_Compact_Format == 0
-        " Display help in non-compact mode
-        call s:Tlist_Window_Display_Help()
-    endif
-
-    " Mark the buffer as not modifiable
-    setlocal nomodifiable
-
-    " Restore the report option
-    let &report = old_report
-
-    " If the tags for only one file should be displayed in the taglist
-    " window, then no need to add the tags here. The bufenter autocommand
-    " will add the tags for that file.
-    if g:Tlist_Show_One_File
-        return
-    endif
-
-    " List all the tags for the previously processed files
-    " Do this only if taglist is configured to display tags for more than
-    " one file. Otherwise, when Tlist_Show_One_File is configured,
-    " tags for the wrong file will be displayed.
-    let i = 0
-    while i < s:tlist_file_count
-        call s:Tlist_Window_Refresh_File(s:tlist_{i}_filename,
-                    \ s:tlist_{i}_filetype)
-        let i = i + 1
-    endwhile
-
-    if g:Tlist_Auto_Update
-        " Add and list the tags for all buffers in the Vim buffer list
-        let i = 1
-        let last_bufnum = bufnr('$')
-        while i <= last_bufnum
-            if buflisted(i)
-                let fname = fnamemodify(bufname(i), ':p')
-                let ftype = s:Tlist_Get_Buffer_Filetype(i)
-                " If the file doesn't support tag listing, skip it
-                if !s:Tlist_Skip_File(fname, ftype)
-                    call s:Tlist_Window_Refresh_File(fname, ftype)
-                endif
-            endif
-            let i = i + 1
-        endwhile
-    endif
-
-    " If Tlist_File_Fold_Auto_Close option is set, then close all the folds
-    if g:Tlist_File_Fold_Auto_Close
-        " Close all the folds
-        silent! %foldclose
-    endif
-
-    " Move the cursor to the top of the taglist window
-    normal! gg
-endfunction
-
-" Tlist_Post_Close_Cleanup()
-" Close the taglist window and adjust the Vim window width
-function! s:Tlist_Post_Close_Cleanup()
-    call s:Tlist_Log_Msg('Tlist_Post_Close_Cleanup()')
-    " Mark all the files as not visible
-    let i = 0
-    while i < s:tlist_file_count
-        let s:tlist_{i}_visible = 0
-        let i = i + 1
-    endwhile
-
-    " Remove the taglist autocommands
-    silent! autocmd! TagListAutoCmds
-
-    " Clear all the highlights
-    match none
-
-    silent! syntax clear TagListTitle
-    silent! syntax clear TagListComment
-    silent! syntax clear TagListTagScope
-
-    " Remove the left mouse click mapping if it was setup initially
-    if g:Tlist_Use_SingleClick
-        if hasmapto('<LeftMouse>')
-            nunmap <LeftMouse>
-        endif
-    endif
-
-    if s:tlist_app_name != "winmanager"
-    if g:Tlist_Use_Horiz_Window || g:Tlist_Inc_Winwidth == 0 ||
-                \ s:tlist_winsize_chgd != 1 ||
-                \ &columns < (80 + g:Tlist_WinWidth)
-        " No need to adjust window width if using horizontally split taglist
-        " window or if columns is less than 101 or if the user chose not to
-        " adjust the window width
-    else
-        " If the user didn't manually move the window, then restore the window
-        " position to the pre-taglist position
-        if s:tlist_pre_winx != -1 && s:tlist_pre_winy != -1 &&
-                    \ getwinposx() == s:tlist_winx &&
-                    \ getwinposy() == s:tlist_winy
-            exe 'winpos ' . s:tlist_pre_winx . ' ' . s:tlist_pre_winy
-        endif
-
-        " Adjust the Vim window width
-        let &columns= &columns - (g:Tlist_WinWidth + 1)
-    endif
-    endif
-
-    let s:tlist_winsize_chgd = -1
-
-    " Reset taglist state variables
-    if s:tlist_app_name == "winmanager"
-        let s:tlist_app_name = "none"
-    endif
-    let s:tlist_window_initialized = 0
-endfunction
-
-" Tlist_Window_Refresh_File()
-" List the tags defined in the specified file in a Vim window
-function! s:Tlist_Window_Refresh_File(filename, ftype)
-    call s:Tlist_Log_Msg('Tlist_Window_Refresh_File (' . a:filename . ')')
-    " First check whether the file already exists
-    let fidx = s:Tlist_Get_File_Index(a:filename)
-    if fidx != -1
-        let file_listed = 1
-    else
-        let file_listed = 0
-    endif
-
-    if !file_listed
-        " Check whether this file is removed based on user request
-        " If it is, then don't display the tags for this file
-        if s:Tlist_User_Removed_File(a:filename)
-            return
-        endif
-    endif
-
-    if file_listed && s:tlist_{fidx}_visible
-        " Check whether the file tags are currently valid
-        if s:tlist_{fidx}_valid
-            " Goto the first line in the file
-            exe s:tlist_{fidx}_start
-
-            " If the line is inside a fold, open the fold
-            if foldclosed('.') != -1
-                exe "silent! " . s:tlist_{fidx}_start . "," .
-                            \ s:tlist_{fidx}_end . "foldopen!"
-            endif
-            return
-        endif
-
-        " Discard and remove the tags for this file from display
-        call s:Tlist_Discard_TagInfo(fidx)
-        call s:Tlist_Window_Remove_File_From_Display(fidx)
-    endif
-
-    " Process and generate a list of tags defined in the file
-    if !file_listed || !s:tlist_{fidx}_valid
-        let ret_fidx = s:Tlist_Process_File(a:filename, a:ftype)
-        if ret_fidx == -1
-            return
-        endif
-        let fidx = ret_fidx
-    endif
-
-    " Set report option to a huge value to prevent informational messages
-    " while adding lines to the taglist window
-    let old_report = &report
-    set report=99999
-
-    if g:Tlist_Show_One_File
-        " Remove the previous file
-        if s:tlist_cur_file_idx != -1
-            call s:Tlist_Window_Remove_File_From_Display(s:tlist_cur_file_idx)
-            let s:tlist_{s:tlist_cur_file_idx}_visible = 0
-            let s:tlist_{s:tlist_cur_file_idx}_start = 0
-            let s:tlist_{s:tlist_cur_file_idx}_end = 0
-        endif
-        let s:tlist_cur_file_idx = fidx
-    endif
-
-    " Mark the buffer as modifiable
-    setlocal modifiable
-
-    " Add new files to the end of the window. For existing files, add them at
-    " the same line where they were previously present. If the file is not
-    " visible, then add it at the end
-    if s:tlist_{fidx}_start == 0 || !s:tlist_{fidx}_visible
-        if g:Tlist_Compact_Format
-            let s:tlist_{fidx}_start = line('$')
-        else
-            let s:tlist_{fidx}_start = line('$') + 1
-        endif
-    endif
-
-    let s:tlist_{fidx}_visible = 1
-
-    " Goto the line where this file should be placed
-    if g:Tlist_Compact_Format
-        exe s:tlist_{fidx}_start
-    else
-        exe s:tlist_{fidx}_start - 1
-    endif
-
-    let txt = fnamemodify(s:tlist_{fidx}_filename, ':t') . ' (' .
-                \ fnamemodify(s:tlist_{fidx}_filename, ':p:h') . ')'
-    if g:Tlist_Compact_Format == 0
-        silent! put =txt
-    else
-        silent! put! =txt
-        " Move to the next line
-        exe line('.') + 1
-    endif
-    let file_start = s:tlist_{fidx}_start
-
-    " Add the tag names grouped by tag type to the buffer with a title
-    let i = 1
-    let ttype_cnt = s:tlist_{a:ftype}_count
-    while i <= ttype_cnt
-        let ttype = s:tlist_{a:ftype}_{i}_name
-        " Add the tag type only if there are tags for that type
-        let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
-        let ttype_txt = {fidx_ttype}
-        if ttype_txt != ''
-            let txt = '  ' . s:tlist_{a:ftype}_{i}_fullname
-            if g:Tlist_Compact_Format == 0
-                let ttype_start_lnum = line('.') + 1
-                silent! put =txt
-            else
-                let ttype_start_lnum = line('.')
-                silent! put! =txt
-            endif
-            silent! put =ttype_txt
-
-            let {fidx_ttype}_offset = ttype_start_lnum - file_start
-
-            " create a fold for this tag type
-            let fold_start = ttype_start_lnum
-            let fold_end = fold_start + {fidx_ttype}_count
-            exe fold_start . ',' . fold_end  . 'fold'
-
-            " Adjust the cursor position
-            if g:Tlist_Compact_Format == 0
-                exe ttype_start_lnum + {fidx_ttype}_count
-            else
-                exe ttype_start_lnum + {fidx_ttype}_count + 1
-            endif
-
-            if g:Tlist_Compact_Format == 0
-                " Separate the tag types by a empty line
-                silent! put =''
-            endif
-        endif
-        let i = i + 1
-    endwhile
-
-    if s:tlist_{fidx}_tag_count == 0
-        if g:Tlist_Compact_Format == 0
-            silent! put =''
-        endif
-    endif
-
-    let s:tlist_{fidx}_end = line('.') - 1
-
-    " Create a fold for the entire file
-    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
-    exe 'silent! ' . s:tlist_{fidx}_start . ',' .
-                \ s:tlist_{fidx}_end . 'foldopen!'
-
-    " Goto the starting line for this file,
-    exe s:tlist_{fidx}_start
-
-    if s:tlist_app_name == "winmanager"
-        " To handle a bug in the winmanager plugin, add a space at the
-        " last line
-        call setline('$', ' ')
-    endif
-
-    " Mark the buffer as not modifiable
-    setlocal nomodifiable
-
-    " Restore the report option
-    let &report = old_report
-
-    " Update the start and end line numbers for all the files following this
-    " file
-    let start = s:tlist_{fidx}_start
-    " include the empty line after the last line
-    if g:Tlist_Compact_Format
-        let end = s:tlist_{fidx}_end
-    else
-        let end = s:tlist_{fidx}_end + 1
-    endif
-    call s:Tlist_Window_Update_Line_Offsets(fidx + 1, 1, end - start + 1)
-
-    " Now that we have updated the taglist window, update the tags
-    " menu (if present)
-    if g:Tlist_Show_Menu
-        call s:Tlist_Menu_Update_File(1)
-    endif
-endfunction
-
-" Tlist_Init_File
-" Initialize the variables for a new file
-function! s:Tlist_Init_File(filename, ftype)
-    call s:Tlist_Log_Msg('Tlist_Init_File (' . a:filename . ')')
-    " Add new files at the end of the list
-    let fidx = s:tlist_file_count
-    let s:tlist_file_count = s:tlist_file_count + 1
-    " Add the new file name to the taglist list of file names
-    let s:tlist_file_names = s:tlist_file_names . a:filename . "\n"
-
-    " Initialize the file variables
-    let s:tlist_{fidx}_filename = a:filename
-    let s:tlist_{fidx}_sort_type = g:Tlist_Sort_Type
-    let s:tlist_{fidx}_filetype = a:ftype
-    let s:tlist_{fidx}_mtime = -1
-    let s:tlist_{fidx}_start = 0
-    let s:tlist_{fidx}_end = 0
-    let s:tlist_{fidx}_valid = 0
-    let s:tlist_{fidx}_visible = 0
-    let s:tlist_{fidx}_tag_count = 0
-    let s:tlist_{fidx}_menu_cmd = ''
-
-    " Initialize the tag type variables
-    let i = 1
-    while i <= s:tlist_{a:ftype}_count
-        let ttype = s:tlist_{a:ftype}_{i}_name
-        let s:tlist_{fidx}_{ttype} = ''
-        let s:tlist_{fidx}_{ttype}_offset = 0
-        let s:tlist_{fidx}_{ttype}_count = 0
-        let i = i + 1
-    endwhile
-
-    return fidx
-endfunction
-
-" Tlist_Get_Tag_Type_By_Tag
-" Return the tag type for the specified tag index
-function! s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
-    let ttype_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_type'
-
-    " Already parsed and have the tag name
-    if exists(ttype_var)
-        return {ttype_var}
-    endif
-
-    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
-    let {ttype_var} = s:Tlist_Extract_Tagtype(tag_line)
-
-    return {ttype_var}
-endfunction
-
-" Tlist_Get_Tag_Prototype
-function! s:Tlist_Get_Tag_Prototype(fidx, tidx)
-    let tproto_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_proto'
-
-    " Already parsed and have the tag prototype
-    if exists(tproto_var)
-        return {tproto_var}
-    endif
-
-    " Parse and extract the tag prototype
-    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
-    let start = stridx(tag_line, '/^') + 2
-    let end = stridx(tag_line, '/;"' . "\t")
-    if tag_line[end - 1] == '$'
-        let end = end -1
-    endif
-    let tag_proto = strpart(tag_line, start, end - start)
-    let {tproto_var} = substitute(tag_proto, '\s*', '', '')
-
-    return {tproto_var}
-endfunction
-
-" Tlist_Get_Tag_SearchPat
-function! s:Tlist_Get_Tag_SearchPat(fidx, tidx)
-    let tpat_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_searchpat'
-
-    " Already parsed and have the tag search pattern
-    if exists(tpat_var)
-        return {tpat_var}
-    endif
-
-    " Parse and extract the tag search pattern
-    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
-    let start = stridx(tag_line, '/^') + 2
-    let end = stridx(tag_line, '/;"' . "\t")
-    if tag_line[end - 1] == '$'
-        let end = end -1
-    endif
-    let {tpat_var} = '\V\^' . strpart(tag_line, start, end - start) .
-                        \ (tag_line[end] == '$' ? '\$' : '')
-
-    return {tpat_var}
-endfunction
-
-" Tlist_Get_Tag_Linenum
-" Return the tag line number, given the tag index
-function! s:Tlist_Get_Tag_Linenum(fidx, tidx)
-    let tline_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_linenum'
-
-    " Already parsed and have the tag line number
-    if exists(tline_var)
-        return {tline_var}
-    endif
-
-    " Parse and extract the tag line number
-    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
-    let start = strridx(tag_line, 'line:') + 5
-    let end = strridx(tag_line, "\t")
-    if end < start
-        let {tline_var} = strpart(tag_line, start) + 0
-    else
-        let {tline_var} = strpart(tag_line, start, end - start) + 0
-    endif
-
-    return {tline_var}
-endfunction
-
-" Tlist_Parse_Tagline
-" Parse a tag line from the ctags output. Separate the tag output based on the
-" tag type and store it in the tag type variable.
-" The format of each line in the ctags output is:
-"
-"     tag_name<TAB>file_name<TAB>ex_cmd;"<TAB>extension_fields
-"
-function! s:Tlist_Parse_Tagline(tag_line)
-    if a:tag_line == ''
-        " Skip empty lines
-        return
-    endif
-
-    " Extract the tag type
-    let ttype = s:Tlist_Extract_Tagtype(a:tag_line)
-
-    " Make sure the tag type is a valid and supported one
-    if ttype == '' || stridx(s:ctags_flags, ttype) == -1
-        " Line is not in proper tags format or Tag type is not supported
-        return
-    endif
-
-    " Update the total tag count
-    let s:tidx = s:tidx + 1
-
-    " The following variables are used to optimize this code.  Vim is slow in
-    " using curly brace names. To reduce the amount of processing needed, the
-    " curly brace variables are pre-processed here
-    let fidx_tidx = 's:tlist_' . s:fidx . '_' . s:tidx
-    let fidx_ttype = 's:tlist_' . s:fidx . '_' . ttype
-
-    " Update the count of this tag type
-    let ttype_idx = {fidx_ttype}_count + 1
-    let {fidx_ttype}_count = ttype_idx
-
-    " Store the ctags output for this tag
-    let {fidx_tidx}_tag = a:tag_line
-
-    " Store the tag index and the tag type index (back pointers)
-    let {fidx_ttype}_{ttype_idx} = s:tidx
-    let {fidx_tidx}_ttype_idx = ttype_idx
-
-    " Extract the tag name
-    let tag_name = strpart(a:tag_line, 0, stridx(a:tag_line, "\t"))
-
-    " Extract the tag scope/prototype
-    if g:Tlist_Display_Prototype
-        let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(s:fidx, s:tidx)
-    else
-        let ttxt = '    ' . tag_name
-
-        " Add the tag scope, if it is available and is configured. Tag
-        " scope is the last field after the 'line:<num>\t' field
-        if g:Tlist_Display_Tag_Scope
-            let tag_scope = s:Tlist_Extract_Tag_Scope(a:tag_line)
-            if tag_scope != ''
-                let ttxt = ttxt . ' [' . tag_scope . ']'
-            endif
-        endif
-    endif
-
-    " Add this tag to the tag type variable
-    let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
-
-    " Save the tag name
-    let {fidx_tidx}_tag_name = tag_name
-endfunction
-
-" Tlist_Process_File
-" Get the list of tags defined in the specified file and store them
-" in Vim variables. Returns the file index where the tags are stored.
-function! s:Tlist_Process_File(filename, ftype)
-    call s:Tlist_Log_Msg('Tlist_Process_File (' . a:filename . ', ' .
-                \ a:ftype . ')')
-    " Check whether this file is supported
-    if s:Tlist_Skip_File(a:filename, a:ftype)
-        return -1
-    endif
-
-    " If the tag types for this filetype are not yet created, then create
-    " them now
-    let var = 's:tlist_' . a:ftype . '_count'
-    if !exists(var)
-        if s:Tlist_FileType_Init(a:ftype) == 0
-            return -1
-        endif
-    endif
-
-    " If this file is already processed, then use the cached values
-    let fidx = s:Tlist_Get_File_Index(a:filename)
-    if fidx == -1
-        " First time, this file is loaded
-        let fidx = s:Tlist_Init_File(a:filename, a:ftype)
-    else
-        " File was previously processed. Discard the tag information
-        call s:Tlist_Discard_TagInfo(fidx)
-    endif
-
-    let s:tlist_{fidx}_valid = 1
-
-    " Exuberant ctags arguments to generate a tag list
-    let ctags_args = ' -f - --format=2 --excmd=pattern --fields=nks '
-
-    " Form the ctags argument depending on the sort type
-    if s:tlist_{fidx}_sort_type == 'name'
-        let ctags_args = ctags_args . '--sort=yes'
-    else
-        let ctags_args = ctags_args . '--sort=no'
-    endif
-
-    " Add the filetype specific arguments
-    let ctags_args = ctags_args . ' ' . s:tlist_{a:ftype}_ctags_args
-
-    " Ctags command to produce output with regexp for locating the tags
-    let ctags_cmd = g:Tlist_Ctags_Cmd . ctags_args
-    let ctags_cmd = ctags_cmd . ' "' . a:filename . '"'
-
-    if &shellxquote == '"'
-        " Double-quotes within double-quotes will not work in the
-        " command-line.If the 'shellxquote' option is set to double-quotes,
-        " then escape the double-quotes in the ctags command-line.
-        let ctags_cmd = escape(ctags_cmd, '"')
-    endif
-
-    " In Windows 95, if not using cygwin, disable the 'shellslash'
-    " option. Otherwise, this will cause problems when running the
-    " ctags command.
-    if has('win95') && !has('win32unix')
-        let old_shellslash = &shellslash
-        set noshellslash
-    endif
-
-    if has('win32') && !has('win32unix') && !has('win95')
-                \ && (&shell =~ 'cmd.exe')
-        " Windows does not correctly deal with commands that have more than 1
-        " set of double quotes.  It will strip them all resulting in:
-        " 'C:\Program' is not recognized as an internal or external command
-        " operable program or batch file.  To work around this, place the
-        " command inside a batch file and call the batch file.
-        " Do this only on Win2K, WinXP and above.
-        " Contributed by: David Fishburn.
-        let s:taglist_tempfile = fnamemodify(tempname(), ':h') .
-                    \ '\taglist.cmd'
-        exe 'redir! > ' . s:taglist_tempfile
-        silent echo ctags_cmd
-        redir END
-
-        call s:Tlist_Log_Msg('Cmd inside batch file: ' . ctags_cmd)
-        let ctags_cmd = '"' . s:taglist_tempfile . '"'
-    endif
-
-    call s:Tlist_Log_Msg('Cmd: ' . ctags_cmd)
-
-    " Run ctags and get the tag list
-    let cmd_output = system(ctags_cmd)
-
-    " Restore the value of the 'shellslash' option.
-    if has('win95') && !has('win32unix')
-        let &shellslash = old_shellslash
-    endif
-
-    if exists('s:taglist_tempfile')
-        " Delete the temporary cmd file created on MS-Windows
-        call delete(s:taglist_tempfile)
-    endif
-
-    " Handle errors
-    if v:shell_error
-        let msg = "Taglist: Failed to generate tags for " . a:filename
-        call s:Tlist_Warning_Msg(msg)
-        if cmd_output != ''
-            call s:Tlist_Warning_Msg(cmd_output)
-        endif
-        return fidx
-    endif
-
-    " Store the modification time for the file
-    let s:tlist_{fidx}_mtime = getftime(a:filename)
-
-    " No tags for current file
-    if cmd_output == ''
-        call s:Tlist_Log_Msg('No tags defined in ' . a:filename)
-        return fidx
-    endif
-
-    call s:Tlist_Log_Msg('Generated tags information for ' . a:filename)
-
-    if v:version > 601
-        " The following script local variables are used by the
-        " Tlist_Parse_Tagline() function.
-        let s:ctags_flags = s:tlist_{a:ftype}_ctags_flags
-        let s:fidx = fidx
-        let s:tidx = 0
-
-        " Process the ctags output one line at a time.  The substitute()
-        " command is used to parse the tag lines instead of using the
-        " matchstr()/stridx()/strpart() functions for performance reason
-        call substitute(cmd_output, "\\([^\n]\\+\\)\n",
-                    \ '\=s:Tlist_Parse_Tagline(submatch(1))', 'g')
-
-        " Save the number of tags for this file
-        let s:tlist_{fidx}_tag_count = s:tidx
-
-        " The following script local variables are no longer needed
-        unlet! s:ctags_flags
-        unlet! s:tidx
-        unlet! s:fidx
-    else
-        " Due to a bug in Vim earlier than version 6.1,
-        " we cannot use substitute() to parse the ctags output.
-        " Instead the slow str*() functions are used
-        let ctags_flags = s:tlist_{a:ftype}_ctags_flags
-        let tidx = 0
-
-        while cmd_output != ''
-            " Extract one line at a time
-            let idx = stridx(cmd_output, "\n")
-            let one_line = strpart(cmd_output, 0, idx)
-            " Remove the line from the tags output
-            let cmd_output = strpart(cmd_output, idx + 1)
-
-            if one_line == ''
-                " Line is not in proper tags format
-                continue
-            endif
-
-            " Extract the tag type
-            let ttype = s:Tlist_Extract_Tagtype(one_line)
-
-            " Make sure the tag type is a valid and supported one
-            if ttype == '' || stridx(ctags_flags, ttype) == -1
-                " Line is not in proper tags format or Tag type is not
-                " supported
-                continue
-            endif
-
-            " Update the total tag count
-            let tidx = tidx + 1
-
-            " The following variables are used to optimize this code.  Vim is
-            " slow in using curly brace names. To reduce the amount of
-            " processing needed, the curly brace variables are pre-processed
-            " here
-            let fidx_tidx = 's:tlist_' . fidx . '_' . tidx
-            let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
-
-            " Update the count of this tag type
-            let ttype_idx = {fidx_ttype}_count + 1
-            let {fidx_ttype}_count = ttype_idx
-
-            " Store the ctags output for this tag
-            let {fidx_tidx}_tag = one_line
-
-            " Store the tag index and the tag type index (back pointers)
-            let {fidx_ttype}_{ttype_idx} = tidx
-            let {fidx_tidx}_ttype_idx = ttype_idx
-
-            " Extract the tag name
-            let tag_name = strpart(one_line, 0, stridx(one_line, "\t"))
-
-            " Extract the tag scope/prototype
-            if g:Tlist_Display_Prototype
-                let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(fidx, tidx)
-            else
-                let ttxt = '    ' . tag_name
-
-                " Add the tag scope, if it is available and is configured. Tag
-                " scope is the last field after the 'line:<num>\t' field
-                if g:Tlist_Display_Tag_Scope
-                    let tag_scope = s:Tlist_Extract_Tag_Scope(one_line)
-                    if tag_scope != ''
-                        let ttxt = ttxt . ' [' . tag_scope . ']'
-                    endif
-                endif
-            endif
-
-            " Add this tag to the tag type variable
-            let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
-
-            " Save the tag name
-            let {fidx_tidx}_tag_name = tag_name
-        endwhile
-
-        " Save the number of tags for this file
-        let s:tlist_{fidx}_tag_count = tidx
-    endif
-
-    call s:Tlist_Log_Msg('Processed ' . s:tlist_{fidx}_tag_count . 
-                \ ' tags in ' . a:filename)
-
-    return fidx
-endfunction
-
-" Tlist_Update_File
-" Update the tags for a file (if needed)
-function! Tlist_Update_File(filename, ftype)
-    call s:Tlist_Log_Msg('Tlist_Update_File (' . a:filename . ')')
-    " If the file doesn't support tag listing, skip it
-    if s:Tlist_Skip_File(a:filename, a:ftype)
-        return
-    endif
-
-    " Convert the file name to a full path
-    let fname = fnamemodify(a:filename, ':p')
-
-    " First check whether the file already exists
-    let fidx = s:Tlist_Get_File_Index(fname)
-
-    if fidx != -1 && s:tlist_{fidx}_valid
-        " File exists and the tags are valid
-        " Check whether the file was modified after the last tags update
-        " If it is modified, then update the tags
-        if s:tlist_{fidx}_mtime == getftime(fname)
-            return
-        endif
-    else
-        " If the tags were removed previously based on a user request,
-        " as we are going to update the tags (based on the user request),
-        " remove the filename from the deleted list
-        call s:Tlist_Update_Remove_List(fname, 0)
-    endif
-
-    " If the taglist window is opened, update it
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum == -1
-        " Taglist window is not present. Just update the taglist
-        " and return
-        call s:Tlist_Process_File(fname, a:ftype)
-    else
-        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != -1
-            " If tags for only one file are displayed and we are not
-            " updating the tags for that file, then no need to
-            " refresh the taglist window. Otherwise, the taglist
-            " window should be updated.
-            if s:tlist_{s:tlist_cur_file_idx}_filename != fname
-                call s:Tlist_Process_File(fname, a:ftype)
-                return
-            endif
-        endif
-
-        " Save the current window number
-        let save_winnr = winnr()
-
-        " Goto the taglist window
-        call s:Tlist_Window_Goto_Window()
-
-        " Save the cursor position
-        let save_line = line('.')
-        let save_col = col('.')
-
-        " Update the taglist window
-        call s:Tlist_Window_Refresh_File(fname, a:ftype)
-
-        " Restore the cursor position
-        if v:version >= 601
-            call cursor(save_line, save_col)
-        else
-            exe save_line
-            exe 'normal! ' . save_col . '|'
-        endif
-
-        if winnr() != save_winnr
-            " Go back to the original window
-            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
-        endif
-    endif
-
-    " Update the taglist menu
-    if g:Tlist_Show_Menu
-        call s:Tlist_Menu_Update_File(1)
-    endif
-endfunction
-
-" Tlist_Window_Close
-" Close the taglist window
-function! s:Tlist_Window_Close()
-    call s:Tlist_Log_Msg('Tlist_Window_Close()')
-    " Make sure the taglist window exists
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum == -1
-        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
-        return
-    endif
-
-    if winnr() == winnum
-        " Already in the taglist window. Close it and return
-        if winbufnr(2) != -1
-            " If a window other than the taglist window is open,
-            " then only close the taglist window.
-            close
-        endif
-    else
-        " Goto the taglist window, close it and then come back to the
-        " original window
-        let curbufnr = bufnr('%')
-        exe winnum . 'wincmd w'
-        close
-        " Need to jump back to the original window only if we are not
-        " already in that window
-        let winnum = bufwinnr(curbufnr)
-        if winnr() != winnum
-            exe winnum . 'wincmd w'
-        endif
-    endif
-endfunction
-
-" Tlist_Window_Mark_File_Window
-" Mark the current window as the file window to use when jumping to a tag.
-" Only if the current window is a non-plugin, non-preview and non-taglist
-" window
-function! s:Tlist_Window_Mark_File_Window()
-    if getbufvar('%', '&buftype') == '' && !&previewwindow
-        let w:tlist_file_window = "yes"
-    endif
-endfunction
-
-" Tlist_Window_Open
-" Open and refresh the taglist window
-function! s:Tlist_Window_Open()
-    call s:Tlist_Log_Msg('Tlist_Window_Open()')
-    " If the window is open, jump to it
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum != -1
-        " Jump to the existing window
-        if winnr() != winnum
-            exe winnum . 'wincmd w'
-        endif
-        return
-    endif
-
-    if s:tlist_app_name == "winmanager"
-        " Taglist plugin is no longer part of the winmanager app
-        let s:tlist_app_name = "none"
-    endif
-
-    " Get the filename and filetype for the specified buffer
-    let curbuf_name = fnamemodify(bufname('%'), ':p')
-    let curbuf_ftype = s:Tlist_Get_Buffer_Filetype('%')
-    let cur_lnum = line('.')
-
-    " Mark the current window as the desired window to open a file when a tag
-    " is selected.
-    call s:Tlist_Window_Mark_File_Window()
-
-    " Open the taglist window
-    call s:Tlist_Window_Create()
-
-    call s:Tlist_Window_Refresh()
-
-    if g:Tlist_Show_One_File
-        " Add only the current buffer and file
-        "
-        " If the file doesn't support tag listing, skip it
-        if !s:Tlist_Skip_File(curbuf_name, curbuf_ftype)
-            call s:Tlist_Window_Refresh_File(curbuf_name, curbuf_ftype)
-        endif
-    endif
-
-    if g:Tlist_File_Fold_Auto_Close
-        " Open the fold for the current file, as all the folds in
-        " the taglist window are closed
-        let fidx = s:Tlist_Get_File_Index(curbuf_name)
-        if fidx != -1
-            exe "silent! " . s:tlist_{fidx}_start . "," .
-                        \ s:tlist_{fidx}_end . "foldopen!"
-        endif
-    endif
-
-    " Highlight the current tag
-    call s:Tlist_Window_Highlight_Tag(curbuf_name, cur_lnum, 1, 1)
-endfunction
-
-" Tlist_Window_Toggle()
-" Open or close a taglist window
-function! s:Tlist_Window_Toggle()
-    call s:Tlist_Log_Msg('Tlist_Window_Toggle()')
-    " If taglist window is open then close it.
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum != -1
-        call s:Tlist_Window_Close()
-        return
-    endif
-
-    call s:Tlist_Window_Open()
-
-    " Go back to the original window, if Tlist_GainFocus_On_ToggleOpen is not
-    " set
-    if !g:Tlist_GainFocus_On_ToggleOpen
-        call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
-    endif
-
-    " Update the taglist menu
-    if g:Tlist_Show_Menu
-        call s:Tlist_Menu_Update_File(0)
-    endif
-endfunction
-
-" Tlist_Process_Filelist
-" Process multiple files. Each filename is separated by "\n"
-" Returns the number of processed files
-function! s:Tlist_Process_Filelist(file_names)
-    let flist = a:file_names
-
-    " Enable lazy screen updates
-    let old_lazyredraw = &lazyredraw
-    set lazyredraw
-
-    " Keep track of the number of processed files
-    let fcnt = 0
-
-    " Process one file at a time
-    while flist != ''
-        let nl_idx = stridx(flist, "\n")
-        let one_file = strpart(flist, 0, nl_idx)
-
-        " Remove the filename from the list
-        let flist = strpart(flist, nl_idx + 1)
-
-        if one_file == ''
-            continue
-        endif
-
-        " Skip directories
-        if isdirectory(one_file)
-            continue
-        endif
-
-        let ftype = s:Tlist_Detect_Filetype(one_file)
-
-        echon "\r                                                              "
-        echon "\rProcessing tags for " . fnamemodify(one_file, ':p:t')
-
-        let fcnt = fcnt + 1
-
-        call Tlist_Update_File(one_file, ftype)
-    endwhile
-
-    " Clear the displayed informational messages
-    echon "\r                                                            "
-
-    " Restore the previous state
-    let &lazyredraw = old_lazyredraw
-
-    return fcnt
-endfunction
-
-" Tlist_Process_Dir
-" Process the files in a directory matching the specified pattern
-function! s:Tlist_Process_Dir(dir_name, pat)
-    let flist = glob(a:dir_name . '/' . a:pat) . "\n"
-
-    let fcnt = s:Tlist_Process_Filelist(flist)
-
-    let len = strlen(a:dir_name)
-    if a:dir_name[len - 1] == '\' || a:dir_name[len - 1] == '/'
-        let glob_expr = a:dir_name . '*'
-    else
-        let glob_expr = a:dir_name . '/*'
-    endif
-    let all_files = glob(glob_expr) . "\n"
-
-    while all_files != ''
-        let nl_idx = stridx(all_files, "\n")
-        let one_file = strpart(all_files, 0, nl_idx)
-
-        let all_files = strpart(all_files, nl_idx + 1)
-        if one_file == ''
-            continue
-        endif
-
-        " Skip non-directory names
-        if !isdirectory(one_file)
-            continue
-        endif
-
-        echon "\r                                                              "
-        echon "\rProcessing files in directory " . fnamemodify(one_file, ':t')
-        let fcnt = fcnt + s:Tlist_Process_Dir(one_file, a:pat)
-    endwhile
-
-    return fcnt
-endfunction
-
-" Tlist_Add_Files_Recursive
-" Add files recursively from a directory
-function! s:Tlist_Add_Files_Recursive(dir, ...)
-    let dir_name = fnamemodify(a:dir, ':p')
-    if !isdirectory(dir_name)
-        call s:Tlist_Warning_Msg('Error: ' . dir_name . ' is not a directory')
-        return
-    endif
-
-    if a:0 == 1
-        " User specified file pattern
-        let pat = a:1
-    else
-        " Default file pattern
-        let pat = '*'
-    endif
-
-    echon "\r                                                              "
-    echon "\rProcessing files in directory " . fnamemodify(dir_name, ':t')
-    let fcnt = s:Tlist_Process_Dir(dir_name, pat)
-
-    echon "\rAdded " . fcnt . " files to the taglist"
-endfunction
-
-" Tlist_Add_Files
-" Add the specified list of files to the taglist
-function! s:Tlist_Add_Files(...)
-    let flist = ''
-    let i = 1
-
-    " Get all the files matching the file patterns supplied as argument
-    while i <= a:0
-        let flist = flist . glob(a:{i}) . "\n"
-        let i = i + 1
-    endwhile
-
-    if flist == ''
-        call s:Tlist_Warning_Msg('Error: No matching files are found')
-        return
-    endif
-
-    let fcnt = s:Tlist_Process_Filelist(flist)
-    echon "\rAdded " . fcnt . " files to the taglist"
-endfunction
-
-" Tlist_Extract_Tagtype
-" Extract the tag type from the tag text
-function! s:Tlist_Extract_Tagtype(tag_line)
-    " The tag type is after the tag prototype field. The prototype field
-    " ends with the /;"\t string. We add 4 at the end to skip the characters
-    " in this special string..
-    let start = strridx(a:tag_line, '/;"' . "\t") + 4
-    let end = strridx(a:tag_line, 'line:') - 1
-    let ttype = strpart(a:tag_line, start, end - start)
-
-    return ttype
-endfunction
-
-" Tlist_Extract_Tag_Scope
-" Extract the tag scope from the tag text
-function! s:Tlist_Extract_Tag_Scope(tag_line)
-    let start = strridx(a:tag_line, 'line:')
-    let end = strridx(a:tag_line, "\t")
-    if end <= start
-        return ''
-    endif
-
-    let tag_scope = strpart(a:tag_line, end + 1)
-    let tag_scope = strpart(tag_scope, stridx(tag_scope, ':') + 1)
-
-    return tag_scope
-endfunction
-
-" Tlist_Refresh()
-" Refresh the taglist
-function! s:Tlist_Refresh()
-    call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' .
-                \ s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
-    " If we are entering the buffer from one of the taglist functions, then
-    " no need to refresh the taglist window again.
-    if s:Tlist_Skip_Refresh
-        " We still need to update the taglist menu
-        if g:Tlist_Show_Menu
-            call s:Tlist_Menu_Update_File(0)
-        endif
-        return
-    endif
-
-    " If part of the winmanager plugin and not configured to process
-    " tags always and not configured to display the tags menu, then return
-    if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always
-                \ && !g:Tlist_Show_Menu
-        return
-    endif
-
-    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
-    if &buftype != ''
-        return
-    endif
-
-    let filename = fnamemodify(bufname('%'), ':p')
-    let ftype = s:Tlist_Get_Buffer_Filetype('%')
-
-    " If the file doesn't support tag listing, skip it
-    if s:Tlist_Skip_File(filename, ftype)
-        return
-    endif
-
-    let tlist_win = bufwinnr(g:TagList_title)
-
-    " If the taglist window is not opened and not configured to process
-    " tags always and not displaying the tags menu, then return
-    if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
-        return
-    endif
-
-    let fidx = s:Tlist_Get_File_Index(filename)
-    if fidx == -1
-        " Check whether this file is removed based on user request
-        " If it is, then don't display the tags for this file
-        if s:Tlist_User_Removed_File(filename)
-            return
-        endif
-
-        " If the taglist should not be auto updated, then return
-        if !g:Tlist_Auto_Update
-            return
-        endif
-    endif
-
-    let cur_lnum = line('.')
-
-    if fidx == -1
-        " Update the tags for the file
-        let fidx = s:Tlist_Process_File(filename, ftype)
-    else
-        let mtime = getftime(filename)
-        if s:tlist_{fidx}_mtime != mtime
-            " Invalidate the tags listed for this file
-            let s:tlist_{fidx}_valid = 0
-
-            " Update the taglist and the window
-            call Tlist_Update_File(filename, ftype)
-
-            " Store the new file modification time
-            let s:tlist_{fidx}_mtime = mtime
-        endif
-    endif
-
-    " Update the taglist window
-    if tlist_win != -1
-        " Disable screen updates
-        let old_lazyredraw = &lazyredraw
-        set nolazyredraw
-
-        " Save the current window number
-        let save_winnr = winnr()
-
-        " Goto the taglist window
-        call s:Tlist_Window_Goto_Window()
-
-        if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
-            " Save the cursor position
-            let save_line = line('.')
-            let save_col = col('.')
-        endif
-
-        " Update the taglist window
-        call s:Tlist_Window_Refresh_File(filename, ftype)
-
-        " Open the fold for the file
-        exe "silent! " . s:tlist_{fidx}_start . "," .
-                    \ s:tlist_{fidx}_end . "foldopen!"
-
-        if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
-            if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
-                " If displaying tags for only one file in the taglist
-                " window and about to display the tags for a new file,
-                " then center the current tag line for the new file
-                let center_tag_line = 1
-            else
-                let center_tag_line = 0
-            endif
-
-            " Highlight the current tag
-            call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
-        else
-            " Restore the cursor position
-            if v:version >= 601
-                call cursor(save_line, save_col)
-            else
-                exe save_line
-                exe 'normal! ' . save_col . '|'
-            endif
-        endif
-
-        " Jump back to the original window
-        if save_winnr != winnr()
-            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
-        endif
-
-        " Restore screen updates
-        let &lazyredraw = old_lazyredraw
-    endif
-
-    " Update the taglist menu
-    if g:Tlist_Show_Menu
-        call s:Tlist_Menu_Update_File(0)
-    endif
-endfunction
-
-" Tlist_Change_Sort()
-" Change the sort order of the tag listing
-" caller == 'cmd', command used in the taglist window
-" caller == 'menu', taglist menu
-" action == 'toggle', toggle sort from name to order and vice versa
-" action == 'set', set the sort order to sort_type
-function! s:Tlist_Change_Sort(caller, action, sort_type)
-    call s:Tlist_Log_Msg('Tlist_Change_Sort (caller = ' . a:caller .
-            \ ', action = ' . a:action . ', sort_type = ' . a:sort_type . ')')
-    if a:caller == 'cmd'
-        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
-        if fidx == -1
-            return
-        endif
-
-        " Remove the previous highlighting
-        match none
-    elseif a:caller == 'menu'
-        let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
-        if fidx == -1
-            return
-        endif
-    endif
-
-    if a:action == 'toggle'
-        let sort_type = s:tlist_{fidx}_sort_type
-
-        " Toggle the sort order from 'name' to 'order' and vice versa
-        if sort_type == 'name'
-            let s:tlist_{fidx}_sort_type = 'order'
-        else
-            let s:tlist_{fidx}_sort_type = 'name'
-        endif
-    else
-        let s:tlist_{fidx}_sort_type = a:sort_type
-    endif
-
-    " Invalidate the tags listed for this file
-    let s:tlist_{fidx}_valid = 0
-
-    if a:caller  == 'cmd'
-        " Save the current line for later restoration
-        let curline = '\V\^' . getline('.') . '\$'
-
-        call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
-                    \   s:tlist_{fidx}_filetype)
-
-        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
-
-        " Go back to the cursor line before the tag list is sorted
-        call search(curline, 'w')
-
-        call s:Tlist_Menu_Update_File(1)
-    else
-        call s:Tlist_Menu_Remove_File()
-
-        call s:Tlist_Refresh()
-    endif
-endfunction
-
-" Tlist_Update_Current_File()
-" Update taglist for the current buffer by regenerating the tag list
-" Contributed by WEN Guopeng.
-function! s:Tlist_Update_Current_File()
-    call s:Tlist_Log_Msg('Tlist_Update_Current_File()')
-    if winnr() == bufwinnr(g:TagList_title)
-        " In the taglist window. Update the current file
-        call s:Tlist_Window_Update_File()
-    else
-        " Not in the taglist window. Update the current buffer
-        let filename = fnamemodify(bufname('%'), ':p')
-        let fidx = s:Tlist_Get_File_Index(filename)
-        if fidx != -1
-            let s:tlist_{fidx}_valid = 0
-        endif
-        let ft = s:Tlist_Get_Buffer_Filetype('%')
-        call Tlist_Update_File(filename, ft)
-    endif
-endfunction
-
-" Tlist_Window_Update_File()
-" Update the tags displayed in the taglist window
-function! s:Tlist_Window_Update_File()
-    call s:Tlist_Log_Msg('Tlist_Window_Update_File()')
-    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
-    if fidx == -1
-        return
-    endif
-
-    " Remove the previous highlighting
-    match none
-
-    " Save the current line for later restoration
-    let curline = '\V\^' . getline('.') . '\$'
-
-    let s:tlist_{fidx}_valid = 0
-
-    " Update the taglist window
-    call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
-                \ s:tlist_{fidx}_filetype)
-
-    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
-
-    " Go back to the tag line before the list is updated
-    call search(curline, 'w')
-endfunction
-
-" Tlist_Window_Get_Tag_Type_By_Linenum()
-" Return the tag type index for the specified line in the taglist window
-function! s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
-    let ftype = s:tlist_{a:fidx}_filetype
-
-    " Determine to which tag type the current line number belongs to using the
-    " tag type start line number and the number of tags in a tag type
-    let i = 1
-    while i <= s:tlist_{ftype}_count
-        let ttype = s:tlist_{ftype}_{i}_name
-        let start_lnum =
-                    \ s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
-        let end =  start_lnum + s:tlist_{a:fidx}_{ttype}_count
-        if a:lnum >= start_lnum && a:lnum <= end
-            break
-        endif
-        let i = i + 1
-    endwhile
-
-    " Current line doesn't belong to any of the displayed tag types
-    if i > s:tlist_{ftype}_count
-        return ''
-    endif
-
-    return ttype
-endfunction
-
-" Tlist_Window_Get_Tag_Index()
-" Return the tag index for the specified line in the taglist window
-function! s:Tlist_Window_Get_Tag_Index(fidx, lnum)
-    let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(a:fidx, a:lnum)
-
-    " Current line doesn't belong to any of the displayed tag types
-    if ttype == ''
-        return 0
-    endif
-
-    " Compute the index into the displayed tags for the tag type
-    let ttype_lnum = s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
-    let tidx = a:lnum - ttype_lnum
-    if tidx == 0
-        return 0
-    endif
-
-    " Get the corresponding tag line and return it
-    return s:tlist_{a:fidx}_{ttype}_{tidx}
-endfunction
-
-" Tlist_Window_Highlight_Line
-" Highlight the current line
-function! s:Tlist_Window_Highlight_Line()
-    " Clear previously selected name
-    match none
-
-    " Highlight the current line
-    if g:Tlist_Display_Prototype == 0
-        let pat = '/\%' . line('.') . 'l\s\+\zs.*/'
-    else
-        let pat = '/\%' . line('.') . 'l.*/'
-    endif
-
-    exe 'match TagListTagName ' . pat
-endfunction
-
-" Tlist_Window_Open_File
-" Open the specified file in either a new window or an existing window
-" and place the cursor at the specified tag pattern
-function! s:Tlist_Window_Open_File(win_ctrl, filename, tagpat)
-    call s:Tlist_Log_Msg('Tlist_Window_Open_File (' . a:filename . ',' .
-                \ a:win_ctrl . ')')
-    let prev_Tlist_Skip_Refresh = s:Tlist_Skip_Refresh
-    let s:Tlist_Skip_Refresh = 1
-
-    if s:tlist_app_name == "winmanager"
-        " Let the winmanager edit the file
-        call WinManagerFileEdit(a:filename, a:win_ctrl == 'newwin')
-    else
-
-    if a:win_ctrl == 'newtab'
-        " Create a new tab
-        exe 'tabnew ' . escape(a:filename, ' ')
-        " Open the taglist window in the new tab
-        call s:Tlist_Window_Open()
-    endif
-
-    if a:win_ctrl == 'checktab'
-        " Check whether the file is present in any of the tabs.
-        " If the file is present in the current tab, then use the
-        " current tab.
-        if bufwinnr(a:filename) != -1
-            let file_present_in_tab = 1
-            let i = tabpagenr()
-        else
-            let i = 1
-            let bnum = bufnr(a:filename)
-            let file_present_in_tab = 0
-            while i <= tabpagenr('$')
-                if index(tabpagebuflist(i), bnum) != -1
-                    let file_present_in_tab = 1
-                    break
-                endif
-                let i += 1
-            endwhile
-        endif
-
-        if file_present_in_tab
-            " Goto the tab containing the file
-            exe 'tabnext ' . i
-        else
-            " Open a new tab
-            exe 'tabnew ' . escape(a:filename, ' ')
-
-            " Open the taglist window
-            call s:Tlist_Window_Open()
-        endif
-    endif
-
-    let winnum = -1
-    if a:win_ctrl == 'prevwin'
-        " Open the file in the previous window, if it is usable
-        let cur_win = winnr()
-        wincmd p
-        if &buftype == '' && !&previewwindow
-            exe "edit " . escape(a:filename, ' ')
-            let winnum = winnr()
-        else
-            " Previous window is not usable
-            exe cur_win . 'wincmd w'
-        endif
-    endif
-
-    " Goto the window containing the file.  If the window is not there, open a
-    " new window
-    if winnum == -1
-        let winnum = bufwinnr(a:filename)
-    endif
-
-    if winnum == -1
-        " Locate the previously used window for opening a file
-        let fwin_num = 0
-        let first_usable_win = 0
-
-        let i = 1
-        let bnum = winbufnr(i)
-        while bnum != -1
-            if getwinvar(i, 'tlist_file_window') == 'yes'
-                let fwin_num = i
-                break
-            endif
-            if first_usable_win == 0 &&
-                        \ getbufvar(bnum, '&buftype') == '' &&
-                        \ !getwinvar(i, '&previewwindow')
-                " First non-taglist, non-plugin and non-preview window
-                let first_usable_win = i
-            endif
-            let i = i + 1
-            let bnum = winbufnr(i)
-        endwhile
-
-        " If a previously used window is not found, then use the first
-        " non-taglist window
-        if fwin_num == 0
-            let fwin_num = first_usable_win
-        endif
-
-        if fwin_num != 0
-            " Jump to the file window
-            exe fwin_num . "wincmd w"
-
-            " If the user asked to jump to the tag in a new window, then split
-            " the existing window into two.
-            if a:win_ctrl == 'newwin'
-                split
-            endif
-            exe "edit " . escape(a:filename, ' ')
-        else
-            " Open a new window
-            if g:Tlist_Use_Horiz_Window
-                exe 'leftabove split ' . escape(a:filename, ' ')
-            else
-                if winbufnr(2) == -1
-                    " Only the taglist window is present
-                    if g:Tlist_Use_Right_Window
-                        exe 'leftabove vertical split ' .
-                                    \ escape(a:filename, ' ')
-                    else
-                        exe 'rightbelow vertical split ' .
-                                    \ escape(a:filename, ' ')
-                    endif
-
-                    " Go to the taglist window to change the window size to
-                    " the user configured value
-                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
-                    if g:Tlist_Use_Horiz_Window
-                        exe 'resize ' . g:Tlist_WinHeight
-                    else
-                        exe 'vertical resize ' . g:Tlist_WinWidth
-                    endif
-                    " Go back to the file window
-                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
-                else
-                    " A plugin or help window is also present
-                    wincmd w
-                    exe 'leftabove split ' . escape(a:filename, ' ')
-                endif
-            endif
-        endif
-        " Mark the window, so that it can be reused.
-        call s:Tlist_Window_Mark_File_Window()
-    else
-        if v:version >= 700
-            " If the file is opened in more than one window, then check
-            " whether the last accessed window has the selected file.
-            " If it does, then use that window.
-            let lastwin_bufnum = winbufnr(winnr('#'))
-            if bufnr(a:filename) == lastwin_bufnum
-                let winnum = winnr('#')
-            endif
-        endif
-        exe winnum . 'wincmd w'
-
-        " If the user asked to jump to the tag in a new window, then split the
-        " existing window into two.
-        if a:win_ctrl == 'newwin'
-            split
-        endif
-    endif
-    endif
-
-    " Jump to the tag
-    if a:tagpat != ''
-        " Add the current cursor position to the jump list, so that user can
-        " jump back using the ' and ` marks.
-        mark '
-        silent call search(a:tagpat, 'w')
-
-        " Bring the line to the middle of the window
-        normal! z.
-
-        " If the line is inside a fold, open the fold
-        if foldclosed('.') != -1
-            .foldopen
-        endif
-    endif
-
-    " If the user selects to preview the tag then jump back to the
-    " taglist window
-    if a:win_ctrl == 'preview'
-        " Go back to the taglist window
-        let winnum = bufwinnr(g:TagList_title)
-        exe winnum . 'wincmd w'
-    else
-        " If the user has selected to close the taglist window, when a
-        " tag is selected, close the taglist  window
-        if g:Tlist_Close_On_Select
-            call s:Tlist_Window_Goto_Window()
-            close
-
-            " Go back to the window displaying the selected file
-            let wnum = bufwinnr(a:filename)
-            if wnum != -1 && wnum != winnr()
-                call s:Tlist_Exe_Cmd_No_Acmds(wnum . 'wincmd w')
-            endif
-        endif
-    endif
-
-    let s:Tlist_Skip_Refresh = prev_Tlist_Skip_Refresh
-endfunction
-
-" Tlist_Window_Jump_To_Tag()
-" Jump to the location of the current tag
-" win_ctrl == useopen - Reuse the existing file window
-" win_ctrl == newwin - Open a new window
-" win_ctrl == preview - Preview the tag
-" win_ctrl == prevwin - Open in previous window
-" win_ctrl == newtab - Open in new tab
-function! s:Tlist_Window_Jump_To_Tag(win_ctrl)
-    call s:Tlist_Log_Msg('Tlist_Window_Jump_To_Tag(' . a:win_ctrl . ')')
-    " Do not process comment lines and empty lines
-    let curline = getline('.')
-    if curline =~ '^\s*$' || curline[0] == '"'
-        return
-    endif
-
-    " If inside a closed fold, then use the first line of the fold
-    " and jump to the file.
-    let lnum = foldclosed('.')
-    if lnum == -1
-        " Jump to the selected tag or file
-        let lnum = line('.')
-    else
-        " Open the closed fold
-        .foldopen!
-    endif
-
-    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
-    if fidx == -1
-        return
-    endif
-
-    " Get the tag output for the current tag
-    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
-    if tidx != 0
-        let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, tidx)
-
-        " Highlight the tagline
-        call s:Tlist_Window_Highlight_Line()
-    else
-        " Selected a line which is not a tag name. Just edit the file
-        let tagpat = ''
-    endif
-
-    call s:Tlist_Window_Open_File(a:win_ctrl, s:tlist_{fidx}_filename, tagpat)
-endfunction
-
-" Tlist_Window_Show_Info()
-" Display information about the entry under the cursor
-function! s:Tlist_Window_Show_Info()
-    call s:Tlist_Log_Msg('Tlist_Window_Show_Info()')
-
-    " Clear the previously displayed line
-    echo
-
-    " Do not process comment lines and empty lines
-    let curline = getline('.')
-    if curline =~ '^\s*$' || curline[0] == '"'
-        return
-    endif
-
-    " If inside a fold, then don't display the prototype
-    if foldclosed('.') != -1
-        return
-    endif
-
-    let lnum = line('.')
-
-    " Get the file index
-    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
-    if fidx == -1
-        return
-    endif
-
-    if lnum == s:tlist_{fidx}_start
-        " Cursor is on a file name
-        let fname = s:tlist_{fidx}_filename
-        if strlen(fname) > 50
-            let fname = fnamemodify(fname, ':t')
-        endif
-        echo fname . ', Filetype=' . s:tlist_{fidx}_filetype .
-                    \  ', Tag count=' . s:tlist_{fidx}_tag_count
-        return
-    endif
-
-    " Get the tag output line for the current tag
-    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
-    if tidx == 0
-        " Cursor is on a tag type
-        let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
-        if ttype == ''
-            return
-        endif
-
-        let ttype_name = ''
-
-        let ftype = s:tlist_{fidx}_filetype
-        let i = 1
-        while i <= s:tlist_{ftype}_count
-            if ttype == s:tlist_{ftype}_{i}_name
-                let ttype_name = s:tlist_{ftype}_{i}_fullname
-                break
-            endif
-            let i = i + 1
-        endwhile
-
-        echo 'Tag type=' . ttype_name .
-                    \ ', Tag count=' . s:tlist_{fidx}_{ttype}_count
-        return
-    endif
-
-    " Get the tag search pattern and display it
-    echo s:Tlist_Get_Tag_Prototype(fidx, tidx)
-endfunction
-
-" Tlist_Find_Nearest_Tag_Idx
-" Find the tag idx nearest to the supplied line number
-" Returns -1, if a tag couldn't be found for the specified line number
-function! s:Tlist_Find_Nearest_Tag_Idx(fidx, linenum)
-    let sort_type = s:tlist_{a:fidx}_sort_type
-
-    let left = 1
-    let right = s:tlist_{a:fidx}_tag_count
-
-    if sort_type == 'order'
-        " Tags sorted by order, use a binary search.
-        " The idea behind this function is taken from the ctags.vim script (by
-        " Alexey Marinichev) available at the Vim online website.
-
-        " If the current line is the less than the first tag, then no need to
-        " search
-        let first_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, 1)
-
-        if a:linenum < first_lnum
-            return -1
-        endif
-
-        while left < right
-            let middle = (right + left + 1) / 2
-            let middle_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, middle)
-
-            if middle_lnum == a:linenum
-                let left = middle
-                break
-            endif
-
-            if middle_lnum > a:linenum
-                let right = middle - 1
-            else
-                let left = middle
-            endif
-        endwhile
-    else
-        " Tags sorted by name, use a linear search. (contributed by Dave
-        " Eggum).
-        " Look for a tag with a line number less than or equal to the supplied
-        " line number. If multiple tags are found, then use the tag with the
-        " line number closest to the supplied line number. IOW, use the tag
-        " with the highest line number.
-        let closest_lnum = 0
-        let final_left = 0
-        while left <= right
-            let lnum = s:Tlist_Get_Tag_Linenum(a:fidx, left)
-
-            if lnum < a:linenum && lnum > closest_lnum
-                let closest_lnum = lnum
-                let final_left = left
-            elseif lnum == a:linenum
-                let closest_lnum = lnum
-                let final_left = left
-                break
-            else
-                let left = left + 1
-            endif
-        endwhile
-        if closest_lnum == 0
-            return -1
-        endif
-        if left >= right
-            let left = final_left
-        endif
-    endif
-
-    return left
-endfunction
-
-" Tlist_Window_Highlight_Tag()
-" Highlight the current tag
-" cntx == 1, Called by the taglist plugin itself
-" cntx == 2, Forced by the user through the TlistHighlightTag command
-" center = 1, move the tag line to the center of the taglist window
-function! s:Tlist_Window_Highlight_Tag(filename, cur_lnum, cntx, center)
-    " Highlight the current tag only if the user configured the
-    " taglist plugin to do so or if the user explictly invoked the
-    " command to highlight the current tag.
-    if !g:Tlist_Auto_Highlight_Tag && a:cntx == 1
-        return
-    endif
-
-    if a:filename == ''
-        return
-    endif
-
-    " Make sure the taglist window is present
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum == -1
-        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
-        return
-    endif
-
-    let fidx = s:Tlist_Get_File_Index(a:filename)
-    if fidx == -1
-        return
-    endif
-
-    " If the file is currently not displayed in the taglist window, then retrn
-    if !s:tlist_{fidx}_visible
-        return
-    endif
-
-    " If there are no tags for this file, then no need to proceed further
-    if s:tlist_{fidx}_tag_count == 0
-        return
-    endif
-
-    " Ignore all autocommands
-    let old_ei = &eventignore
-    set eventignore=all
-
-    " Save the original window number
-    let org_winnr = winnr()
-
-    if org_winnr == winnum
-        let in_taglist_window = 1
-    else
-        let in_taglist_window = 0
-    endif
-
-    " Go to the taglist window
-    if !in_taglist_window
-        exe winnum . 'wincmd w'
-    endif
-
-    " Clear previously selected name
-    match none
-
-    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, a:cur_lnum)
-    if tidx == -1
-        " Make sure the current tag line is visible in the taglist window.
-        " Calling the winline() function makes the line visible.  Don't know
-        " of a better way to achieve this.
-        let lnum = line('.')
-
-        if lnum < s:tlist_{fidx}_start || lnum > s:tlist_{fidx}_end
-            " Move the cursor to the beginning of the file
-            exe s:tlist_{fidx}_start
-        endif
-
-        if foldclosed('.') != -1
-            .foldopen
-        endif
-
-        call winline()
-
-        if !in_taglist_window
-            exe org_winnr . 'wincmd w'
-        endif
-
-        " Restore the autocommands
-        let &eventignore = old_ei
-        return
-    endif
-
-    " Extract the tag type
-    let ttype = s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
-
-    " Compute the line number
-    " Start of file + Start of tag type + offset
-    let lnum = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset +
-                \ s:tlist_{fidx}_{tidx}_ttype_idx
-
-    " Goto the line containing the tag
-    exe lnum
-
-    " Open the fold
-    if foldclosed('.') != -1
-        .foldopen
-    endif
-
-    if a:center
-        " Move the tag line to the center of the taglist window
-        normal! z.
-    else
-        " Make sure the current tag line is visible in the taglist window.
-        " Calling the winline() function makes the line visible.  Don't know
-        " of a better way to achieve this.
-        call winline()
-    endif
-
-    " Highlight the tag name
-    call s:Tlist_Window_Highlight_Line()
-
-    " Go back to the original window
-    if !in_taglist_window
-        exe org_winnr . 'wincmd w'
-    endif
-
-    " Restore the autocommands
-    let &eventignore = old_ei
-    return
-endfunction
-
-" Tlist_Get_Tag_Prototype_By_Line
-" Get the prototype for the tag on or before the specified line number in the
-" current buffer
-function! Tlist_Get_Tag_Prototype_By_Line(...)
-    if a:0 == 0
-        " Arguments are not supplied. Use the current buffer name
-        " and line number
-        let filename = bufname('%')
-        let linenr = line('.')
-    elseif a:0 == 2
-        " Filename and line number are specified
-        let filename = a:1
-        let linenr = a:2
-        if linenr !~ '\d\+'
-            " Invalid line number
-            return ""
-        endif
-    else
-        " Sufficient arguments are not supplied
-        let msg =  'Usage: Tlist_Get_Tag_Prototype_By_Line <filename> ' .
-                                \ '<line_number>'
-        call s:Tlist_Warning_Msg(msg)
-        return ""
-    endif
-
-    " Expand the file to a fully qualified name
-    let filename = fnamemodify(filename, ':p')
-    if filename == ''
-        return ""
-    endif
-
-    let fidx = s:Tlist_Get_File_Index(filename)
-    if fidx == -1
-        return ""
-    endif
-
-    " If there are no tags for this file, then no need to proceed further
-    if s:tlist_{fidx}_tag_count == 0
-        return ""
-    endif
-
-    " Get the tag text using the line number
-    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
-    if tidx == -1
-        return ""
-    endif
-
-    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
-endfunction
-
-" Tlist_Get_Tagname_By_Line
-" Get the tag name on or before the specified line number in the
-" current buffer
-function! Tlist_Get_Tagname_By_Line(...)
-    if a:0 == 0
-        " Arguments are not supplied. Use the current buffer name
-        " and line number
-        let filename = bufname('%')
-        let linenr = line('.')
-    elseif a:0 == 2
-        " Filename and line number are specified
-        let filename = a:1
-        let linenr = a:2
-        if linenr !~ '\d\+'
-            " Invalid line number
-            return ""
-        endif
-    else
-        " Sufficient arguments are not supplied
-        let msg =  'Usage: Tlist_Get_Tagname_By_Line <filename> <line_number>'
-        call s:Tlist_Warning_Msg(msg)
-        return ""
-    endif
-
-    " Make sure the current file has a name
-    let filename = fnamemodify(filename, ':p')
-    if filename == ''
-        return ""
-    endif
-
-    let fidx = s:Tlist_Get_File_Index(filename)
-    if fidx == -1
-        return ""
-    endif
-
-    " If there are no tags for this file, then no need to proceed further
-    if s:tlist_{fidx}_tag_count == 0
-        return ""
-    endif
-
-    " Get the tag name using the line number
-    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
-    if tidx == -1
-        return ""
-    endif
-
-    return s:tlist_{fidx}_{tidx}_tag_name
-endfunction
-
-" Tlist_Window_Move_To_File
-" Move the cursor to the beginning of the current file or the next file
-" or the previous file in the taglist window
-" dir == -1, move to start of current or previous function
-" dir == 1, move to start of next function
-function! s:Tlist_Window_Move_To_File(dir)
-    if foldlevel('.') == 0
-        " Cursor is on a non-folded line (it is not in any of the files)
-        " Move it to a folded line
-        if a:dir == -1
-            normal! zk
-        else
-            " While moving down to the start of the next fold,
-            " no need to do go to the start of the next file.
-            normal! zj
-            return
-        endif
-    endif
-
-    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
-    if fidx == -1
-        return
-    endif
-
-    let cur_lnum = line('.')
-
-    if a:dir == -1
-        if cur_lnum > s:tlist_{fidx}_start
-            " Move to the beginning of the current file
-            exe s:tlist_{fidx}_start
-            return
-        endif
-
-        if fidx != 0
-            " Move to the beginning of the previous file
-            let fidx = fidx - 1
-        else
-            " Cursor is at the first file, wrap around to the last file
-            let fidx = s:tlist_file_count - 1
-        endif
-
-        exe s:tlist_{fidx}_start
-        return
-    else
-        " Move to the beginning of the next file
-        let fidx = fidx + 1
-
-        if fidx >= s:tlist_file_count
-            " Cursor is at the last file, wrap around to the first file
-            let fidx = 0
-        endif
-
-        if s:tlist_{fidx}_start != 0
-            exe s:tlist_{fidx}_start
-        endif
-        return
-    endif
-endfunction
-
-" Tlist_Session_Load
-" Load a taglist session (information about all the displayed files
-" and the tags) from the specified file
-function! s:Tlist_Session_Load(...)
-    if a:0 == 0 || a:1 == ''
-        call s:Tlist_Warning_Msg('Usage: TlistSessionLoad <filename>')
-        return
-    endif
-
-    let sessionfile = a:1
-
-    if !filereadable(sessionfile)
-        let msg = 'Taglist: Error - Unable to open file ' . sessionfile
-        call s:Tlist_Warning_Msg(msg)
-        return
-    endif
-
-    " Mark the current window as the file window
-    call s:Tlist_Window_Mark_File_Window()
-
-    " Source the session file
-    exe 'source ' . sessionfile
-
-    let new_file_count = g:tlist_file_count
-    unlet! g:tlist_file_count
-
-    let i = 0
-    while i < new_file_count
-        let ftype = g:tlist_{i}_filetype
-        unlet! g:tlist_{i}_filetype
-
-        if !exists('s:tlist_' . ftype . '_count')
-            if s:Tlist_FileType_Init(ftype) == 0
-                let i = i + 1
-                continue
-            endif
-        endif
-
-        let fname = g:tlist_{i}_filename
-        unlet! g:tlist_{i}_filename
-
-        let fidx = s:Tlist_Get_File_Index(fname)
-        if fidx != -1
-            let s:tlist_{fidx}_visible = 0
-            let i = i + 1
-            continue
-        else
-            " As we are loading the tags from the session file, if this
-            " file was previously deleted by the user, now we need to
-            " add it back. So remove the file from the deleted list.
-            call s:Tlist_Update_Remove_List(fname, 0)
-        endif
-
-        let fidx = s:Tlist_Init_File(fname, ftype)
-
-        let s:tlist_{fidx}_filename = fname
-
-        let s:tlist_{fidx}_sort_type = g:tlist_{i}_sort_type
-        unlet! g:tlist_{i}_sort_type
-
-        let s:tlist_{fidx}_filetype = ftype
-        let s:tlist_{fidx}_mtime = getftime(fname)
-
-        let s:tlist_{fidx}_start = 0
-        let s:tlist_{fidx}_end = 0
-
-        let s:tlist_{fidx}_valid = 1
-
-        let s:tlist_{fidx}_tag_count = g:tlist_{i}_tag_count
-        unlet! g:tlist_{i}_tag_count
-
-        let j = 1
-        while j <= s:tlist_{fidx}_tag_count
-            let s:tlist_{fidx}_{j}_tag = g:tlist_{i}_{j}_tag
-            let s:tlist_{fidx}_{j}_tag_name = g:tlist_{i}_{j}_tag_name
-            let s:tlist_{fidx}_{j}_ttype_idx = g:tlist_{i}_{j}_ttype_idx
-            unlet! g:tlist_{i}_{j}_tag
-            unlet! g:tlist_{i}_{j}_tag_name
-            unlet! g:tlist_{i}_{j}_ttype_idx
-            let j = j + 1
-        endwhile
-
-        let j = 1
-        while j <= s:tlist_{ftype}_count
-            let ttype = s:tlist_{ftype}_{j}_name
-
-            if exists('g:tlist_' . i . '_' . ttype)
-                let s:tlist_{fidx}_{ttype} = g:tlist_{i}_{ttype}
-                unlet! g:tlist_{i}_{ttype}
-                let s:tlist_{fidx}_{ttype}_offset = 0
-                let s:tlist_{fidx}_{ttype}_count = g:tlist_{i}_{ttype}_count
-                unlet! g:tlist_{i}_{ttype}_count
-
-                let k = 1
-                while k <= s:tlist_{fidx}_{ttype}_count
-                    let s:tlist_{fidx}_{ttype}_{k} = g:tlist_{i}_{ttype}_{k}
-                    unlet! g:tlist_{i}_{ttype}_{k}
-                    let k = k + 1
-                endwhile
-            else
-                let s:tlist_{fidx}_{ttype} = ''
-                let s:tlist_{fidx}_{ttype}_offset = 0
-                let s:tlist_{fidx}_{ttype}_count = 0
-            endif
-
-            let j = j + 1
-        endwhile
-
-        let i = i + 1
-    endwhile
-
-    " If the taglist window is open, then update it
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum != -1
-        let save_winnr = winnr()
-
-        " Goto the taglist window
-        call s:Tlist_Window_Goto_Window()
-
-        " Refresh the taglist window
-        call s:Tlist_Window_Refresh()
-
-        " Go back to the original window
-        if save_winnr != winnr()
-            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
-        endif
-    endif
-endfunction
-
-" Tlist_Session_Save
-" Save a taglist session (information about all the displayed files
-" and the tags) into the specified file
-function! s:Tlist_Session_Save(...)
-    if a:0 == 0 || a:1 == ''
-        call s:Tlist_Warning_Msg('Usage: TlistSessionSave <filename>')
-        return
-    endif
-
-    let sessionfile = a:1
-
-    if s:tlist_file_count == 0
-        " There is nothing to save
-        call s:Tlist_Warning_Msg('Warning: Taglist is empty. Nothing to save.')
-        return
-    endif
-
-    if filereadable(sessionfile)
-        let ans = input('Do you want to overwrite ' . sessionfile . ' (Y/N)?')
-        if ans !=? 'y'
-            return
-        endif
-
-        echo "\n"
-    endif
-
-    let old_verbose = &verbose
-    set verbose&vim
-
-    exe 'redir! > ' . sessionfile
-
-    silent! echo '" Taglist session file. This file is auto-generated.'
-    silent! echo '" File information'
-    silent! echo 'let tlist_file_count = ' . s:tlist_file_count
-
-    let i = 0
-
-    while i < s:tlist_file_count
-        " Store information about the file
-        silent! echo 'let tlist_' . i . "_filename = '" .
-                                            \ s:tlist_{i}_filename . "'"
-        silent! echo 'let tlist_' . i . '_sort_type = "' .
-                                                \ s:tlist_{i}_sort_type . '"'
-        silent! echo 'let tlist_' . i . '_filetype = "' .
-                                            \ s:tlist_{i}_filetype . '"'
-        silent! echo 'let tlist_' . i . '_tag_count = ' .
-                                                        \ s:tlist_{i}_tag_count
-        " Store information about all the tags
-        let j = 1
-        while j <= s:tlist_{i}_tag_count
-            let txt = escape(s:tlist_{i}_{j}_tag, '"\\')
-            silent! echo 'let tlist_' . i . '_' . j . '_tag = "' . txt . '"'
-            silent! echo 'let tlist_' . i . '_' . j . '_tag_name = "' .
-                        \ s:tlist_{i}_{j}_tag_name . '"'
-            silent! echo 'let tlist_' . i . '_' . j . '_ttype_idx' . ' = ' .
-                        \ s:tlist_{i}_{j}_ttype_idx
-            let j = j + 1
-        endwhile
-
-        " Store information about all the tags grouped by their type
-        let ftype = s:tlist_{i}_filetype
-        let j = 1
-        while j <= s:tlist_{ftype}_count
-            let ttype = s:tlist_{ftype}_{j}_name
-            if s:tlist_{i}_{ttype}_count != 0
-                let txt = escape(s:tlist_{i}_{ttype}, '"\')
-                let txt = substitute(txt, "\n", "\\\\n", 'g')
-                silent! echo 'let tlist_' . i . '_' . ttype . ' = "' .
-                                                \ txt . '"'
-                silent! echo 'let tlist_' . i . '_' . ttype . '_count = ' .
-                                                     \ s:tlist_{i}_{ttype}_count
-                let k = 1
-                while k <= s:tlist_{i}_{ttype}_count
-                    silent! echo 'let tlist_' . i . '_' . ttype . '_' . k .
-                                \ ' = ' . s:tlist_{i}_{ttype}_{k}
-                    let k = k + 1
-                endwhile
-            endif
-            let j = j + 1
-        endwhile
-
-        silent! echo
-
-        let i = i + 1
-    endwhile
-
-    redir END
-
-    let &verbose = old_verbose
-endfunction
-
-" Tlist_Buffer_Removed
-" A buffer is removed from the Vim buffer list. Remove the tags defined
-" for that file
-function! s:Tlist_Buffer_Removed(filename)
-    call s:Tlist_Log_Msg('Tlist_Buffer_Removed (' . a:filename .  ')')
-
-    " Make sure a valid filename is supplied
-    if a:filename == ''
-        return
-    endif
-
-    " Get tag list index of the specified file
-    let fidx = s:Tlist_Get_File_Index(a:filename)
-    if fidx == -1
-        " File not present in the taglist
-        return
-    endif
-
-    " Remove the file from the list
-    call s:Tlist_Remove_File(fidx, 0)
-endfunction
-
-" When a buffer is deleted, remove the file from the taglist
-autocmd BufDelete * silent call s:Tlist_Buffer_Removed(expand('<afile>:p'))
-
-" Tlist_Window_Open_File_Fold
-" Open the fold for the specified file and close the fold for all the
-" other files
-function! s:Tlist_Window_Open_File_Fold(acmd_bufnr)
-    call s:Tlist_Log_Msg('Tlist_Window_Open_File_Fold (' . a:acmd_bufnr . ')')
-
-    " Make sure the taglist window is present
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum == -1
-        call s:Tlist_Warning_Msg('Taglist: Error - Taglist window is not open')
-        return
-    endif
-
-    " Save the original window number
-    let org_winnr = winnr()
-    if org_winnr == winnum
-        let in_taglist_window = 1
-    else
-        let in_taglist_window = 0
-    endif
-
-    if in_taglist_window
-        " When entering the taglist window, no need to update the folds
-        return
-    endif
-
-    " Go to the taglist window
-    if !in_taglist_window
-        call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
-    endif
-
-    " Close all the folds
-    silent! %foldclose
-
-    " Get tag list index of the specified file
-    let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
-    if filereadable(fname)
-        let fidx = s:Tlist_Get_File_Index(fname)
-        if fidx != -1
-            " Open the fold for the file
-            exe "silent! " . s:tlist_{fidx}_start . "," .
-                        \ s:tlist_{fidx}_end . "foldopen"
-        endif
-    endif
-
-    " Go back to the original window
-    if !in_taglist_window
-        call s:Tlist_Exe_Cmd_No_Acmds(org_winnr . 'wincmd w')
-    endif
-endfunction
-
-" Tlist_Window_Check_Auto_Open
-" Open the taglist window automatically on Vim startup.
-" Open the window only when files present in any of the Vim windows support
-" tags.
-function! s:Tlist_Window_Check_Auto_Open()
-    let open_window = 0
-
-    let i = 1
-    let buf_num = winbufnr(i)
-    while buf_num != -1
-        let filename = fnamemodify(bufname(buf_num), ':p')
-        let ft = s:Tlist_Get_Buffer_Filetype(buf_num)
-        if !s:Tlist_Skip_File(filename, ft)
-            let open_window = 1
-            break
-        endif
-        let i = i + 1
-        let buf_num = winbufnr(i)
-    endwhile
-
-    if open_window
-        call s:Tlist_Window_Toggle()
-    endif
-endfunction
-
-" Tlist_Refresh_Folds
-" Remove and create the folds for all the files displayed in the taglist
-" window. Used after entering a tab. If this is not done, then the folds
-" are not properly created for taglist windows displayed in multiple tabs.
-function! s:Tlist_Refresh_Folds()
-    let winnum = bufwinnr(g:TagList_title)
-    if winnum == -1
-        return
-    endif
-
-    let save_wnum = winnr()
-    exe winnum . 'wincmd w'
-
-    " First remove all the existing folds
-    normal! zE
-
-    " Create the folds for each in the tag list
-    let fidx = 0
-    while fidx < s:tlist_file_count
-        let ftype = s:tlist_{fidx}_filetype
-
-        " Create the folds for each tag type in a file
-        let j = 1
-        while j <= s:tlist_{ftype}_count
-            let ttype = s:tlist_{ftype}_{j}_name
-            if s:tlist_{fidx}_{ttype}_count
-                let s = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset
-                let e = s + s:tlist_{fidx}_{ttype}_count
-                exe s . ',' . e . 'fold'
-            endif
-            let j = j + 1
-        endwhile
-
-        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
-        exe 'silent! ' . s:tlist_{fidx}_start . ',' .
-                    \ s:tlist_{fidx}_end . 'foldopen!'
-        let fidx = fidx + 1
-    endwhile
-
-    exe save_wnum . 'wincmd w'
-endfunction
-
-function! s:Tlist_Menu_Add_Base_Menu()
-    call s:Tlist_Log_Msg('Adding the base menu')
-
-    " Add the menu
-    anoremenu <silent> T&ags.Refresh\ menu :call <SID>Tlist_Menu_Refresh()<CR>
-    anoremenu <silent> T&ags.Sort\ menu\ by.Name
-                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
-    anoremenu <silent> T&ags.Sort\ menu\ by.Order
-                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
-    anoremenu T&ags.-SEP1-           :
-
-    if &mousemodel =~ 'popup'
-        anoremenu <silent> PopUp.T&ags.Refresh\ menu
-                    \ :call <SID>Tlist_Menu_Refresh()<CR>
-        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Name
-                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
-        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Order
-                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
-        anoremenu PopUp.T&ags.-SEP1-           :
-    endif
-endfunction
-
-let s:menu_char_prefix =
-            \ '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
-
-" Tlist_Menu_Get_Tag_Type_Cmd
-" Get the menu command for the specified tag type
-" fidx - File type index
-" ftype - File Type
-" add_ttype_name - To add or not to add the tag type name to the menu entries
-" ttype_idx - Tag type index
-function! s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, ttype_idx)
-    " Curly brace variable name optimization
-    let ftype_ttype_idx = a:ftype . '_' . a:ttype_idx
-
-    let ttype = s:tlist_{ftype_ttype_idx}_name
-    if a:add_ttype_name
-        " If the tag type name contains space characters, escape it. This
-        " will be used to create the menu entries.
-        let ttype_fullname = escape(s:tlist_{ftype_ttype_idx}_fullname, ' ')
-    endif
-
-    " Curly brace variable name optimization
-    let fidx_ttype = a:fidx . '_' . ttype
-
-    " Number of tag entries for this tag type
-    let tcnt = s:tlist_{fidx_ttype}_count
-    if tcnt == 0 " No entries for this tag type
-        return ''
-    endif
-
-    let mcmd = ''
-
-    " Create the menu items for the tags.
-    " Depending on the number of tags of this type, split the menu into
-    " multiple sub-menus, if needed.
-    if tcnt > g:Tlist_Max_Submenu_Items
-        let j = 1
-        while j <= tcnt
-            let final_index = j + g:Tlist_Max_Submenu_Items - 1
-            if final_index > tcnt
-                let final_index = tcnt
-            endif
-
-            " Extract the first and last tag name and form the
-            " sub-menu name
-            let tidx = s:tlist_{fidx_ttype}_{j}
-            let first_tag = s:tlist_{a:fidx}_{tidx}_tag_name
-
-            let tidx = s:tlist_{fidx_ttype}_{final_index}
-            let last_tag = s:tlist_{a:fidx}_{tidx}_tag_name
-
-            " Truncate the names, if they are greater than the
-            " max length
-            let first_tag = strpart(first_tag, 0, g:Tlist_Max_Tag_Length)
-            let last_tag = strpart(last_tag, 0, g:Tlist_Max_Tag_Length)
-
-            " Form the menu command prefix
-            let m_prefix = 'anoremenu <silent> T\&ags.'
-            if a:add_ttype_name
-                let m_prefix = m_prefix . ttype_fullname . '.'
-            endif
-            let m_prefix = m_prefix . first_tag . '\.\.\.' . last_tag . '.'
-
-            " Character prefix used to number the menu items (hotkey)
-            let m_prefix_idx = 0
-
-            while j <= final_index
-                let tidx = s:tlist_{fidx_ttype}_{j}
-
-                let tname = s:tlist_{a:fidx}_{tidx}_tag_name
-
-                let mcmd = mcmd . m_prefix . '\&' .
-                            \ s:menu_char_prefix[m_prefix_idx] . '\.' .
-                            \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' .
-                            \ tidx . ')<CR>|'
-
-                let m_prefix_idx = m_prefix_idx + 1
-                let j = j + 1
-            endwhile
-        endwhile
-    else
-        " Character prefix used to number the menu items (hotkey)
-        let m_prefix_idx = 0
-
-        let m_prefix = 'anoremenu <silent> T\&ags.'
-        if a:add_ttype_name
-            let m_prefix = m_prefix . ttype_fullname . '.'
-        endif
-        let j = 1
-        while j <= tcnt
-            let tidx = s:tlist_{fidx_ttype}_{j}
-
-            let tname = s:tlist_{a:fidx}_{tidx}_tag_name
-
-            let mcmd = mcmd . m_prefix . '\&' .
-                        \ s:menu_char_prefix[m_prefix_idx] . '\.' .
-                        \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' . tidx
-                        \ . ')<CR>|'
-
-            let m_prefix_idx = m_prefix_idx + 1
-            let j = j + 1
-        endwhile
-    endif
-
-    return mcmd
-endfunction
-
-" Update the taglist menu with the tags for the specified file
-function! s:Tlist_Menu_File_Refresh(fidx)
-    call s:Tlist_Log_Msg('Refreshing the tag menu for ' . s:tlist_{a:fidx}_filename)
-    " The 'B' flag is needed in the 'cpoptions' option
-    let old_cpoptions = &cpoptions
-    set cpoptions&vim
-
-    exe s:tlist_{a:fidx}_menu_cmd
-
-    " Update the popup menu (if enabled)
-    if &mousemodel =~ 'popup'
-        let cmd = substitute(s:tlist_{a:fidx}_menu_cmd, ' T\\&ags\.',
-                                        \ ' PopUp.T\\\&ags.', "g")
-        exe cmd
-    endif
-
-    " The taglist menu is not empty now
-    let s:tlist_menu_empty = 0
-
-    " Restore the 'cpoptions' settings
-    let &cpoptions = old_cpoptions
-endfunction
-
-" Tlist_Menu_Update_File
-" Add the taglist menu
-function! s:Tlist_Menu_Update_File(clear_menu)
-    if !has('gui_running')
-        " Not running in GUI mode
-        return
-    endif
-
-    call s:Tlist_Log_Msg('Updating the tag menu, clear_menu = ' . a:clear_menu)
-
-    " Remove the tags menu
-    if a:clear_menu
-        call s:Tlist_Menu_Remove_File()
-
-    endif
-
-    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
-    if &buftype != ''
-        return
-    endif
-
-    let filename = fnamemodify(bufname('%'), ':p')
-    let ftype = s:Tlist_Get_Buffer_Filetype('%')
-
-    " If the file doesn't support tag listing, skip it
-    if s:Tlist_Skip_File(filename, ftype)
-        return
-    endif
-
-    let fidx = s:Tlist_Get_File_Index(filename)
-    if fidx == -1 || !s:tlist_{fidx}_valid
-        " Check whether this file is removed based on user request
-        " If it is, then don't display the tags for this file
-        if s:Tlist_User_Removed_File(filename)
-            return
-        endif
-
-        " Process the tags for the file
-        let fidx = s:Tlist_Process_File(filename, ftype)
-        if fidx == -1
-            return
-        endif
-    endif
-
-    let fname = escape(fnamemodify(bufname('%'), ':t'), '.')
-    if fname != ''
-        exe 'anoremenu T&ags.' .  fname . ' <Nop>'
-        anoremenu T&ags.-SEP2-           :
-    endif
-
-    if !s:tlist_{fidx}_tag_count
-        return
-    endif
-
-    if s:tlist_{fidx}_menu_cmd != ''
-        " Update the menu with the cached command
-        call s:Tlist_Menu_File_Refresh(fidx)
-
-        return
-    endif
-
-    " We are going to add entries to the tags menu, so the menu won't be
-    " empty
-    let s:tlist_menu_empty = 0
-
-    let cmd = ''
-
-    " Determine whether the tag type name needs to be added to the menu
-    " If more than one tag type is present in the taglisting for a file,
-    " then the tag type name needs to be present
-    let add_ttype_name = -1
-    let i = 1
-    while i <= s:tlist_{ftype}_count && add_ttype_name < 1
-        let ttype = s:tlist_{ftype}_{i}_name
-        if s:tlist_{fidx}_{ttype}_count
-            let add_ttype_name = add_ttype_name + 1
-        endif
-        let i = i + 1
-    endwhile
-
-    " Process the tags by the tag type and get the menu command
-    let i = 1
-    while i <= s:tlist_{ftype}_count
-        let mcmd = s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, i)
-        if mcmd != ''
-            let cmd = cmd . mcmd
-        endif
-
-        let i = i + 1
-    endwhile
-
-    " Cache the menu command for reuse
-    let s:tlist_{fidx}_menu_cmd = cmd
-
-    " Update the menu
-    call s:Tlist_Menu_File_Refresh(fidx)
-endfunction
-
-" Tlist_Menu_Remove_File
-" Remove the tags displayed in the tags menu
-function! s:Tlist_Menu_Remove_File()
-    if !has('gui_running') || s:tlist_menu_empty
-        return
-    endif
-
-    call s:Tlist_Log_Msg('Removing the tags menu for a file')
-
-    " Cleanup the Tags menu
-    silent! unmenu T&ags
-    if &mousemodel =~ 'popup'
-        silent! unmenu PopUp.T&ags
-    endif
-
-    " Add a dummy menu item to retain teared off menu
-    noremenu T&ags.Dummy l
-
-    silent! unmenu! T&ags
-    if &mousemodel =~ 'popup'
-        silent! unmenu! PopUp.T&ags
-    endif
-
-    call s:Tlist_Menu_Add_Base_Menu()
-
-    " Remove the dummy menu item
-    unmenu T&ags.Dummy
-
-    let s:tlist_menu_empty = 1
-endfunction
-
-" Tlist_Menu_Refresh
-" Refresh the taglist menu
-function! s:Tlist_Menu_Refresh()
-    call s:Tlist_Log_Msg('Refreshing the tags menu')
-    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
-    if fidx != -1
-        " Invalidate the cached menu command
-        let s:tlist_{fidx}_menu_cmd = ''
-    endif
-
-    " Update the taglist, menu and window
-    call s:Tlist_Update_Current_File()
-endfunction
-
-" Tlist_Menu_Jump_To_Tag
-" Jump to the selected tag
-function! s:Tlist_Menu_Jump_To_Tag(tidx)
-    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
-    if fidx == -1
-        return
-    endif
-
-    let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, a:tidx)
-    if tagpat == ''
-        return
-    endif
-
-    " Add the current cursor position to the jump list, so that user can
-    " jump back using the ' and ` marks.
-    mark '
-
-    silent call search(tagpat, 'w')
-
-    " Bring the line to the middle of the window
-    normal! z.
-
-    " If the line is inside a fold, open the fold
-    if foldclosed('.') != -1
-        .foldopen
-    endif
-endfunction
-
-" Tlist_Menu_Init
-" Initialize the taglist menu
-function! s:Tlist_Menu_Init()
-    call s:Tlist_Menu_Add_Base_Menu()
-
-    " Automatically add the tags defined in the current file to the menu
-    augroup TagListMenuCmds
-        autocmd!
-
-        if !g:Tlist_Process_File_Always
-            autocmd BufEnter * call s:Tlist_Refresh()
-        endif
-        autocmd BufLeave * call s:Tlist_Menu_Remove_File()
-    augroup end
-
-    call s:Tlist_Menu_Update_File(0)
-endfunction
-
-" Tlist_Vim_Session_Load
-" Initialize the taglist window/buffer, which is created when loading
-" a Vim session file.
-function! s:Tlist_Vim_Session_Load()
-    call s:Tlist_Log_Msg('Tlist_Vim_Session_Load')
-
-    " Initialize the taglist window
-    call s:Tlist_Window_Init()
-
-    " Refresh the taglist window
-    call s:Tlist_Window_Refresh()
-endfunction
-
-" Tlist_Set_App
-" Set the name of the external plugin/application to which taglist
-" belongs.
-" Taglist plugin is part of another plugin like cream or winmanager.
-function! Tlist_Set_App(name)
-    if a:name == ""
-        return
-    endif
-
-    let s:tlist_app_name = a:name
-endfunction
-
-" Winmanager integration
-
-" Initialization required for integration with winmanager
-function! TagList_Start()
-    " If current buffer is not taglist buffer, then don't proceed
-    if bufname('%') != '__Tag_List__'
-        return
-    endif
-
-    call Tlist_Set_App('winmanager')
-
-    " Get the current filename from the winmanager plugin
-    let bufnum = WinManagerGetLastEditedFile()
-    if bufnum != -1
-        let filename = fnamemodify(bufname(bufnum), ':p')
-        let ftype = s:Tlist_Get_Buffer_Filetype(bufnum)
-    endif
-
-    " Initialize the taglist window, if it is not already initialized
-    if !exists('s:tlist_window_initialized') || !s:tlist_window_initialized
-        call s:Tlist_Window_Init()
-        call s:Tlist_Window_Refresh()
-        let s:tlist_window_initialized = 1
-    endif
-
-    " Update the taglist window
-    if bufnum != -1
-        if !s:Tlist_Skip_File(filename, ftype) && g:Tlist_Auto_Update
-            call s:Tlist_Window_Refresh_File(filename, ftype)
-        endif
-    endif
-endfunction
-
-function! TagList_IsValid()
-    return 0
-endfunction
-
-function! TagList_WrapUp()
-    return 0
-endfunction
-
-" restore 'cpo'
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
Index: b/plugin/winfileexplorer.vim
deleted file mode 100644
===================================================================
--- a/plugin/winfileexplorer.vim
+++ /dev/null
@@ -1,1490 +0,0 @@
-"=============================================================================
-" File: explorer.vim
-" Author: M A Aziz Ahmed (aziz@acorn-networks.com)
-" Last Change: Sun Mar 31 11:00 PM 2002 PST
-" Version: 2.5
-" Additions by Mark Waggoner (waggoner@aracnet.com) et al.
-"-----------------------------------------------------------------------------
-" This file implements a file explorer. Latest version available at:
-" http://www.freespeech.org/aziz/vim/
-" Updated version available at:
-" http://www.aracnet.com/~waggoner
-"-----------------------------------------------------------------------------
-" Normally, this file will reside in the plugins directory and be
-" automatically sourced.  If not, you must manually source this file
-" using :source explorer.vim
-"
-" To use it, just edit a directory (vi dirname) or type :Explore to
-" launch the file explorer in the current window, or :Sexplore to split
-" the current window and launch explorer there.
-"
-" If the current buffer is modified, the window is always split.
-"
-" It is also possible to delete files and rename files within explorer.
-" See :help file-explorer for more details
-"
-"-----------------------------------------------------------------------------
-" Update history removed, it's not very interesting.
-" Contributors were: Doug Potts, Bram Moolenaar, Thomas Khler
-"
-" This is a modified version to be compatible with winmanager.vim. 
-" Changes by Srinath Avadhanula
-"=============================================================================
-
-" Has this already been loaded?
-if exists("loaded_winfileexplorer")
-  finish
-endif
-let loaded_winfileexplorer=1
-
-" Line continuation used here
-let s:cpo_save = &cpo
-set cpo&vim
-
-"---
-" Default settings for global configuration variables
-
-" Split vertically instead of horizontally?
-if !exists("g:explVertical")
-  let g:explVertical=0
-endif
-
-" How big to make the window? Set to "" to avoid resizing
-if !exists("g:explWinSize")
-  let g:explWinSize=15
-endif
-
-" When opening a new file/directory, split below current window (or
-" above)?  1 = below, 0 = to above
-if !exists("g:explSplitBelow")
-  let g:explSplitBelow = &splitbelow
-endif
-
-" Split to right of current window (or to left)?
-" 1 = to right, 0 = to left
-if !exists("g:explSplitRight")
-  let g:explSplitRight = &splitright
-endif
-
-" Start the first explorer window...
-" Defaults to be the same as explSplitBelow
-if !exists("g:explStartBelow")
-  let g:explStartBelow = g:explSplitBelow
-endif
-
-" Start the first explorer window...
-" Defaults to be the same as explSplitRight
-if !exists("g:explStartRight")
-  let g:explStartRight = g:explSplitRight
-endif
-
-" Show detailed help?
-if !exists("g:explDetailedHelp")
-  let g:explDetailedHelp=0
-endif
-
-" Show file size and dates?
-if !exists("g:explDetailedList")
-  let g:explDetailedList=0
-endif
-
-" Format for the date
-if !exists("g:explDateFormat")
-  let g:explDateFormat="%d %b %Y %H:%M"
-endif
-
-" Files to hide
-if !exists("g:explHideFiles")
-  let g:explHideFiles=''
-endif
-
-" Field to sort by
-if !exists("g:explSortBy")
-  let g:explSortBy='name'
-endif
-
-" Segregate directories? 1, 0, or -1
-if !exists("g:explDirsFirst")
-  let g:explDirsFirst=1
-endif
-
-" Segregate items in suffixes option? 1, 0, or -1
-if !exists("g:explSuffixesLast")
-  let g:explSuffixesLast=1
-endif
-
-" Include separator lines between directories, files, and suffixes?
-if !exists("g:explUseSeparators")
-  let g:explUseSeparators=0
-endif
-
-" whether or not to take over the functioning of the default file-explorer
-" plugin
-if !exists("g:defaultExplorer")
-	let g:defaultExplorer = 1
-end
-
-if !exists('g:favDirs')
-	if exists('$HOME')
-		let s:favDirs = expand('$HOME').'/'
-	end
-else
-	if exists('$HOME')
-		let s:favDirs = g:favDirs."\/\n".expand('$HOME')
-	end
-end
-let s:favDirs = substitute(s:favDirs, '\', '/', 'g')
-let s:favDirs = substitute(s:favDirs, '\/\/', '\/', 'g')
-
-" -- stuff used by winmanager
-let g:FileExplorer_title = "[File List]"
-function! FileExplorer_Start()
-	let b:displayMode = "winmanager"
-	if exists('s:lastDirectoryDisplayed')
-		call s:EditDir(s:lastDirectoryDisplayed)
-	else
-		call s:EditDir(expand("%:p:h"))
-	end
-	if exists('s:lastCursorRow')
-		exe s:lastCursorRow
-		exe 'normal! '.s:lastCursorColumn.'|'
-	end
-endfunction
-
-function! FileExplorer_IsValid()
-	return 1
-endfunction
-
-function! FileExplorer_WrapUp()
-	let s:lastCursorRow = line('.')
-	let s:lastCursorColumn = virtcol('.')
-	let s:lastDirectoryDisplayed = b:completePath
-endfunction
-" --- end winmanager specific stuff (for now)
-
-"---
-" script variables - these are the same across all
-" explorer windows
-
-" characters that must be escaped for a regular expression
-let s:escregexp = '/*^$.~\'
-
-" characters that must be escaped for filenames
-if has("dos16") || has("dos32") || has("win16") || has("win32") || has("os2")
-  let s:escfilename = ' %#'
-else
-  let s:escfilename = ' \%#'
-endif
-
-
-" A line to use for separating sections
-let s:separator='"---------------------------------------------------'
-
-"---
-" Create commands
-" commenting stuff for beta version release
-" if !exists(':Explore')
-"   command -n=? -complete=dir Explore :call s:StartExplorer(0, '<a>')
-" endif
-" if !exists(':Sexplore')
-"   command -n=? -complete=dir Sexplore :call s:StartExplorer(1, '<a>')
-" endif
-" 
-"---
-" Start the explorer using the preferences from the global variables
-"
-function! s:StartExplorer(split, start_dir)
-	let startcmd = "edit"
-	if a:start_dir != ""
-		let fname=a:start_dir
-	else
-		let fname = expand("%:p:h")
-	endif
-	if fname == ""
-		let fname = getcwd()
-	endif
-
-	" Create a variable to use if splitting vertically
-	let splitMode = ""
-	if g:explVertical == 1
-		let splitMode = "vertical"
-	endif
-
-	" Save the user's settings for splitbelow and splitright
-	let savesplitbelow = &splitbelow
-	let savesplitright = &splitright
-
-	if a:split || &modified
-		let startcmd = splitMode . " " . g:explWinSize . "new " . fname
-		let &splitbelow = g:explStartBelow
-		let &splitright = g:explStartRight
-	else
-		let startcmd = "edit " . fname
-	endif
-	silent execute startcmd
-	let &splitbelow = savesplitbelow
-	let &splitright = savesplitright
-endfunction
-
-
-"---
-" This is the main entry for 'editing' a directory
-"
-function! s:EditDir(...)
-	" depending on the number of arguments, this function has either been called
-	" by winmanager or by doing "e dirname" or :Explore
-	if a:0 == 0
-		" Get out of here right away if this isn't a directory!
-		let name = expand("%")
-		if name == ""
-			let name = expand("%:p")
-		endif
-	elseif a:0 >= 1
-		let name = a:1
-		set modifiable
-		1,$d_
-	end	
-	if a:0 >= 2 
-		let forceReDisplay = a:2
-	else
-		let forceReDisplay = 0
-	end
-
-	if !isdirectory(name)
-		return
-	endif
-
-	" Turn off the swapfile, set the buffer type so that it won't get
-	" written, and so that it will get deleted when it gets hidden.
-	setlocal modifiable
-	setlocal noswapfile
-	setlocal buftype=nowrite
-	setlocal bufhidden=delete
-	" Don't wrap around long lines
-	setlocal nowrap
-
-
-	" Get the complete path to the directory to look at with a slash at
-	" the end
-	let b:completePath = s:Path(name)
-	let s:lastDirectoryDisplayed = b:completePath
-
-	" Save the directory we are currently in and chdir to the directory
-	" we are editing so that we can get a real path to the directory,
-	" eliminating things like ".."
-	let origdir= s:Path(getcwd())
-	exe "chdir" escape(b:completePath,s:escfilename)
-	let b:completePath = s:Path(getcwd())
-	exe "chdir" escape(origdir,s:escfilename)
-
-	" Add a slash at the end
-	if b:completePath !~ '/$'
-		let b:completePath = b:completePath . '/'
-	endif
-
-	" escape special characters for exec commands
-	let b:completePathEsc=escape(b:completePath,s:escfilename)
-	let b:parentDirEsc=substitute(b:completePathEsc, '/[^/]*/$', '/', 'g')
-
-	" Set filter for hiding files
-	let b:filterFormula=substitute(g:explHideFiles, '\([^\\]\),', '\1\\|', 'g')
-	if b:filterFormula != ''
-		let b:filtering="\nNot showing: " . b:filterFormula
-	else
-		let b:filtering=""
-	endif
-
-
-	" added to allow directory caching
-	" s:numFileBuffers is an array containing the names of the directories
-	" visited.
-	if !exists("s:numFileBuffers")
-		let s:numFileBuffers = 0
-	end
-
-	let i = 1
-	while i <= s:numFileBuffers
-		exec 'let diri = s:dir_'.i
-		if diri == b:completePath
-			" if we are on a previously displayed directory which is being redrawn
-			" forcibly, then skip the stage of pasting from memory ... 
-			if !forceReDisplay
-				let oldRep=&report
-				let save_sc = &sc
-				set report=10000 nosc
-				1,$d _
-				exec 'put=s:FileList_'.i
-				0d
-				0
-				let b:maxFileLen = 0
-				/^"=/+1,$g/^/call s:MarkDirs()
-				call s:CleanUpHistory()
-				call s:PrintFavDirs()
-				0
-				/^"=/+1
-				call s:CleanUpHistory()
-				let &report=oldRep
-				let &sc = save_sc
-			end
-			" ... merely remember the variable number and break.
-			let s:currentFileNumberDisplayed = i
-			break
-		endif
-		let i = i+1	
-	endwhile
-
-	" No need for any insertmode abbreviations, since we don't allow
-	" insertions anyway!
-	iabc <buffer>
-
-	" Long or short listing?  Use the global variable the first time
-	" explorer is called, after that use the script variable as set by
-	" the interactive user.
-	if exists("s:longlist")
-		let w:longlist = s:longlist
-	else
-		let w:longlist = g:explDetailedList
-	endif
-
-	" Show keyboard shortcuts?
-	if exists("s:longhelp")
-		let w:longhelp = s:longhelp
-	else
-		let w:longhelp = g:explDetailedHelp
-	endif
-
-	" Set the sort based on the global variables the first time.  If you
-	" later change the sort order, it will be retained in the s:sortby
-	" variable for the next time you open explorer
-	let w:sortdirection=1
-	let w:sortdirlabel = ""
-	let w:sorttype = ""
-	if exists("s:sortby")
-		let sortby=s:sortby
-	else
-		let sortby=g:explSortBy
-	endif
-	if sortby =~ "reverse"
-		let w:sortdirection=-1
-		let w:sortdirlabel = "reverse "
-	endif
-	if sortby =~ "date"
-		let w:sorttype = "date"
-	elseif sortby =~ "size"
-		let w:sorttype = "size"
-	else
-		let w:sorttype = "name"
-	endif
-	call s:SetSuffixesLast()
-
-	" Set up syntax highlighting
-	" Something wrong with the evaluation of the conditional though...
-	if has("syntax") && exists("g:syntax_on") && !has("syntax_items")
-		syn match browseSynopsis    "^\"[ -].*"
-		syn match favoriteDirectory "^+ .*$"
-		syn match browseDirectory   "[^\"+].*/ "
-		syn match browseDirectory   "[^\"+].*/$"
-		syn match browseCurDir      "^\"= .*$"
-		syn match browseSortBy      "^\" Sorted by .*$"  contains=browseSuffixInfo
-		syn match browseSuffixInfo  "(.*)$"  contained
-		syn match browseFilter      "^\" Not Showing:.*$"
-		syn match browseFiletime    "\d\+$"
-		exec('syn match browseSuffixes    "' . b:suffixesHighlight . '"')
-
-		"hi def link browseSynopsis    PreProc
-		hi def link browseSynopsis    Special
-		hi def link browseDirectory   Directory
-		hi def link browseCurDir      Statement
-		hi def link favoriteDirectory Type
-		hi def link browseSortBy      String
-		hi def link browseSuffixInfo  Type
-		hi def link browseFilter      String
-		hi def link browseFiletime    Ignore
-		hi def link browseSuffixes    Type
-	endif
-	" Set up mappings for this buffer
-	let cpo_save = &cpo
-	set cpo&vim
-
-	if exists("b:displayMode") && b:displayMode == "winmanager"
-		" when called in winmanager mode, the argument movefirst assumes the role
-		" of whether or not to split a window.
-		nnoremap <buffer> <cr> :call <SID>EditEntry(0,"winmanager")<cr>
-		nnoremap <buffer> <tab> :call <SID>EditEntry(1,"winmanager")<cr>
-		nnoremap <buffer> -    :call <SID>EditDir(b:parentDirEsc)<cr>
-		nnoremap <buffer> <2-leftmouse> :call <SID>EditEntry(0,"winmanager")<cr>
-		nnoremap <buffer> C    :call <SID>EditDir(getcwd(),1)<cr>:call <SID>RestoreFileDisplay()<cr>
-		nnoremap <buffer> <F5> :call <SID>EditDir(b:completePath,1)<cr>:call <SID>RestoreFileDisplay()<cr>
-		nnoremap <buffer> <C-^> <Nop>
-		nnoremap <buffer> f :call <SID>AddToFavDir()<cr>
-	else
-		nnoremap <buffer> <cr> :call <SID>EditEntry("","edit")<cr>
-		nnoremap <buffer> -    :exec ("silent e "  . b:parentDirEsc)<cr>
-		nnoremap <buffer> o    :call <SID>OpenEntry()<cr>
-		nnoremap <buffer> O    :call <SID>OpenEntryPrevWindow()<cr>
-		nnoremap <buffer> <2-leftmouse> :call <SID>DoubleClick()<cr>
-	endif
-	nnoremap <buffer> p   :call <SID>EditEntry("","pedit")<cr>
-	nnoremap <buffer> a   :call <SID>ShowAllFiles()<cr>:call <SID>RestoreFileDisplay()<cr>
-	nnoremap <buffer> R   :call <SID>RenameFile()<cr>
-	nnoremap <buffer> D   :. call <SID>DeleteFile()<cr>:call <SID>RestoreFileDisplay()<cr>
-	vnoremap <buffer> D   :call <SID>DeleteFile()<cr>:call <SID>RestoreFileDisplay()<cr>
-	nnoremap <buffer> i   :call <SID>ToggleLongList()<cr>:call <SID>RestoreFileDisplay()<cr>
-	nnoremap <buffer> s   :call <SID>SortSelect()<cr>:call <SID>RestoreFileDisplay()<cr>
-	nnoremap <buffer> r   :call <SID>SortReverse()<cr>:call <SID>RestoreFileDisplay()<cr>
-	nnoremap <buffer> ?   :call <SID>ToggleHelp()<cr>
-	nnoremap <buffer> a   :call <SID>ShowAllFiles()<cr>:call <SID>RestoreFileDisplay()<cr>
-	nnoremap <buffer> R   :call <SID>RenameFile()<cr>
-	nnoremap <buffer> c   :exec "cd ".b:completePathEsc<cr>:pwd<cr>
-	let &cpo = cpo_save
-
-	" If directory is already loaded, don't open it again!
-	if line('$') > 1
-		setlocal nomodifiable
-		return
-	endif
-
-	" Show the files
-	call s:ShowDirectory()
-	call s:PrintFavDirs()
-
-	" prevent the buffer from being modified
-	setlocal nomodifiable
-
-	" remember the contents of this directory if its been displayed for the
-	" first time for fast redraw later. if we have reached here bcause of a
-	" forcible redraw, do not create a new s:dir_i variable.
-	if !forceReDisplay
-		let s:numFileBuffers = s:numFileBuffers + 1
-		let s:currentFileNumberDisplayed = s:numFileBuffers
-		exe 'let s:dir_'.s:currentFileNumberDisplayed.' = b:completePath'
-	end
-	0
-	/^"=/+1
-	call s:CleanUpHistory()
-	call s:RestoreFileDisplay()
-endfunction
-
-"---
-" If this is the only window, open file in a new window
-" Otherwise, open file in the most recently visited window
-"
-function! s:OpenEntryPrevWindow()
-	" Figure out if there are any other windows
-	let n = winnr()
-	wincmd p
-	" No other window?  Then open a new one
-	if n == winnr()
-		call s:OpenEntry()
-		" Other windows exist
-	else
-		" Check if the previous buffer is modified - ask if they want to
-		" save!
-		let bufname = bufname(winbufnr(winnr()))
-		if &modified
-			let action=confirm("Save Changes in " . bufname . "?","&Yes\n&No\n&Cancel")
-			" Yes - try to save - if there is an error, cancel
-			if action == 1
-				let v:errmsg = ""
-				silent w
-				if v:errmsg != ""
-					echoerr "Unable to write buffer!"
-					wincmd p
-					return
-				endif
-				" No, abandon changes
-			elseif action == 2
-				set nomodified
-				echomsg "Warning, abandoning changes in " . bufname
-				" Cancel (or any other result), don't do the open
-			else
-				wincmd p
-				return
-			endif
-		endif
-		wincmd p
-		call s:EditEntry("wincmd p","edit")
-	endif
-endfunction
-
-"
-" save the contents of the currently displayed file listing into the current
-" s:dir_i variable
-"
-function! s:RestoreFileDisplay()
-	let oldRep=&report
-	let save_sc = &sc
-	set report=10000 nosc
-	let presLine = line('.')
-
-	let saverega = @a
-	normal! ggVG"ay
-	exec 'let s:FileList_'.s:currentFileNumberDisplayed.' = @a'
-	let @a = saverega
-
-	let &report=oldRep
-	let &sc = save_sc
-	exe presLine
-endfunction
-
-"---
-" Open a file or directory in a new window.
-" Use g:explSplitBelow and g:explSplitRight to decide where to put the
-" split window, and resize the original explorer window if it is
-" larger than g:explWinSize
-"
-function! s:OpenEntry()
-  " Are we on a line with a file name?
-  let l = getline(".")
-  if l =~ '^"'
-    return
-  endif
-
-  " Copy window settings to script settings
-  let s:sortby=w:sortdirlabel . w:sorttype
-  let s:longhelp = w:longhelp
-  let s:longlist = w:longlist
-
-  " Get the window number of the explorer window
-  let n = winnr()
-
-  " Save the user's settings for splitbelow and splitright
-  let savesplitbelow=&splitbelow
-  let savesplitright=&splitright
-
-  " Figure out how to do the split based on the user's preferences.
-  " We want to split to the (left,right,top,bottom) of the explorer
-  " window, but we want to extract the screen real-estate from the
-  " window next to the explorer if possible.
-  "
-  " 'there' will be set to a command to move from the split window
-  " back to the explorer window
-  "
-  " 'back' will be set to a command to move from the explorer window
-  " back to the newly split window
-  "
-  " 'right' and 'below' will be set to the settings needed for
-  " splitbelow and splitright IF the explorer is the only window.
-  "
-  if g:explVertical
-    if g:explSplitRight
-      let there="wincmd h"
-      let back ="wincmd l"
-      let right=1
-      let below=0
-    else
-      let there="wincmd l"
-      let back ="wincmd h"
-      let right=0
-      let below=0
-    endif
-  else
-    if g:explSplitBelow
-      let there="wincmd k"
-      let back ="wincmd j"
-      let right=0
-      let below=1
-    else
-      let there="wincmd j"
-      let back ="wincmd k"
-      let right=0
-      let below=0
-    endif
-  endif
-
-  " Get the file name
-  let fn=s:GetFullFileName()
-
-  " Attempt to go to adjacent window
-  exec(back)
-  " If no adjacent window, set splitright and splitbelow appropriately
-  if n == winnr()
-    let &splitright=right
-    let &splitbelow=below
-  else
-    " found adjacent window - invert split direction
-    let &splitright=!right
-    let &splitbelow=!below
-  endif
-
-  " Create a variable to use if splitting vertically
-  let splitMode = ""
-  if g:explVertical == 1
-    let splitMode = "vertical"
-  endif
-
-  " Is it a directory?  If so, get a real path to it instead of
-  " relative path
-  if isdirectory(fn)
-    let origdir= s:Path(getcwd())
-    exe "chdir" escape(fn,s:escfilename)
-    let fn = s:Path(getcwd())
-    exe "chdir" escape(origdir,s:escfilename)
-  endif
-
-  " Open the new window
-  exec("silent " . splitMode." sp " . escape(fn,s:escfilename))
-
-  " resize the explorer window if it is larger than the requested size
-  exec(there)
-  if g:explWinSize =~ '[0-9]\+' && winheight("") > g:explWinSize
-    exec("silent ".splitMode." resize ".g:explWinSize)
-  endif
-  exec(back)
-
-  " Restore splitmode settings
-  let &splitbelow=savesplitbelow
-  let &splitright=savesplitright
-
-endfunction
-
-"---
-" Double click with the mouse
-"
-function s:DoubleClick()
-	if expand("<cfile>") =~ '[\\/]$'
-		call s:EditEntry("","edit")		" directory: open in this window
-	else
-		call s:OpenEntryPrevWindow()	" file: open in another window
-	endif
-endfun
-
-"---
-" Open file or directory in the same window as the explorer is
-" currently in
-"
-function! s:EditEntry(movefirst,editcmd)
-  " Are we on a line with a file name?
-  let l = getline(".")
-  if l =~ '^"'
-    return
-  endif
-
-  " Copy window settings to script settings
-  let s:sortby=w:sortdirlabel . w:sorttype
-  let s:longhelp = w:longhelp
-  let s:longlist = w:longlist
-
-  " Get the file name
-  let fn=s:GetFullFileName()
-  if isdirectory(fn)
-    let origdir= s:Path(getcwd())
-    exe "chdir" escape(fn,s:escfilename)
-    let fn = s:Path(getcwd())
-    exe "chdir" escape(origdir,s:escfilename)
-  endif
-
-	" if its the original explorer using this function, then proceed as before.
-	if !(exists("b:displayMode") && b:displayMode == "winmanager")
-		" Move to desired window if needed
-		exec(a:movefirst)
-		" Edit the file/dir
-		exec(a:editcmd . " " . escape(fn,s:escfilename))
-	" otherwise if its winmanager which called it, then do things the winmanager
-	" way, i.e, open directories in the same buffer and open files in the last
-	" visited file editing area (splitting if necessary)
-	else
-		if isdirectory(fn)
-			" callinng EditDir ensures that things are displayed in the same buffer.
-			call s:EditDir(fn)
-		else
-			" this function is provided by winmanager. it takes focus to the last
-			" visited buffer in the file editing area and then opens the new file in
-			" its place, while taking into consideration whether that buffer was
-			" modified, or whether the user wants to force a split each time, etc.
-			call WinManagerFileEdit(fn, a:movefirst)
-		end
-	end
-endfunction
-
-"---
-" Create a regular expression out of the suffixes option for sorting
-" and set a string to indicate whether we are sorting with the
-" suffixes at the end (or the beginning)
-"
-function! s:SetSuffixesLast()
-	let b:suffixesRegexp = '\(' . substitute(escape(&suffixes,s:escregexp),',','\\|','g') . '\)$'
-	let b:suffixesHighlight = '^[^"].*\(' . substitute(escape(&suffixes,s:escregexp),',','\\|','g') . '\)\( \|$\)'
-	if has("fname_case")
-		let b:suffixesRegexp = '\C' . b:suffixesRegexp
-		let b:suffixesHighlight = '\C' . b:suffixesHighlight
-	else
-		let b:suffixesRegexp = '\c' . b:suffixesRegexp
-		let b:suffixesHighlight = '\c' . b:suffixesHighlight
-	endif
-	if g:explSuffixesLast > 0 && &suffixes != ""
-		let b:suffixeslast=" (" . &suffixes . " at end of list)"
-	elseif g:explSuffixesLast < 0 && &suffixes != ""
-		let b:suffixeslast=" (" . &suffixes . " at start of list)"
-	else
-		let b:suffixeslast=" ('suffixes' mixed with files)"
-	endif
-endfunction
-
-"---
-" Show the header and contents of the directory
-"
-function! s:ShowDirectory()
-	" Prevent a report of our actions from showing up
-	let oldRep=&report
-	let save_sc = &sc
-	set report=10000 nosc
-
-	"Delete all lines
-	1,$d _
-
-	" Add the header
-	call s:AddHeader()
-	$d _
-
-	" Display the files
-
-	" Get a list of all the files
-	let files = s:Path(glob(b:completePath."*"))
-	if files != "" && files !~ '\n$'
-		let files = files . "\n"
-	endif
-
-	" Add the dot files now, making sure "." is not included!
-	let files = files . substitute(s:Path(glob(b:completePath.".*")), "[^\n]*/./\\=\n", '' , '')
-	if files != "" && files !~ '\n$'
-		let files = files . "\n"
-	endif
-
-	" Are there any files left after filtering?
-	if files != ""
-		normal! mt
-		put =files
-		let b:maxFileLen = 0
-		0
-		/^"=/+1,$g/^/call s:MarkDirs()
-		call s:CleanUpHistory()
-		normal! `t
-		call s:AddFileInfo()
-	endif
-
-	normal! zz
-
-	" Move to first directory in the listing
-	0
-	/^"=/+1
-	call s:CleanUpHistory()
-
-	" Do the sort
-	call s:SortListing("Loaded contents of ".b:completePath.". ")
-
-	" Move to first directory in the listing
-	0
-	/^"=/+1
-	call s:CleanUpHistory()
-
-	let &report=oldRep
-	let &sc = save_sc
-
-endfunction
-
-function! s:AddToFavDir()
-
-	if s:favDirs !~ "\\(^\\|\n\\)".b:completePath."\\(\n\\|$\\)"
-		let s:favDirs = s:favDirs."\n".b:completePath
-	else
-		return
-	endif
-
-	let pos = (line('.')+1).' | normal! '.virtcol('.').'|'
-	call s:PrintFavDirs()
-	exe pos
-endfunction
-
-"---
-" Mark which items are directories - called once for each file name
-" must be used only when size/date is not displayed
-"
-function! s:MarkDirs()
-	let oldRep=&report
-	set report=1000
-	"Remove slashes if added
-	s;/$;;e
-	"Removes all the leading slashes and adds slashes at the end of directories
-	s;^.*\\\([^\\]*\)$;\1;e
-	s;^.*/\([^/]*\)$;\1;e
-	"normal! ^
-	let currLine=getline(".")
-	if isdirectory(b:completePath . currLine)
-		s;$;/;
-		let fileLen=strlen(currLine)+1
-	else
-		let fileLen=strlen(currLine)
-		if (b:filterFormula!="") && (currLine =~ b:filterFormula)
-			" Don't show the file if it is to be filtered.
-			d _
-		endif
-	endif
-	if fileLen > b:maxFileLen
-		let b:maxFileLen=fileLen
-	endif
-	let &report=oldRep
-endfunction
-
-"---
-" Make sure a path has proper form
-"
-function! s:Path(p)
-	if has("dos16") || has("dos32") || has("win16") || has("win32") || has("os2")
-		return substitute(a:p,'\\','/','g')
-	else
-		return a:p
-	endif
-endfunction
-
-"---
-" Extract the file name from a line in several different forms
-"
-function! s:GetFullFileNameEsc()
-    return s:EscapeFilename(s:GetFullFileName())
-endfunction
-
-function! s:GetFileNameEsc()
-    return s:EscapeFilename(s:GetFileName())
-endfunction
-
-function! s:EscapeFilename(name)
-    return escape(a:name,s:escfilename)
-endfunction
-
-
-function! s:GetFullFileName()
-	if getline('.') =~ '+ '
-		if match(getline('.'), '(.*)') > 0
-			return matchstr(getline('.'), '(\zs.*\ze)')
-		else
-			return strpart(getline('.'), 2, 1000)
-		endif
-	endif
-	return s:ExtractFullFileName(getline("."))
-endfunction
-
-function! s:GetFileName()
-	return s:ExtractFileName(getline("."))
-endfunction
-
-function! s:ExtractFullFileName(line)
-	let fn=s:ExtractFileName(a:line)
-	if fn == '/'
-		return b:completePath
-	else
-		return b:completePath . s:ExtractFileName(a:line)
-	endif
-endfunction
-
-function! s:ExtractFileName(line)
-	return substitute(strpart(a:line,0,b:maxFileLen),'\s\+$','','')
-endfunction
-
-"---
-" Get the size of the file
-function! s:ExtractFileSize(line)
-	if (w:longlist==0)
-		return getfsize(s:ExtractFileName(a:line))
-	else
-		return strpart(a:line,b:maxFileLen+2,b:maxFileSizeLen);
-	endif
-endfunction
-
-"---
-" Get the date of the file as a number
-function! s:ExtractFileDate(line)
-	if w:longlist==0
-		return getftime(s:ExtractFileName(a:line))
-	else
-		return strpart(matchstr(strpart(a:line,b:maxFileLen+b:maxFileSizeLen+4),".*"),1) + 0
-	endif
-endfunction
-
-
-"---
-" Add the header with help information
-"
-function! s:AddHeader()
-	let save_f=@f
-	1
-	if w:longhelp==1
-		let @f="\" <enter> : open file or directory\n"
-			\."\" o : open new window for file/directory\n"
-			\."\" O : open file in previously visited window\n"
-			\."\" p : preview the file\n"
-			\."\" i : toggle size/date listing\n"
-			\."\" s : select sort field    r : reverse sort\n"
-			\."\" - : go up one level      c : cd to this dir\n"
-			\."\" R : rename file          D : delete file\n"
-			\."\" f : add current directory to favourites\n"
-			\."\" :help file-explorer for detailed help\n"
-	else
-		let @f="\" Press ? for keyboard shortcuts\n"
-	endif
-	let @f=@f."\" Sorted by ".w:sortdirlabel.w:sorttype.b:suffixeslast.b:filtering."\n"
-	let @f=@f."\"= ".b:completePath."\n"
-	put! f
-	let @f=save_f
-endfunction
-
-function! s:PrintFavDirs()
-	if !exists('s:favDirs')
-		return
-	end
-	setlocal modifiable
-	0
-	if search('^"=')
-		exe  'silent! 1,'.line('.').' g/^+ .*$/d _'
-	else
-		call s:CleanUpHistory()
-		setlocal nomodifiable nomodified
-		return
-	endif
-	call s:CleanUpHistory()
-	let favDirs = s:favDirs
-	let favDirs = substitute(favDirs, "\\(^\\|\n\\)", '\1+ ', 'g')
-	let favDirs = substitute(favDirs, '$', "\n", '')
-	0
-	call search('^"=')
-	silent! put!=favDirs
-	silent! g/^+ /s/\v^\+ (.*)\/([^\/]+\/=)$/+ \2 (\1\/\2)
-	call s:CleanUpHistory()
-	call s:CleanUpHistory()
-	setlocal nomodifiable nomodified
-endfunction
-
-"---
-" Show the size and date for each file
-"
-function! s:AddFileInfo()
-	let save_sc = &sc
-	set nosc
-
-	" Mark our starting point
-	normal! mt
-
-	call s:RemoveSeparators()
-
-	" Remove all info
-	0
-	/^"=/+1,$g/^/call setline(line("."),s:GetFileName())
-	call s:CleanUpHistory()
-
-	" Add info if requested
-	if w:longlist==1
-		" Add file size and calculate maximum length of file size field
-		let b:maxFileSizeLen = 0
-		0
-		/^"=/+1,$g/^/let fn=s:GetFullFileName() |
-			\let fileSize=getfsize(fn) |
-			\let fileSizeLen=strlen(fileSize) |
-			\if fileSizeLen > b:maxFileSizeLen |
-			\   let b:maxFileSizeLen = fileSizeLen |
-			\endif |
-			\exec "normal! ".(b:maxFileLen-strlen(getline("."))+2)."A \<esc>" |
-			\exec 's/$/'.fileSize.'/'
-		call s:CleanUpHistory()
-
-		" Right justify the file sizes and
-		" add file modification date
-		0
-		/^"=/+1,$g/^/let fn=s:GetFullFileName() |
-			\exec "normal! A \<esc>$b".(b:maxFileLen+b:maxFileSizeLen-strlen(getline("."))+3)."i \<esc>\"_x" |
-			\exec 's/$/ '.escape(s:FileModDate(fn), '/').'/'
-		call s:CleanUpHistory()
-		setlocal nomodified
-	endif
-
-	call s:AddSeparators()
-
-	" return to start
-	normal! `t
-
-	let &sc = save_sc
-endfunction
-
-
-"----
-" Get the modification time for a file
-"
-function! s:FileModDate(name)
-	let filetime=getftime(a:name)
-	if filetime > 0
-		return strftime(g:explDateFormat,filetime) . " " . filetime
-	else
-		return ""
-	endif
-endfunction
-
-"---
-" Delete a file or files
-"
-function! s:DeleteFile() range
-	let oldRep = &report
-	let &report = 1000
-
-	let filesDeleted = 0
-	let stopDel = 0
-	let delAll = 0
-	let currLine = a:firstline
-	let lastLine = a:lastline
-	setlocal modifiable
-
-	while ((currLine <= lastLine) && (stopDel==0))
-		exec(currLine)
-		let fileName=s:GetFullFileName()
-		if isdirectory(fileName)
-			echo fileName." : Directory deletion not supported yet"
-			let currLine = currLine + 1
-		else
-			if delAll == 0
-				let sure=input("Delete ".fileName." (y/n/a/q)? ")
-				if sure=="a"
-					let delAll = 1
-				endif
-			endif
-			if (sure=="y") || (sure=="a")
-				let success=delete(fileName)
-				if success!=0
-					exec (" ")
-					echo "\nCannot delete ".fileName
-					let currLine = currLine + 1
-				else
-					d _
-					let filesDeleted = filesDeleted + 1
-					let lastLine = lastLine - 1
-				endif
-			elseif sure=="q"
-				let stopDel = 1
-			elseif sure=="n"
-				let currLine = currLine + 1
-			endif
-		endif
-	endwhile
-	echo "\n".filesDeleted." files deleted"
-	let &report = oldRep
-	setlocal nomodified
-	setlocal nomodifiable
-endfunction
-
-"---
-" Rename a file
-"
-function! s:RenameFile()
-	let fileName=s:GetFullFileName()
-	setlocal modifiable
-	if isdirectory(fileName)
-		echo "Directory renaming not supported yet"
-	elseif filereadable(fileName)
-		let altName=input("Rename ".fileName." to : ")
-		echo " "
-		if altName==""
-			setlocal nomodifiable
-			return
-		endif
-		let success=rename(fileName, b:completePath.altName)
-		if success!=0
-			echo "Cannot rename ".fileName. " to ".altName
-		else
-			echo "Renamed ".fileName." to ".altName
-			let oldRep=&report
-			set report=1000
-			" e!
-			" instead of generating a bufEnter event if we use e!, use EditDir. It
-			" doesnt matter that EditDir() is called with more than 0 arguments
-			" whether or not winmanager is active because at this location, we have
-			" a buffer open anyway.
-			call s:EditDir(b:completePath, 1)
-			let &report=oldRep
-		endif
-	endif
-	setlocal nomodified
-	setlocal nomodifiable
-	call s:RestoreFileDisplay()
-endfunction
-
-"---
-" Toggle between short and long help
-"
-function! s:ToggleHelp()
-	if exists("w:longhelp") && w:longhelp==0
-		let w:longhelp=1
-		let s:longhelp=1
-	else
-		let w:longhelp=0
-		let s:longhelp=0
-	endif
-	" Allow modification
-	setlocal modifiable
-	call s:UpdateHeader()
-	" Disallow modification
-	setlocal nomodifiable
-endfunction
-
-"---
-" Update the header
-"
-function! s:UpdateHeader()
-	let oldRep=&report
-	set report=10000
-	" Save position
-	normal! mt
-	" Remove old header
-	0
-	1,/^"=/ d _
-	call s:CleanUpHistory()
-	" Add new header
-	call s:AddHeader()
-	" Go back where we came from if possible
-	0
-	if line("'t") != 0
-		normal! `t
-	endif
-
-	let &report=oldRep
-	setlocal nomodified
-endfunction
-
-"---
-" Toggle long vs. short listing
-"
-function! s:ToggleLongList()
-	setlocal modifiable
-	if exists("w:longlist") && w:longlist==1
-		let w:longlist=0
-		let s:longlist=0
-	else
-		let w:longlist=1
-		let s:longlist=1
-	endif
-	call s:AddFileInfo()
-	setlocal nomodifiable
-endfunction
-
-"---
-" Show all files - remove filtering
-"
-function! s:ShowAllFiles()
-	setlocal modifiable
-	let b:filterFormula=""
-	let b:filtering=""
-	call s:ShowDirectory()
-	setlocal nomodifiable
-endfunction
-
-"---
-" Figure out what section we are in
-"
-function! s:GetSection()
-	let fn=s:GetFileName()
-	let section="file"
-	if fn =~ '/$'
-		let section="directory"
-	elseif fn =~ b:suffixesRegexp
-		let section="suffixes"
-	endif
-	return section
-endfunction
-
-"---
-" Remove section separators
-"
-function! s:RemoveSeparators()
-  if !g:explUseSeparators
-    return
-  endif
-  0
-  silent! exec '/^"=/+1,$g/^' . s:separator . "/d _"
-  call s:CleanUpHistory()
-endfunction
-
-"---
-" Add section separators
-"   between directories and files if they are separated
-"   between files and 'suffixes' files if they are separated
-function! s:AddSeparators()
-  if !g:explUseSeparators
-    return
-  endif
-  0
-  /^"=/+1
-  call s:CleanUpHistory()
-  let lastsec=s:GetSection()
-  +1
-  .,$g/^/let sec=s:GetSection() |
-               \if g:explDirsFirst != 0 && sec != lastsec &&
-               \   (lastsec == "directory" || sec == "directory") |
-               \  exec "normal! I" . s:separator . "\n\<esc>" |
-               \elseif g:explSuffixesLast != 0 && sec != lastsec &&
-               \   (lastsec == "suffixes" || sec == "suffixes") |
-               \  exec "normal! I" . s:separator . "\n\<esc>" |
-               \endif |
-               \let lastsec=sec
-endfunction
-
-"---
-" General string comparison function
-"
-function! s:StrCmp(line1, line2, direction)
-	if a:line1 < a:line2
-		return -a:direction
-	elseif a:line1 > a:line2
-		return a:direction
-	else
-		return 0
-	endif
-endfunction
-
-"---
-" Function for use with Sort(), to compare the file names
-" Default sort is to put in alphabetical order, but with all directory
-" names before all file names
-"
-function! s:FileNameCmp(line1, line2, direction)
-	let f1=s:ExtractFileName(a:line1)
-	let f2=s:ExtractFileName(a:line2)
-
-	" Put directory names before file names
-	if (g:explDirsFirst != 0) && (f1 =~ '\/$') && (f2 !~ '\/$')
-		return -g:explDirsFirst
-	elseif (g:explDirsFirst != 0) && (f1 !~ '\/$') && (f2 =~ '\/$')
-		return g:explDirsFirst
-	elseif (g:explSuffixesLast != 0) && (f1 =~ b:suffixesRegexp) && (f2 !~ b:suffixesRegexp)
-		return g:explSuffixesLast
-	elseif (g:explSuffixesLast != 0) && (f1 !~ b:suffixesRegexp) && (f2 =~ b:suffixesRegexp)
-		return -g:explSuffixesLast
-	else
-		return s:StrCmp(f1,f2,a:direction)
-	endif
-
-endfunction
-
-"---
-" Function for use with Sort(), to compare the file modification dates
-" Default sort is to put NEWEST files first.  Reverse will put oldest
-" files first
-"
-function! s:FileDateCmp(line1, line2, direction)
-	let f1=s:ExtractFileName(a:line1)
-	let f2=s:ExtractFileName(a:line2)
-	let t1=s:ExtractFileDate(a:line1)
-	let t2=s:ExtractFileDate(a:line2)
-
-	" Put directory names before file names
-	if (g:explDirsFirst != 0) && (f1 =~ '\/$') && (f2 !~ '\/$')
-		return -g:explDirsFirst
-	elseif (g:explDirsFirst != 0) && (f1 !~ '\/$') && (f2 =~ '\/$')
-		return g:explDirsFirst
-	elseif (g:explSuffixesLast != 0) && (f1 =~ b:suffixesRegexp) && (f2 !~ b:suffixesRegexp)
-		return g:explSuffixesLast
-	elseif (g:explSuffixesLast != 0) && (f1 !~ b:suffixesRegexp) && (f2 =~ b:suffixesRegexp)
-		return -g:explSuffixesLast
-	elseif t1 > t2
-		return -a:direction
-	elseif t1 < t2
-		return a:direction
-	else
-		return s:StrCmp(f1,f2,1)
-	endif
-endfunction
-
-"---
-" Function for use with Sort(), to compare the file sizes
-" Default sort is to put largest files first.  Reverse will put
-" smallest files first
-"
-function! s:FileSizeCmp(line1, line2, direction)
-	let f1=s:ExtractFileName(a:line1)
-	let f2=s:ExtractFileName(a:line2)
-	let s1=s:ExtractFileSize(a:line1)
-	let s2=s:ExtractFileSize(a:line2)
-
-	if (g:explDirsFirst != 0) && (f1 =~ '\/$') && (f2 !~ '\/$')
-		return -g:explDirsFirst
-	elseif (g:explDirsFirst != 0) && (f1 !~ '\/$') && (f2 =~ '\/$')
-		return g:explDirsFirst
-	elseif (g:explSuffixesLast != 0) && (f1 =~ b:suffixesRegexp) && (f2 !~ b:suffixesRegexp)
-		return g:explSuffixesLast
-	elseif (g:explSuffixesLast != 0) && (f1 !~ b:suffixesRegexp) && (f2 =~ b:suffixesRegexp)
-		return -g:explSuffixesLast
-	elseif s1 > s2
-		return -a:direction
-	elseif s1 < s2
-		return a:direction
-	else
-		return s:StrCmp(f1,f2,1)
-	endif
-endfunction
-
-"---
-" Sort lines.  SortR() is called recursively.
-"
-function! s:SortR(start, end, cmp, direction)
-
-  " Bottom of the recursion if start reaches end
-  if a:start >= a:end
-    return
-  endif
-  "
-  let partition = a:start - 1
-  let middle = partition
-  let partStr = getline((a:start + a:end) / 2)
-  let i = a:start
-  while (i <= a:end)
-    let str = getline(i)
-    exec "let result = " . a:cmp . "(str, partStr, " . a:direction . ")"
-    if result <= 0
-      " Need to put it before the partition.  Swap lines i and partition.
-      let partition = partition + 1
-      if result == 0
-        let middle = partition
-      endif
-      if i != partition
-        let str2 = getline(partition)
-        call setline(i, str2)
-        call setline(partition, str)
-      endif
-    endif
-    let i = i + 1
-  endwhile
-
-  " Now we have a pointer to the "middle" element, as far as partitioning
-  " goes, which could be anywhere before the partition.  Make sure it is at
-  " the end of the partition.
-  if middle != partition
-	  let str = getline(middle)
-	  let str2 = getline(partition)
-	  call setline(middle, str2)
-	  call setline(partition, str)
-  endif
-  call s:SortR(a:start, partition - 1, a:cmp,a:direction)
-  call s:SortR(partition + 1, a:end, a:cmp,a:direction)
-endfunction
-
-"---
-" To Sort a range of lines, pass the range to Sort() along with the name of a
-" function that will compare two lines.
-"
-function! s:Sort(cmp,direction) range
-	call s:SortR(a:firstline, a:lastline, a:cmp, a:direction)
-endfunction
-
-"---
-" Reverse the current sort order
-"
-function! s:SortReverse()
-	if exists("w:sortdirection") && w:sortdirection == -1
-		let w:sortdirection = 1
-		let w:sortdirlabel  = ""
-	else
-		let w:sortdirection = -1
-		let w:sortdirlabel  = "reverse "
-	endif
-	let s:sortby=w:sortdirlabel . w:sorttype
-	call s:SortListing("")
-endfunction
-
-"---
-" Toggle through the different sort orders
-"
-function! s:SortSelect()
-	" Select the next sort option
-	if !exists("w:sorttype")
-		let w:sorttype="name"
-	elseif w:sorttype == "name"
-		let w:sorttype="size"
-	elseif w:sorttype == "size"
-		let w:sorttype="date"
-	else
-		let w:sorttype="name"
-	endif
-	let s:sortby=w:sortdirlabel . w:sorttype
-	call s:SortListing("")
-endfunction
-
-"---
-" Sort the file listing
-"
-function! s:SortListing(msg)
-    " Save the line we start on so we can go back there when done
-    " sorting
-    let startline = getline(".")
-    let col=col(".")
-    let lin=line(".")
-
-    " Allow modification
-    setlocal modifiable
-
-    " Send a message about what we're doing
-    " Don't really need this - it can cause hit return prompts
-"   echo a:msg . "Sorting by" . w:sortdirlabel . w:sorttype
-
-    " Create a regular expression out of the suffixes option in case
-    " we need it.
-    call s:SetSuffixesLast()
-
-    " Remove section separators
-    call s:RemoveSeparators()
-
-    " Do the sort
-    0
-    if w:sorttype == "size"
-      /^"=/+1,$call s:Sort("s:FileSizeCmp",w:sortdirection)
-    elseif w:sorttype == "date"
-      /^"=/+1,$call s:Sort("s:FileDateCmp",w:sortdirection)
-    else
-      /^"=/+1,$call s:Sort("s:FileNameCmp",w:sortdirection)
-    endif
-  	call s:CleanUpHistory()
-
-    " Replace the header with updated information
-    call s:UpdateHeader()
-
-    " Restore section separators
-    call s:AddSeparators()
-
-    " Return to the position we started on
-    0
-    if search('\m^'.escape(startline,s:escregexp),'W') <= 0
-      execute lin
-    endif
-    execute "normal!" col . "|"
-
-    " Disallow modification
-    setlocal nomodified
-    setlocal nomodifiable
-
-endfunction
-
-if !g:defaultExplorer
-	let loaded_explorer = 1
-	"---
-	" Create commands
-	if !exists(':Explore')
-		command -n=? -complete=dir Explore :call s:StartExplorer(0, '<a>')
-	endif
-	if !exists(':Sexplore')
-		command -n=? -complete=dir Sexplore :call s:StartExplorer(1, '<a>')
-	endif
-	" NOTE: This is a special command NOT to be used by users. Its here for
-	" communication between winmanager and explorer.vim. This command only works
-	" if you are currently 'editing' a directory, in which case, you dont need
-	" this anyway. USE AT YOUR OWN RISK.
-	if !exists(':ExploreInCurrentWindow')
-		command -n=? -complete=dir ExploreInCurrentWindow :call <SID>EditDir()
-	endif
-end
-
-" CleanUpHistory
-function! <SID>CleanUpHistory()
-  call histdel("/", -1)
-  let @/ = histget("/", -1)
-endfunction
-
-" restore 'cpo'
-let &cpo = s:cpo_save
-unlet s:cpo_save
-
-
-" vim: ts=4:noet:sw=4
Index: b/plugin/winmanager.vim
deleted file mode 100644
===================================================================
--- a/plugin/winmanager.vim
+++ /dev/null
@@ -1,1316 +0,0 @@
-"=============================================================================
-"        File: winmanager.vim
-"      Author: Srinath Avadhanula (srinath@eecs.berkeley.edu)
-" Last Change: Wed Apr 03 05:00 PM 2002 PST
-"        Help: winmanager.vim is a plugin which implements a classical windows
-"              type IDE in Vim-6.0.  When you open up a new file, simply type
-"              in :WMToggle. This will start up the file explorer.
-"
-"
-" NOTE:  Starting from winmanager-2.x you can add new plugins to winmanager
-" and also customize the window layout in your .vimrc
-"
-" See ":help winmanager" for additional details.
-" ============================================================================
-
-" quit if the user doesnt want us or if we are already loaded.
-if exists("loaded_winmanager")
-	finish
-end
-let loaded_winmanager = 1
-
-" width of the explorer windows 
-if !exists("g:winManagerWidth")
-	let g:winManagerWidth = 25
-end
-
-" whether to close winmanager if only explorer windows are visible.
-if !exists("g:persistentBehaviour")
-	let g:persistentBehaviour = 1
-end
-
-" default window layout
-if !exists("g:winManagerWindowLayout")
-	let g:winManagerWindowLayout = "FileExplorer,TagsExplorer|BufExplorer"
-end
-
-" use default explorer plugin which ships with vim.
-if !exists("g:defaultExplorer")
-	let g:defaultExplorer = 1
-end
-
-" commands
-" toggling between the windows manager open or closed. this can also be used
-" to start win manager.
-if !exists(':WMToggle')
-	command -nargs=0 WMToggle :silent call <SID>ToggleWindowsManager()
-end
-
-" WManager and WMclose still exist for backward compatibility, but their use
-" is deprecated because WMToggle has the functionality of both of them.
-if !exists(':WManager')
-	command -nargs=0 WManager :silent call <SID>StartWindowsManager()
-end
-if !exists(':WMClose')
-	command -nargs=0 WMClose :silent call <SID>CloseWindowsManager()
-end
-" command to go to either the first explorer window visible
-if !exists(':FirstExplorerWindow')
-	command -nargs=0 FirstExplorerWindow :silent call <SID>GotoExplorerWindow('1')
-end
-" command to go to either the last explorer window visible
-if !exists(':BottomExplorerWindow')
-	command -nargs=0 BottomExplorerWindow :silent call <SID>GotoExplorerWindow('$')
-end
-
-" this command is used internally by winmanager. shouldnt be of concern to the
-" user.
-if !exists(':WinManagerGotoNextInGroup')
-	command -nargs=1 WinManagerGotoNextInGroup :silent call <SID>GotoNextExplorerInGroup(<args>)
-end	
-if !exists(':WinManagerGotoPrevInGroup')
-	command -nargs=1 WinManagerGotoPrevInGroup :silent call <SID>GotoNextExplorerInGroup(<args>,-1)
-end	
-
-" nifty command for debugging. SVarValueWinManager 'MRUList' will echo the
-" value of 's:MRUList' for instance. to be used for debugging winmanager.
-" shouldn't be of interest to the user.
-if !exists(':SVarValueWinManager')
-	command -nargs=* SVarValueWinManager :call <SID>ShowVariableValue(<args>)
-end
-
-" characters that must be escaped for filenames
-if has("dos16") || has("dos32") || has("win16") || has("win32") || has("os2")
-	let s:escfilename = ' %#'
-else
-	let s:escfilename = ' \%#'
-endif
-
-" a quick way to "uncomment" all the debug print statements.
-let g:debugWinManager = 1
-let g:numRefs = 0
-
-" initialization.
-let s:numExplorerGroups = 0
-let s:numExplorers = 0
-
-" Line continuation used here
-let s:cpo_save = &cpo
-set cpo&vim
-
-"---
-" this function creates a variable 
-" s:explorerGroup_i
-" for the i^th time it is called. This variable will be of the form
-" s:explorerGroup_i = ",member1,member2,member3,"
-"
-" this provides a way to "group" various explorers into common groups, so that
-" one of them will be visible at a time.
-"
-function! <SID>RegisterExplorerGroup()
-	" g:winManagerWindowLayout is of the form
-	" 'FileExplorer,TagsExplorer|BufExplorer'
-	
-	" begin extracting groups from the layout variable.
-	let groupNum = 1
-	while 1
-		" if no more groups then break.	
-		let curGroup = s:Strntok(g:winManagerWindowLayout, '|', groupNum)
-		if curGroup == ''
-			break
-		end
-		
-		" otherwise extract the explorers belonging to this group and the
-		" explorer ID's etc. also protect against the same explorer being put
-		" in 2 groups.
-		let grplist = ','
-		let numlist = ','
-		let curgn = s:numExplorerGroups + 1
-
-		let i = 1
-		while 1
-			let name = s:Strntok(curGroup, ',', i)
-			if name == ''
-				break
-			end
-			" refuse to register an explorer twice, or if the explorer's title
-			" doesnt exist.
-			if exists('s:'.name.'_numberID') || !exists('g:'.name.'_title')
-				if  !exists('g:'.name.'_title')
-					if has('gui_running')
-						call confirm(name." is registered as a plugin, but I cannot seem to find it anywhere.\n"
-							\.'Make sure you have downloaded the relevant plugin or change the g:winManagerWindowLayout variable',
-							\"&ok", 1, 'Warning')
-					else
-						echohl Error
-						echomsg name." is registered as a plugin, but I cannot seem to find it anywhere."
-							\.'Please make sure you have downloaded the relevant plugin'
-						echohl None
-					endif
-				endif
-				let i = i + 1
-				continue
-			end
-
-			let s:numExplorers = s:numExplorers + 1
-			let num = s:numExplorers
-
-			exe 'let s:explorerName_'.num.' = name'
-
-			let grplist = grplist.name.","
-			let numlist = numlist.''.num.','
-
-			" create variables of the form ExplorerName_<group/member/number>ID
-			" which contains which group the explorer belongs to and its member
-			" number within that group and also its number
-			" this will create a variable of the form
-			exe 'let s:'.name.'_groupID  = "'.curgn.'"'
-			exe 'let s:'.name.'_memberID = "'.i.'"'
-			exe 'let s:'.name.'_numberID = "'.num.'"'
-
-			let i = i + 1
-		endwhile
-		if grplist == ','
-			call PrintError('no explorers registered in this run')
-			return
-		end
-
-		let s:numExplorerGroups = s:numExplorerGroups + 1
-
-		exe 'let s:explorerGroup_'.curgn.' = grplist'
-		exe 'let s:explorerGroupNums_'.curgn.' = numlist'
-		exe 'let s:numMembers_'.curgn.' = a:0'
-
-		let groupNum = groupNum + 1
-	endwhile
-
-endfunction
-
-
-"---
-" initializes the window manager. sets the initial layout. as of now, the
-" layout of the explorer windows (i.e, which plugin appears above or below the
-" other) depends on the order in which the plugins are sourced. 
-" TODO: make this easily user customizable later.
-"       Done! See comments about registration.
-"
-" this function opens each "registered" plugin in its appropriate position. it
-" also starts off the autocommand which makes dynamic updating of buffers
-" possible.
-"
-function! <SID>StartWindowsManager()
-	" for the first few versions of winmanager, if no registration is done,
-	" assume the following default configuration of the windows:
-	"    (FileExplorer, TagsExplorer)
-	"    (BufExplorer)
-	" This allows for an "easy" distribution. i.e, the installation will not
-	" break if the user is careless with his .vimrc
-	let oldRep=&report
-	let save_sc = &sc
-	set report=10000 nosc
-	if s:numExplorers == 0
-		call s:RegisterExplorerGroup()
-	end
-	let nothingShown = 1
-	let s:commandRunning = 1
-
-	if !exists("s:MRUList")
-		call s:InitializeMRUList()
-	end
-	let currentWindowNumber = winnr()
-
-	if !exists("s:gotExplorerTitles")
-		let s:gotExplorerTitles = 1
-		let i = 1
-		while i <= s:numExplorers
-			exe 'let name = s:explorerName_'.i
-			exe 'let s:explorerTitle_'.i.' = g:'.name.'_title'
-			let i = i + 1
-		endwhile
-	endif
-
-	" focus on the first visible explorer window.
-	let gotvisible = 0
-	let i = 1
-	while i <= s:numExplorerGroups
-		" check if the ith explorer is visible.
-		let windownum = s:IsExplorerGroupVisible(i)
-		if windownum != -1
-			call s:GotoWindow(windownum)
-			let gotvisible = 1
-			" cen is the "current explorer number". used while restoring the
-			" layout.
-			let cen = i
-			let nothingShown = 0
-			break
-		end
-		let i = i + 1
-	endwhile
-
-	" split the current window or vsplit a new window for the explorers if
-	" none of the explorers is visible.
-	if !gotvisible
-		if exists('s:lastMemberDisplayed_1')
-			let lastmem = s:lastMemberDisplayed_1
-		else
-			let lastmem = 1
-		end
-		let somethingDisplayed = s:EditNextVisibleExplorer(1, lastmem-1, 1, 'vsplit')
-		" if nothing was displayed this time, there is a possiblity it could
-		" happen later during one of the refresh cycles. remember this for
-		" then.
-		call PrintError('something displayed on '.lastmem.' of 1 :'.somethingDisplayed)
-		if !somethingDisplayed
-			let s:tryGroupAgain_1 = 1
-			q
-		else
-			let s:tryGroupAgain_1 = 0
-			let nothingShown = 0
-			let currentWindowNumber = currentWindowNumber + 1
-		end
-		let cen = 1
-		" for now assume that the explorer windows always stay on the left.
-		" TODO: make this optional later
-		wincmd H
-		" set up the correct width
-		exe g:winManagerWidth.'wincmd |'
-	end
-
-	" now we are on one of the explorers. time to redo the original layout.
-	let _split = &splitbelow
-	let i = 1
-	while i <= s:numExplorerGroups
-		" for each group, see if any member of it is visible.
-		let windownum = s:IsExplorerGroupVisible(i)
-		
-		" if this explorer group is not visible, then open the first plugin
-		" belonging to this group
-		if windownum == -1
-
-			" if this explorer group is "before" the cen, then split above, else
-			" below. except for the first time when this could possibly be
-			" true, it always evaluates to the else.
-			if i < cen
-				set nosplitbelow
-			else
-				set splitbelow
-			end
-			" find the last plugin belonging to this "group" which was
-			" displayed.
-			if exists('s:lastMemberDisplayed_'.i)
-				exe 'let lastmem = s:lastMemberDisplayed_'.i
-			else
-				let lastmem = 1
-			end
-			" try to display either that plugin or the one after it.
-			let somethingDisplayed = s:EditNextVisibleExplorer(i, lastmem-1,1,"split")
-			if !somethingDisplayed
-				exe 'let s:tryGroupAgain_'.i.' = 1'
-				q
-			else
-				exe 'let s:tryGroupAgain_'.i.' = 0'
-				" if this is the first explorer shown, need to push it to the
-				" right.
-				if nothingShown
-					wincmd H
-					" set up the correct width
-					exe g:winManagerWidth.'wincmd |'
-				end
-				let nothingShown = 0
-				let currentWindowNumber = currentWindowNumber + 1
-			end
-			let cen = i
-
-		" the group is visible, go to it so we can split the one after that
-		" from it.
-		else
-			call s:GotoWindow(windownum)
-		endif
-
-		let i = i + 1
-		" cen: current explorer (group) number which was visited.
-		let cen = i
-	endwhile
-	call PrintError('done with start while loop')
-	
-	" now make the run for resizing. 
-	let i = 1
-	while i <= s:numExplorerGroups
-		" find if its visible and the explorer of this group which is
-		" currently displayed.
-		let windownum = s:IsExplorerGroupVisible(i)
-		" need to check because some of the explorer groups might not have
-		" been displayed, if all their members were unable to display
-		" anything.
-		if windownum == -1
-			let i = i + 1
-			continue
-		end
-		let numexp = s:WhichMemberVisible(i)
-		
-		" visible, goto that window. 
-		call s:GotoWindow(windownum)
-		exe 'let name = s:explorerName_'.numexp
-		" if this is not occupying the entire height of the window, then call
-		" its ReSize() function (if it exists).
-		if exists('*'.name.'_ReSize') && !s:IsOnlyVertical()
-			exe 'call '.name.'_ReSize()'
-		end
-		let i = i + 1
-	endwhile
-	call PrintError('done with refresh while loop')
-
-	let &splitbelow = _split
-
-	augroup WinManagerRefresh
-		au!
-		au BufEnter * call <SID>RefreshWinManager()
-		au BufDelete * call <SID>RefreshWinManager("BufDelete")
-	augroup END
-
-	call s:GotoWindow(currentWindowNumber)
-	" RepairAltRegister needs to be called here as well, because 
-	" 1. when winmanager is re-started, we need to restore the @# register to
-	"    what it was.
-	" 2. if winmanager is started for the first time, then we need to ensure
-	"    that @# is at least not one of the explorer windows.
-	if buflisted(bufnr('%'))
-		call s:RepairAltRegister()
-	end
-	let s:commandRunning = 0
-	let &report=oldRep
-	let &sc = save_sc
-	if nothingShown
-		echomsg "[ no valid explorers available. winmanager will start when next possible ]"
-	end
-endfunction
-
-"---
-" if this window occupies the entire height of the screen, return 1, else
-" return 0. i.e return 1 if there is no window above or below this window.
-"
-function! <SID>IsOnlyVertical()
-	let curwin = winnr()
-	wincmd k
-	if curwin != winnr()
-		wincmd j
-		return 0
-	else
-		wincmd j
-		if winnr() != curwin
-			wincmd k
-			return 0
-		end
-	end
-	return 1
-endfunction
-
-"---
-" this function first takes focus to the last listed file being edited and
-" then depending on the users action and modified, etc opens the file bufName
-" either on it or splits a new window etc.
-"
-function! WinManagerFileEdit(bufName, split)
-	" this function is usually _not_ triggered from an autocommand, so the
-	" movement commands in this function will trigger RefreshWinManager().
-	" make that do nothing with this flag.
-	let s:commandRunning = 1
-	let oldRep=&report
-	let save_sc = &sc
-	set report=10000 nosc
-	
-	" if the file is already visible somewhere just go there.
-	" a:bufName is a fully qualified filename of the form
-	"    e:/path/to/file
-	" now bufnr('e:/path/to/file') != -1 even in the case where a file called
-	" e:/path/to/file/other/name is opened. (this is bufnr()'s behavior).
-	" therefore make an additional check so were protected against false
-	" matches.
-	if bufwinnr(bufnr(a:bufName)) != -1 &&
-		\ a:bufName == expand('#'.bufnr(a:bufName).':p')
-
-		call s:GotoWindow(bufwinnr(a:bufName))
-		" however, we still have to repair the @# register
-		call s:RepairAltRegister()
-
-	" otherwise goto the last listed buffer being edited.
-	else 
-
-		" if we had already opened this file, then use the #n notation instead
-		" of opening by file name. this preserves cursor position.
-		if bufnr(a:bufName) != -1 &&
-			\ a:bufName == expand('#'.bufnr(a:bufName).':p')
-			let bufcall = '#'.bufnr(a:bufName)
-		else
-			let bufcall = a:bufName
-		end
-
-		let lastBufferNumber = s:MRUGet(1)
-		" if the last accessed buffer is visible, then goto it.
-		if bufwinnr(lastBufferNumber) != -1
-			" the fact that we go to the last listed buffer and then open this
-			" buffer automatically protects the @# register.
-			call s:GotoWindow(bufwinnr(bufnr(lastBufferNumber)))
-			" now split it or not depending on stuff.
-			if (&modified && !&hidden) || a:split
-				exe 'silent! split '.bufcall
-			else
-				exe 'silent! e '.bufcall
-			end
-		else
-			" the last accessed buffer is not visible. this most probably
-			" means that the explorer buffers are the only windows visible.
-			" this means that the layout has to be redone by v-splitting a new
-			" window for this file.
-			" first open the alternate file just to retain @# if its still
-			" listed. 
-			if buflisted(lastBufferNumber)
-				exe 'silent! vsplit #'.lastBufferNumber
-				exe 'silent! e '.bufcall
-			" the last accessed buffer has dissapeared. just edit this file.
-			else
-				exe 'silent! vsplit '.bufcall
-			end
-			" now push this to the very right
-			wincmd L
-			" calculate the width of this window and reset it.
-			exe &columns-g:winManagerWidth.' wincmd |'
-		end
-	end
-
-	let s:commandRunning = 0
-
-	" call Refresh incase this fileopen made some displays invalid.
-	call s:RefreshWinManager()
-	let &report=oldRep
-	let &sc = save_sc
-endfunction
-
-
-"---
-" function to repair the @# register.
-"
-" quickly edit the alternate buffer previously being edited in the
-" FileExplorer area so that the % and # registers are not screwed with.
-" This function must be called while focus is on a listed buffer which needs
-" to be made @%.
-"
-function! <SID>RepairAltRegister()
-	" setting hidden while going back and forth is very wise because sometimes
-	" this function is used from within an autocommand. in such cases,
-	" switching back and forth between buffers makes the syntax highlighting
-	" dissapear.
-	let _hidden = &l:bufhidden
-	setlocal bufhidden=hide
-	let oldRep=&report
-	let save_sc = &sc
-	set report=10000 nosc
-
-	let currentBufferNumber = bufnr('%')
-	let currentBufferName = expand('%:p')
-	let alternateBufferNumber = s:MRUGet(2)
-
-	" if the required alternatebuffer exists, then first edit it to preserve @#
- 	if alternateBufferNumber != bufnr("#") 
-		\ && alternateBufferNumber != -1
-		\ && buflisted(alternateBufferNumber)
- 		exec 'silent! b! '.alternateBufferNumber
-	elseif alternateBufferNumber == -1
-	" if the alternate buffer doesnt exist, do some randomness so that the @#
-	" register is at least not some explorer buffer number. ideally, at this
-	" stage, something would have been done to ensure that @# = -1, however,
-	" for now, edit a temporary file.
-		exe "e ".tempname()
-		setlocal nobuflisted
-		setlocal nomodifiable
-		setlocal bufhidden=delete
-		setlocal buftype=nofile
-		let tmpBufNum = bufnr('%')
-		exe 'silent! b! '.currentBufferNumber
-		exe 'silent! bwipeout '.tmpBufNum
-		let &l:bufhidden = _hidden
-		return
-	end
-
- 	" now edit the current file (to preserve @% :-) )
-	" it seems that using ":b !" is _very_ important to preserve syntax
-	" highlighting. if ":e #" or ":b " is used, then syntax highlighting is
-	" lost and the ugly hack thing keeps getting called everytime. 
-	" still dont know exactly why this is. it has something to do with
-	" abandoned buffers being kept and also nested autocommands, but its not
-	" very clear to me what it is.
-	exec('silent! b! '.currentBufferNumber)
-
-	" a totally ugly hack to restore syntax highlighting... i have NO idea why
-	" this has to be here... somehow mixing opening files with autocommands
-	" has always been very very problematic.
-	" NOTE: the problem seems to have gone away now... see above comment.
-	if has("syntax") && exists("g:syntax_on") && !has("syntax_items")
-		call PrintError('needing to reset syntax!')
-		do syntax
-	else
-		call PrintError('fugly hack not needed!')
-	end
-	" end fugly hack.
-
-	let &l:bufhidden = _hidden
-	let &report=oldRep
-	let &sc = save_sc
-endfunction
-
-"---
-" the main function. this is responsible for updating plugins dynamically.
-" this function is triggered on the BufEnter and BufDelete events. every time
-" it is called, it makes a pass through all visible plugins and if their
-" display is not valid, it calls their Start() function.
-"
-" if this function is called with no arguments, it is assumed to be triggered
-" from a BufEnter even or due to a forcible refresh. If it is called with one
-" argument called "BufDelete", then it is assumed that it is triggered from
-" the BufDelete event.
-"
-function! <SID>RefreshWinManager(...)
-	" refreshes the window layout and the displayes of windows which trigger
-	" on autocommands.
-	
-	" make a note of whether this refresh was triggered by the BufDelete event
-	" or not.
-	let _split = &splitbelow
-	if a:0 > 0 && a:1 == "BufDelete"
-		let BufDelete = 1
-	else
-		let BufDelete = 0
-	end
-	" do the push pop thing irrespective of whether we do the rest of the
-	" stuff or not.
-	if BufDelete
-		call s:MRUPop()
-	else
-		call s:MRUPush()
-	end
-	" if this autocommand was triggered because of internal movements/commands
-	" due to other winmanager commands, then quit.
-	if exists("s:commandRunning") && s:commandRunning
-		return
-	end
-	" check if only explorer windows are visible and if so quit if we dont
-	" want persistent behavior.
-	if !g:persistentBehaviour && s:OnlyExplorerWindowsOpen()
-		qa
-	end
-	
-	" this magic statement is curing the syntax losing problem. WHY?
-	let s:commandRunning = 1
-	let g:numRefs = g:numRefs + 1
-
-	" remember this window number because we will return to it after
-	" refreshing the buffer listing.
-	let currentWindowNumber = winnr()
-	let curBufListed = buflisted(bufnr('%'))
-	let cfn = s:Path(expand("%:p"))
-
-	" now cycle through all the visible explorers and and for each "invalid"ly
-	" displayed explorer call its corresponding refresh and resize functions.
-	let i = 1
-	while i <= s:numExplorerGroups  && curBufListed
-		" find if its visible and the explorer of this group which is
-		" currently displayed.
-		let windownum = s:IsExplorerGroupVisible(i)
-		" if this explorer is visible, then call its _IsValid() function, etc.
-		if windownum == -1
-			let i = i + 1
-			continue
-		end
-		let numexp = s:WhichMemberVisible(i)
-		" visible, goto that window.
-		call s:GotoWindow(windownum)
-		exe 'let name = s:explorerName_'.numexp
-
-		exe 'let explorerName = s:explorerName_'.numexp
-		exe 'let isvalid = '.explorerName.'_IsValid()'
-		" ... and if it isnt then update it.
-		if !isvalid
-			call <SID>GotoWindow(windownum)
-			exe 'call '.explorerName.'_Start()'
-			if exists('*'.explorerName.'_ReSize') && !s:IsOnlyVertical()
-				exe 'call '.explorerName.'_ReSize()'
-			end
-		end
-		let i = i + 1
-	endwhile
-
-	" this while loop handles the case where a group of explorers are was not
-	" valid at some point and therefore didnt occupy a window, but became
-	" valid after some point and therefore need to obtain a seperate window.
-	let i = 1
-	while i <= s:numExplorerGroups && curBufListed
-		exe 'let retry = s:tryGroupAgain_'.i
-		" only do this if we need to retry opening this buffer. we should not
-		" keep opening a group which the user has closed using a ":quit"
-		" command.
-		if retry
-			call PrintError('retrying group '.i)
-			" find the 'nearest' group which is open.
-			let nearestGroup = 'inf'
-			let nearestWindow = 'inf'
-			" TODO: possible bug: what if there are more than a million
-			" plugins being used? :-)
-			let nearestGroupDist = 1000000
-			let j = 1
-			while j <= s:numExplorerGroups
-				
-				let windownum = s:IsExplorerGroupVisible(j)
-				if windownum != -1
-					let dist = ( (j-i) < 0 ? (i-j) : (j-i) )
-					if dist < nearestGroupDist
-						let nearestGroupDist = dist
-						let nearestGroup = j
-						let nearestWindow = windownum
-					end
-				end
-				let j = j + 1
-			endwhile
-
-			call PrintError('nearestWindow = '.nearestWindow)
-			" if nearestWindow is 'inf', it means no other explorer plugins
-			" are open. which means that this thing needs to go the very
-			" right.
-			if nearestWindow == 'inf'
-				let ecmd = 'vsplit'
-			else
-				let ecmd = 'split'
-				if nearestGroup > i
-					setlocal nosplitbelow
-				else
-					setlocal splitbelow
-				end
-			end
-			let somethingDisplayed = s:EditNextVisibleExplorer(i, 0, 1, ecmd)
-			" if nothing was displayed this time, there is a possiblity it could
-			" happen later during one of the refresh cycles. remember this for
-			" then.
-			if !somethingDisplayed
-				exe 'let s:tryGroupAgain_'.i.' = 1'
-				q
-			else
-				exe 'let s:tryGroupAgain_'.i.' = 0'
-				let currentWindowNumber = currentWindowNumber + 1
-				exe 'let name = s:explorerName_'.somethingDisplayed
-				if exists('*'.name.'_ReSize') && !s:IsOnlyVertical()
-					exe 'call '.name.'_ReSize()'
-				end
-				if nearestWindow == 'inf'
-					wincmd H
-					" set up the correct width
-					" set width only if we are creating a new window...
-					exe g:winManagerWidth.'wincmd |'
-				end
-				call PrintError('doing the funky open thing')
-			end
-		end
-		let i = i + 1
-	endwhile
-
-	call s:ResizeAllExplorers()
-
-	" refreshing done, now return back to where we were originally.
-	call <SID>GotoWindow(currentWindowNumber)
-	
-	" however, we still have to "repair" the actual @% and @# registers, in
-	" case we are returning to a listed buffer.  also should do this only for
-	" a BufEnter event. For a BufDelete event, the do this only if the current
-	" buffer is not the buffer being deleted.
-	call PrintError('refresh: abuf = '.expand('<abuf>'))
-	if buflisted(bufnr("%")) && !isdirectory(bufname("%")) && 
-	\	( !BufDelete || ( bufnr('%') != expand('<abuf>') ) )
-		call <SID>RepairAltRegister()
-	end
-
-	let s:commandRunning = 0
-	let &splitbelow = _split
-endfunction
-
-function! <SID>ResizeAllExplorers()
-	let i = 1
-	while i <= s:numExplorers
-		let explorerWinNum = s:IsExplorerVisible(i)
-		if explorerWinNum != -1
-			exe 'let explorerName = s:explorerName_'.i
-			if exists('*'.explorerName.'_ReSize') && !s:IsOnlyVertical()
-			" if a resize() function exists for this explorer and there
-			" is some window above and/or below this window, then call its
-			" resize function. this allows for dynamic resizing.
-				call s:GotoWindow(explorerWinNum)
-				exe 'call '.explorerName.'_ReSize()'
-				call PrintError('calling resize for '.explorerName)
-			end
-		end
-		let i = i + 1
-	endwhile
-endfunction
-
-"---
-" Make sure a path has proper form. 
-" this function forces every path to take the following form
-" dir1/dir2/file    OR
-" dir1/dir2/dir/ 
-" i.e, it replaces \ with / and stuff.
-"
-function! <SID>Path(p)
-	let _p = a:p
-	if a:p =~ '//$'
-		return ""
-	end
-	if isdirectory(_p)
-		let origdir= getcwd()
-		exe "chdir" _p
-		let _p = getcwd()
-		exe "chdir" origdir
-	end
-	if has("dos16") || has("dos32") || has("win16") || has("win32") || has("os2")
-		let _p = substitute(_p,'\\','/','g')
-	endif
-	if _p !~ '/$' && isdirectory(_p)
-		let _p = _p.'/'
-	endif
-	return _p
-endfunction
-
-" goto the reqdWinNum^th window. returns 0 on failure otherwise 1.
-function! <SID>GotoWindow(reqdWinNum)
-	let startWinNum = winnr()
-	if startWinNum == a:reqdWinNum
-		return 1
-	end
-	if winbufnr(a:reqdWinNum) == -1
-		return 0
-	else
-		exe a:reqdWinNum.' wincmd w'
-		return 1
-	end
-
-endfunction
-
-" returns the window number of the ith explorer if its visible, else -1
-function! <SID>IsExplorerVisible(i)
-	if exists('s:explorerBufNum_'.a:i)
-		exe 'let explorerBufNum = s:explorerBufNum_'.a:i
-	else
-		let explorerBufNum = -1
-	end
-	return bufwinnr(explorerBufNum)
-endfunction
-
-" returns the window number of the first explorer of the ith explorer group if
-" its visible, else -1
-"
-" if called with 2 arguments with the second being 'member', then returns the
-" member number which is visible instead of its window number
-"
-function! <SID>IsExplorerGroupVisible(i, ...)
-	" numList : the list of explorer numbers belonging to this group
-	exe 'let numList = s:explorerGroupNums_'.a:i
-	" ncl : next comma location
-	" pcl : previous comma location
-	let pcl = 0
-	let ncl	= match(numList, ',', pcl + 1)
-	while ncl != -1
-		exe 'let num = '.strpart(numList, pcl + 1, ncl - pcl - 1)
-		if s:IsExplorerVisible(num) != -1
-			if a:0 == 1 && a:1 == 'mem'
-				return num
-			else
-				return s:IsExplorerVisible(num)
-			end
-		end
-		let pcl = ncl
-		let ncl	= match(numList, ',', pcl + 1)
-	endwhile
-	return -1
-endfunction
-
-" returns the member number of the first explorer of the ith explorer group if
-" its visible, else -1
-function! <SID>WhichMemberVisible(i)
-	return s:IsExplorerGroupVisible(a:i, 'mem')
-endfunction
-
-" a handy little function for debugging.
-function! PrintError(eline)
-	if !g:debugWinManager
-		return
-	end
-	if !exists("g:myerror")
-		let g:myerror = ""
-	end
-	let g:myerror = g:myerror . "\n" . a:eline
-endfunction
-
-"---
-" find the memn^th member's explorer number of the groupn^th explorer group
-" i.e, if s:explorerGroup_2 = ",3,4,5,"
-" then FindExplorerInGroup(2,3) = 5
-" 
-" returs -1 if its not possible.
-"
-function! <SID>FindExplorerInGroup(groupn, memn)
-	" numList : the list of explorer numbers belonging to this group
-	exe 'let numList = s:explorerGroupNums_'.a:groupn
-
-	let num = s:Strntok2(numList, ',', a:memn)
-	if num == ''
-		return -1
-	end
-	exe 'return '.num
-endfunction
-
-"---
-" goto the next explorer in the group which this one belongs to.
-" if called with 2 arguments, goto the previous explorer.
-"
-function! <SID>GotoNextExplorerInGroup(name, ...)
-	let s:commandRunning = 1
-	" go forward or back?
-	if a:0 > 1
-		let dir = -1
-	else
-		let dir = 1
-	end
-
-	" first extract the ID variable from the name
-	exe 'let grpn = s:'.a:name.'_groupID'
-	exe 'let memn = s:'.a:name.'_memberID'
-	exe 'let numn = s:'.a:name.'_numberID'
-
-	" find the number of members of this group.
-	exe 'let nummems = s:numMembers_'.grpn
-	if nummems == 1
-		return 0
-	end
-
-	if exists('*'.a:name.'_WrapUp')
-		exe 'call '.a:name.'_WrapUp()'
-	end
-
-	let curbufnum = bufnr('%')
-	let somethingDisplayed = s:EditNextVisibleExplorer(grpn, memn, dir, 'e')
-	if !somethingDisplayed && curbufnum != bufnr('%')
-	   	" now start the next explorer using its title
-	   	exe 'let title = s:explorerTitle_'.numn
-	   	exe 'silent! e '.title
-		setlocal nobuflisted
-		setlocal bufhidden=delete
-		setlocal buftype=nofile
-		setlocal noswapfile
-
-		" call the Start() function for the next explorer ...
-		exe 'call '.a:name.'_Start()'
-		exe 'nnoremap <buffer> <C-n> :WinManagerGotoNextInGroup "'.a:name.'"<cr>'
-		exe 'nnoremap <buffer> <C-p> :WinManagerGotoPrevInGroup "'.a:name.'"<cr>'
-		setlocal nomodifiable
-		call WinManagerForceReSize(a:name)
-	end
-
-	let s:commandRunning = 0
-endfunction
-
-" edit the first possible explorer after memn belonging to groun. use editcmd
-" to form the new window.
-function! <SID>EditNextVisibleExplorer(grpn, memn, dir, editcmd)
-	
-	call PrintError('EditNext: grpn = '.a:grpn.', memn = '.a:memn.', dir = '.a:dir.' editcmd = '.a:editcmd)
-	" then try to find the number of the next member.
-	let startmn = (a:memn ? a:memn : 1)
-	let nextmn = a:memn + a:dir
-	let editcmd = a:editcmd
-
-	let somethingDisplayed = 0
-
-	let once = 0
-	" enter this loop at least once
-	while nextmn != startmn || !once
-	" cycle through the next explorers in this group finding out the next
-	" explorer which says its able to display anything at all.
-		let once = 1
-	
-		let nextEN = s:FindExplorerInGroup(a:grpn, nextmn)
-		" if the next member doesnt exist wrap around.
-		if nextEN == -1 
-			if a:dir == 1
-				let nextEN = s:FindExplorerInGroup(a:grpn, 1)
-				let nextmn = 1
-				continue
-			else
-				let nextEN = s:FindExplorerInGroup(a:grpn, nummems)
-				let nextmn = nummems
-				continue
-			end
-		end
-
-		" if we have come back to the same explorer with every other group
-		" member not able to display anything, then return.
-		call PrintError('nextmn = '.nextmn.' a:memn = '.a:memn)
-
-		exe 'let name = s:explorerName_'.nextEN
-		" if the _IsPossible() function doesn't exist, assume its always
-		" possible to display stuff.
-		let isposs = 1
-		if exists('*'.name.'_IsPossible')
-			exe 'let isposs = '.name.'_IsPossible()'
-		end
-		if isposs
-			" now start the next explorer using its title
-			exe 'let title = s:explorerTitle_'.nextEN
-			exe 'let name = s:explorerName_'.nextEN
-			exe 'silent! '.editcmd.' '.title
-			" use vsplitting etc only the first time things are opened.
-			if editcmd != 'e'
-				let editcmd = 'e'
-			end
-			" these are a few setting which most well-made explorers
-			" already set, but just to be on the safe side.
-			setlocal nobuflisted
-			setlocal bufhidden=delete
-			setlocal buftype=nofile
-			setlocal noswapfile
-
-			" call the Start() function for the next explorer ...
-			exe 'call '.name.'_Start()'
-			setlocal nomodifiable
-			" and remember its buffer number for later.
-			exe 'let s:explorerBufNum_'.nextEN.' = bufnr("%")'
-			" also remember that this was the last explorer of this group which was
-			" displayed.
-			exe 'let s:lastMemberDisplayed_'.a:grpn.' = nextmn'
-
-			" if this explorer has actually not put anything in the buffer
-			" then quit and forget.
-			if line('$') > 0 && getline('$') != ''
-				let somethingDisplayed = nextEN
-				break
-			end
-		end
-		" goto the next explorer of the group.
-		let nextmn = nextmn + a:dir
-	endwhile
-
-	if somethingDisplayed
-		" and then add this mapping to switch to the next/previous
-		" explorer in this group
-		exe 'nnoremap <buffer> <C-n> :WinManagerGotoNextInGroup "'.name.'"<cr>'
-		exe 'nnoremap <buffer> <C-p> :WinManagerGotoPrevInGroup "'.name.'"<cr>'
-	end
-	return somethingDisplayed
-endfunction
-
-
-" goes to either the first explorer window or the last explorer window
-" visible.
-function! <SID>GotoExplorerWindow(which)
-	let s:commandRunning = 1
-	" first go to either the top left or the bottom right window.
-	if a:which == '1'
-		" goto to the top left and move in the bottom/right direction.
-		wincmd t
-		let winmovecmd = 'wincmd w'
-	else
-		wincmd b
-		let winmovecmd = 'wincmd W'
-	end
-	" remember the window we started from.
-	let startWin = winnr()
-	let firstTime = 1
-	" then begin cycling through all the windows either going in the
-	" bottom/right direction or the top/left direction.
-	while 1
-		" if we are on an explorer window quit.
-		if s:IsExplorerBuffer(bufnr('%'))
-			let s:commandRunning = 0
-			return
-		end
-		" if we have cycled through one complete time without hitting pay
-		" dirt, quit.
-		if winnr() == startWin && !firstTime
-			" TODO: this will screw the @% and @# register.
-			break
-		end
-		let firstTime = 0
-		exe winmovecmd
-	endwhile
-	let s:commandRunning = 0
-endfunction
-
-" returns the explorer number if an explorer plugin exists with the specified
-" buffer number
-function! <SID>IsExplorerBuffer(num)
-	let i = 1
-	while i <= s:numExplorers
-		if exists('s:explorerBufNum_'.i)
-			exe 'let bufnum = s:explorerBufNum_'.i
-			if bufnum == a:num
-				return i
-			end
-		end
-		let i = i + 1
-	endwhile
-	return 0
-endfunction
-
-" toggle showing the explorer plugins.
-function! <SID>ToggleWindowsManager()
-	if IsWinManagerVisible()
-		call s:CloseWindowsManager()
-	else
-		call s:StartWindowsManager()
-	end
-endfunction
-
-" exported function. returns the buffer number of the last file being edited
-" in the file editing area.
-function! WinManagerGetLastEditedFile(...)
-	if a:0 == 0
-		return s:MRUGet(1)
-	else
-		let ret = s:MRUGet(a:1)
-		if ret == ''
-			return matchstr(s:MRUList, ',\zs[0-9]\+\ze,$')
-		else
-			return ret
-		end
-endfunction
-
-
-" exported function. returns 1 if any of the explorer windows are open,
-" otherwise returns 0.
-function! IsWinManagerVisible()
-	let i = 1
-	while i <= s:numExplorers
-		if s:IsExplorerVisible(i) != -1
-			return 1
-		end
-		let i = i + 1
-	endwhile
-	return 0
-endfunction
-
-
-" close all the visible explorer windows.
-function! <SID>CloseWindowsManager()
-	let s:commandRunning = 1
-
-	let i = 1
-	while i <= bufnr('$')
-		let explNum = s:IsExplorerBuffer(i)
-		if explNum > 0 && bufwinnr(i) != -1
-			exe 'bd '.i
-		end
-		let i = i + 1
-	endwhile
-
-	let s:commandRunning = 0
-endfunction
-
-" provides a way to examine script local variables from outside the script.
-" very handy for debugging.
-function! <SID>ShowVariableValue(...)
-	let i = 1
-	while i <= a:0
-		exe 'let arg = a:'.i
-		if exists('s:'.arg) ||
-		\  exists('*s:'.arg)
-			exe 'let val = s:'.arg
-			echomsg 's:'.arg.' = '.val
-		end
-		let i = i + 1
-	endwhile
-endfunction
-
-" the following functions are hooks provided by winmanager to external plugins
-" as a way to get winmanager to stop getting triggered on AUs. This is useful
-" when an explorer plugin triggers a BufEnter or BufDelete *internally*. For
-" example, bufexplorer.vim's "delete buffer" function triggers a BufDelete
-" function.
-"
-function! WinManagerSuspendAUs()
-	let s:commandRunning = 1
-endfunction
-function! WinManagerResumeAUs()
-	let s:commandRunning = 0
-endfunction
-
-" Another hook provided by winmanager. Normally winmanager will call the
-" plugins resize function every time the BufEnter or BufDelete event is
-" triggered. However, sometimes a plugin might change the number of lines
-" *internally*. In this case, the plugin could make a call to this function
-" which will make a safety check and then call its resize function.
-"
-function! WinManagerForceReSize(explName)
-	if !exists('s:'.a:explName.'_numberID') || !exists('*'.a:explName.'_ReSize')
-		call PrintError('resize quitting because resize function not found or explorer not registered')
-		return
-	end
-	exe 'let explNum = s:'.a:explName.'_numberID'
-	let s:commandRunning = 1
-	let windowNum = s:IsExplorerVisible(explNum)
-	if windowNum == -1
-		call PrintError('resize quitting because window not visible')
-		return
-	end
-	call s:GotoWindow(windowNum)
-	if s:IsOnlyVertical()
-		call PrintError('resize quitting because its illegal')
-		return
-	end
-	exe 'call '.a:explName.'_ReSize()'
-	let s:commandRunning = 0
-endfunction
-
-" returns 1 if the only visible windows are explorer windows.
-function! <SID>OnlyExplorerWindowsOpen()
-	let i = 1
-	" loop over all open windows
-	while 1
-		" if we have checked all open windows and not returned yet, then it
-		" means only explorers are visible.
-		if winbufnr(i) == -1
-			return 1
-		end
-		" if this is a non-explorer window then return 0
-		if !s:IsExplorerBuffer(winbufnr(i))
-			return 0
-		end
-		let i = i + 1
-	endwhile
-endfunction
-
-" MRUPush
-function! <SID>MRUPush()
-	if buflisted(bufnr("%")) && !isdirectory(bufname("%"))
-		let _bufNbr = bufnr('%')
-		let _list = substitute(s:MRUList, ','._bufNbr.',', ',', '')
-		let s:MRUList = ','._bufNbr._list
-		unlet _bufNbr _list
-	end
-endfunction
-
-" MRUPop
-function! <SID>MRUPop()
-	let _bufNbr = expand('<abuf>')
-	let s:MRUList = substitute(s:MRUList, ''._bufNbr.',', '', '')
-	unlet _bufNbr
-endfunction
-
-" MRUGet
-function! <SID>MRUGet(slot)
-	let ret = s:Strntok2(s:MRUList, ',', a:slot)
-	if ret == ''
-		return -1
-	end
-	exe 'return '.ret
-endfunction
-
-" Strntok:
-" extract the n^th token from s seperated by tok. 
-" example: Strntok('1,23,3', ',', 2) = 23
-fun! <SID>Strntok(s, tok, n)
-	return matchstr( a:s.a:tok[0], '\v(\zs([^'.a:tok.']*)\ze['.a:tok.']){'.a:n.'}')
-endfun
-
-" Strntok2
-" same as Strntok except that s is delimited by the tok character at the
-" beginning and end.
-" example: Strntok2(',1,23,3,', ',', 2) = 23
-fun! <SID>Strntok2(s, tok, n)
-	return matchstr( a:s, '\v((['.a:tok.']\zs[^'.a:tok.']*)\ze){'.a:n.'}')
-endfun
-
-" InitializeMRUList 
-"
-" initialize the MRU list. initially this will be just the buffers in the
-" order of their buffer numbers with the @% and @# leading. The MRU list
-" consists of a string of the following form: ",1,2,3,4,"
-" NOTE: there are commas at the beginning and the end. this is to make
-" identifying the position of buffers in the list easier even if they occur in
-" the beginning or end and in situations where one buffer number is part of
-" another. i.e the string "9" is part of the string "19"
-" 
-function! <SID>InitializeMRUList()
-	let nBufs = bufnr('$')
-	let _i = 1
-
-	" put the % and the # numbers at the beginning if they are listed.
-	let s:MRUList = ''
-	if buflisted(bufnr("%"))
-		let s:MRUList = ','.bufnr("%")
-	end
-	if buflisted(bufnr("#"))
-		let s:MRUList = s:MRUList.','.bufnr("#")
-	end
-	let s:MRUList = s:MRUList.','
-	
-	" then proceed with the rest of the buffers
-	while _i <= nBufs
-		" dont keep unlisted buffers in the MRU list.
-		if buflisted(_i) && bufnr("%") != _i && bufnr("#") != _i
-			let s:MRUList = s:MRUList._i.','
-		end
-		let _i = _i + 1
-	endwhile
-	" Doing this makes bufexplorer.vim display the first two listed buffers as
-	" @% and @# which they actually are when winmanager starts up after doing
-	" something like:
-	"    vim *.vim
-	"    :WMtoggle
-	let g:MRUList = s:MRUList
-endfunction
-
-if !g:defaultExplorer
-	let loaded_explorer = 1
-	"---
-	" Set up the autocommand to allow directories to be edited
-	"
-	augroup fileExplorer
-		au!
-		au VimEnter * call s:EditDir("VimEnter")
-		au BufEnter * call s:EditDir("BufEnter")
-	augroup end
-end
-
-" handles editing a directory via winmanager.
-function! <SID>EditDir(event)
-	" return immediately if this isn't a directory.
-	let name = expand("%")
-	if name == ""
-		let name = expand("%:p")
-	endif
-	if !isdirectory(name)
-		return
-	endif
-	
-	" if it is, then call the modified explorer.vim's Explore command.
-	if a:event != "VimEnter"
- 		if exists(":Explore")
- 			ExploreInCurrentWindow
- 		end
-	end
-	" if we have entered vim while editing a directory, then remove the
-	" directory buffer, and start the window layout.
-	" Note that we only start up winmanager in a VimEnter event because we
-	" want commands such as ":e /some/dir/" within vim to have the same effect
-	" as with the standard explorer.vim plugin which ships with vim.
-	"
-	" NOTE: if the user has chosen a layout where the FileExplorer is not at
-	" the top-left, this will be unintuitive.
-	if a:event == "VimEnter"
-		bwipeout
-		
-		call s:StartWindowsManager()
-		call s:MRUPush()
-		call s:GotoExplorerWindow('1')
- 	end
-endfunction
-
-" restore 'cpo'
-let &cpo = s:cpo_save
-unlet s:cpo_save
-" vim:ts=4:noet:sw=4
Index: b/plugin/wintagexplorer.vim
deleted file mode 100644
===================================================================
--- a/plugin/wintagexplorer.vim
+++ /dev/null
@@ -1,510 +0,0 @@
-"=============================================================================
-"        File: wintagexplorer.vim
-"      Author: Srinath Avadhanula (srinath@eecs.berkeley.edu)
-" Last Change: Wed Apr 03 05:00 PM 2002 PST
-"        Help: This file provides a simple interface to a tags file. The tags
-"              are grouped according to the file they belong to and the user can
-"              press <enter> while on a tag to open the tag in an adjacent
-"              window.
-"
-"              This file shows the implementation of an explorer plugin add-in
-"              to winmanager.vim. As explained in |winmanager-adding|, this
-"              function basically has to expose various functions which
-"              winmanager calls during its refresh-diplay cycle. In turn, it
-"              uses the function WinManagerRileEdit() supplied by
-"              winmanager.vim.
-
-" See ":help winmanager" for additional details.
-" ============================================================================
-
-
-" "TagsExplorer" is the "name" under which this plugin "registers" itself.
-" Registration means including a line like:
-"    RegisterExplorers "TagsExplorer"
-" in the .vimrc. Registration provides a way to let the user customize the
-" layout of the various windows. When a explorer is released, the user needs
-" to know this "name" to register the plugin. 
-"
-" The first thing this plugin does is decide upon a "title" for itself. This is
-" the name of the buffer which winmanager will open for displaying the
-" contents of this plugin. Note that this variable has to be of the form:
-"    g:<ExplorerName>_title
-" where <ExplorerName> = "TagsExplorer" for this plugin.
-let g:TagsExplorer_title = "[Tag List]"
-
-" variables to remember the last position of the user within the file.
-let s:savedCursorRow = 1
-let s:savedCursorCol = 1
-
-" skip display the error message if no tags file in current directory.
-if !exists('g:TagsExplorerSkipError')
-	let g:TagsExplorerSkipError = 0
-end
-if !exists('g:saveTagsDisplay')
-	let g:saveTagsDisplay = 1
-end
-
-function! TagsExplorer_IsPossible()
-	if glob('tags') == '' && g:TagsExplorerSkipError && !exists('s:tagsDisplay')
-		return 0
-	end
-	return 1
-endfunction
-
-" This is the function which winmanager calls the first time this plugin is
-" displayed. Again, the rule for the name of this function is:
-" <ExplorerName>_Start()
-"
-function! TagsExplorer_Start()
-	let _showcmd = &showcmd
-
-	setlocal bufhidden=delete
-	setlocal buftype=nofile
-	setlocal modifiable
-	setlocal noswapfile
-	setlocal nowrap
-	setlocal nobuflisted
-
-	set noshowcmd
-
-	" set up some _really_ elementary syntax highlighting.
-	if has("syntax") && !has("syntax_items") && exists("g:syntax_on")
-		syn match TagsExplorerFileName	'^\S*$'   
-		syn match TagsExplorerTagName	'^  \S*' 
-		syn match TagsExplorerError   '^"\s\+Error:'
-		syn match TagsExplorerVariable 'g:TagsExplorerSkipError'
-		syn match TagsExplorerIgnore '"$'
-
-		hi def link TagsExplorerFileName Special
-		hi def link TagsExplorerTagName String
-		hi def link TagsExplorerError Error
-		hi def link TagsExplorerVariable Comment
-		hi def link TagsExplorerIgnore Ignore
-	end
-
-	" set up the maps.
-	nnoremap <buffer> <silent> <c-]> :call <SID>OpenTag(0)<cr>
-	nnoremap <buffer> <silent> <cr> :call <SID>OpenTag(0)<cr>
-	nnoremap <buffer> <silent> <tab> :call <SID>OpenTag(1)<cr>
-  	nnoremap <buffer> <silent> <2-leftmouse> :call <SID>OpenTag(0)<cr>
-	nnoremap <buffer> <silent> <space> za
-	nnoremap <buffer> <silent> <c-^> <Nop>
-	nnoremap <buffer> <silent> <F5> :call <SID>DisplayTagsFile()<cr>
-
-	call <SID>StartTagsFileDisplay()
-	
-	" clean up.
-	setlocal nomodified
-	let &showcmd = _showcmd
-	unlet! _showcmd
-endfunction
-
-function! <SID>StartTagsFileDisplay()
-
-	" if the tags were previously displayed, then they would have been saved
-	" in this script variable. Therefore, just paste the contents of that
-	" variable and quit.
-	" instead of using just one variable, create a hash from the complete path
-	" of the tags file so that tag files from multiple directories can be
-	" displayed and there is caching for each of them.
-	let presHash = substitute(fnamemodify('tags', ':p'), '[^a-zA-Z0-9]', '_', 'g')
-	let taghash = ''
-	if exists('s:tagHash_'.presHash)
-		let taghash = 's:tagHash_'.presHash
-		let dirhash = 's:dirHash_'.presHash
-		let viewhash = 's:viewHash_'.presHash
-
-		let s:lastHash = presHash
-	elseif glob('tags') == '' && exists('s:lastHash')
-		let taghash = 's:tagHash_'.s:lastHash
-		let dirhash = 's:dirHash_'.s:lastHash
-		let viewhash = 's:viewHash_'.s:lastHash
-	end
-
-	if taghash != ''
-
-		setlocal modifiable
-		1,$d_
-		exe 'put='.taghash
-		1d_
-		setlocal nomodified
-		setlocal nomodifiable
-
-		" revert to the last saved view.
-		exe 'call s:LoadView('.viewhash.')'
-		exe 'let s:TagsDirectory = '.dirhash
-		
-		let s:lastHash = presHash
-		return
-
-	end
-
-	if glob('.vimtagsdisplay') != '' && g:saveTagsDisplay
-
-
-		let presHash = substitute(getcwd().'\tags', '[^a-zA-Z0-9]', '_', 'g')
-		let taghash = 's:tagHash_'.presHash
-		let dirhash = 's:dirHash_'.presHash
-		let viewhash = 's:viewHash_'.presHash
-
-		setlocal modifiable
-		1,$ d_
-		read .vimtagsdisplay
-		let _a = @a
-		0
-		call search('^\S')
-		1,.-1 d_
-		normal! ggVG"ay
-		exe 'let '.taghash.' = @a'
-		let @a = _a
-		call s:FoldTags()
-		0
-		setlocal nomodified
-		setlocal nomodifiable
-
-		exe 'let s:TagsDirectory = getcwd()'
-		exe 'let '.dirhash.' = getcwd()'	
-		exe 'let '.viewhash.' = s:MkViewNoNestedFolds()'
-		let s:lastHash = presHash
-
-		return
-
-	elseif glob('tags') != ''
-
-
-		let s:lastHash = substitute(fnamemodify('tags', ':p'), '[^a-zA-Z0-9]', '_', 'g')
-		
-		call <SID>DisplayTagsFile()
-
-	else
-
-	   call <SID>DisplayError()
-	   " setting this variable results in the next invokations of
-	   " TagsExplorer_IsPossible() to return 0. this makes
-	   " EditNextVisibleExplorer() skip displaying the tags file the next time
-	   " <C-n> is pressed.
-	   let g:TagsExplorerSkipError = 1
-	   return
-	
-	end
-
-endfunction
-
-
-function! <SID>DisplayTagsFile()
-
-	let _showcmd = &showcmd
-	let _report = &report
-	set noshowcmd
-	set report=10000
-	setlocal modifiable
-
-	if glob('tags') == ''
-		return
-	end
-
-	1,$ d_
-	silent! read tags
-
-	" remove the leading comment lines.
-	silent! % g/^!_/de
-	" delete the first blank line which happens because of read
-	0 d
-	" if this is an empty tags file, then quit.
-	if line('$') < 1 || getline(1) =~ '^\s*$'
-		return
-	end
-
-	let startTime = localtime()
-	% call s:GroupTags()
-	let sortEndTime = localtime()
-	
-	call s:FoldTags()
-	0
-	let foldEndTime = localtime()
-
-	let presHash = substitute(fnamemodify('tags', ':p'), '[^a-zA-Z0-9]', '_', 'g')
-	let taghash = 's:tagHash_'.presHash
-	let dirhash = 's:dirHash_'.presHash
-	let viewhash = 's:viewHash_'.presHash
-
-	" for fast redraw if this plugin is closed and reopened...
-	let _a = @a
-	normal! ggVG"ay
-	exe 'let '.taghash.' = @a'
-	let s:tagsDisplay = @a
-
-	if g:saveTagsDisplay
-		if glob('.vimtagsdisplay') != ''
-			silent! redir! > .vimtagsdisplay
-		else
-			silent! redir > .vimtagsdisplay
-		end
-		silent! echo @a
-		redir END
-	end
-		
-	let @a = _a
-
-	" store the directory of the current tags file location.
-	exe 'let '.dirhash.' = getcwd()'
-	exe 'let s:TagsDirectory = '.dirhash
-	exe 'let '.viewhash.' = s:MkViewNoNestedFolds()'
-	
-	setlocal nomodified
-	setlocal nomodifiable
-	let &showcmd = _showcmd
-	let &report = _report
-
-endfunction
-
-function! <SID>DisplayError()
-
-	setlocal modifiable
-
-	1,$ d_
-
-    put='Error:'
-    put=''
-    put='No Tags File Found in the current directory. Try reopening WManager in a'
-    put='directory which contains a tags file.'
-    put=''
-    put='An easy way to do this is to switch to the file explorer plugin (using <c-n>),'
-    put='navigate to that directory, press \"c\" while there in order to set the pwd, and'
-    put='then switch back to this view using <c-n>.'
-    put=''
-    put='This error message will not be shown for the remainder of this vim session.'
-    put='To have it not appear at all, set g:TagsExplorerSkipError to 1 in your .vimrc'
-
-	1d
-	let _tw= &tw
-	let &tw = g:winManagerWidth - 2
-	normal! ggVGgq
-	% s/$/"/g
-	0
-
-	let &tw = _tw
-
-	setlocal nomodifiable
-	setlocal nomodified
-
-endfunction
-
-function! TagsExplorer_WrapUp()
-	if !exists('s:lastHash')
-		return
-	end
-	
-	let viewhash = 's:viewHash_'.s:lastHash
-	exe 'let '.viewhash.' = s:MkViewNoNestedFolds()'
-endfunction
-
-function! TagsExplorer_IsValid()
-	return 1
-endfunction
-
-function! <SID>OpenTag(split)
-	let line = getline('.')
-	" if ther is a quote at the end of the line, it means we are still
-	" displaying the error message. 
-	if match(line, '"$') != -1
-		return
-	end
-
-	normal! 0
-	" this is a tag, because it starts with a space.
-	let tag = ''
-	if line =~ '^\s'
-		let tag = matchstr(getline('.'), '  \zs.*\ze')
-		" go back and extract the file name
-		let num = line('.')
-		?^\S
-		normal! 0
-		let fname = getline('.')
-		exe num
-	else
-		let fname = getline('.')
-	end
-	let _pwd = getcwd()
-	exe 'cd '.s:TagsDirectory
-	call WinManagerFileEdit(fnamemodify(fname, ':p'), a:split)
-	exe 'cd '._pwd
-
-	if tag != '' 
-		exe 'silent! tag '.tag
-	end
-endfunction
-
-" function to group tags according to which file they belong to...
-" does not use the "% g" command. does the %g command introduce a O(n^2)
-" nature into the algo?
-function! <SID>GroupTags() range
-	" get the first file
-	let numfiles = 0
-	
-	let linenum = a:firstline
-
-	while linenum <= a:lastline
-		
-		" extract the filename and the tag name from this line. this is
-		" another potential speed killer.
-		let tagname = matchstr(getline(linenum), '^[^\t]*\t\@=')
-		let fname = matchstr(getline(linenum), '\t\zs[^\t]*\ze')
-
-		" create a hash with this name.
-		" this is the costliest operation in this loop. if the file names are
-		" fully qualified and some 50 characters long, this might take very
-		" long. however, every line _has_ to be processed and therefore
-		" something has to be done with the filename. the only question is,
-		" how clever can we get with that operation?
-		let fhashname = substitute(fname, '[^a-zA-Z0-9_]', '_', 'g')
-
-		if !exists('hash_'.fhashname)
-			exe 'let hash_'.fhashname.' = ""'
-			let numfiles = numfiles + 1
-			exe 'let filehash_'.numfiles.' = fhashname'
-			exe 'let filename_'.numfiles.' = fname'
-		end
-		" append this tag to the tag list corresponding to this file name.
-		exe 'let hash_'.fhashname.' = hash_'.fhashname.'."  ".tagname."\n"'
-		
-		let linenum = linenum + 1
-	endwhile
-	0
-	1,$ d_
-	
-	let i = 1
-	while i <= numfiles
-		$
-		exe 'let hashname = filehash_'.i
-		exe 'let tagsf = hash_'.hashname
-		exe 'let filename = filename_'.i
-		let disp = filename."\n".tagsf
-
-		put=disp
-
-		let i = i + 1
-	endwhile
-	0 d_
-endfunction
-
-function! <SID>FoldTags()
-	
-	setlocal foldmethod=manual
-	1
-	let lastLine = 1
-	while 1
-		if search('^\S', 'W')
-			normal! k
-			let presLine = line('.')
-		else
-			break
-		end
-		exe lastLine.','.presLine.' fold'
-		normal! j
-		let lastLine = line('.')
-	endwhile
-	exe lastLine.',$ fold'
-endfunction
-
-function! TE_ShowVariableValue(...)
-	let i = 1
-	while i <= a:0
-		exe 'let arg = a:'.i
-		if exists('s:'.arg) ||
-		\  exists('*s:'.arg)
-			exe 'let val = s:'.arg
-			echomsg 's:'.arg.' = '.val
-		end
-		let i = i + 1
-	endwhile
-endfunction
-
-" Synopsis: let foldInfo = s:MkViewNoNestedFolds()
-" Description: returns the view information. This function is to be used when
-"    it is known that there are no nested folds in the file (i.e folds with
-"    depth > 1). when there are nested folds, this function silently ignores
-"    them.
-function! s:MkViewNoNestedFolds()
-	let row = line('.')
-	let col = virtcol('.')
-	let viewInfo = row.'#'.col.'#'
-	let openInfo = ''
-
-	let i = 1
-	while i <= line('$')
-		if foldlevel(i) > 0
-			let unfold = 0
-			if foldclosedend(i) < 0
-				exe i
-				normal! zc
-				let unfold = 1
-				let openInfo = openInfo.0.','
-			else
-				let openInfo = openInfo.1.','
-			end
-			let j = foldclosedend(i)
-			let viewInfo  = viewInfo.i.','.j.'|'
-			if unfold
-				exe i
-				normal! zo
-			end
-			let i = j + 1
-			continue
-		end
-		let i = i + 1
-	endwhile
-	
-	let viewInfo = viewInfo.'#'.openInfo
-	let viewInfo = substitute(viewInfo, '|#', '#', '')
-	let viewInfo = substitute(viewInfo, ',$', '', '')
-
-	exe row
-	exe 'normal! '.col.'|'
-
-	return viewInfo
-endfunction
-
-" Synopsis: call s:LoadView(foldInfo)
-" Description: This function restores the view defined in the argument
-"    foldInfo. See the description of MkView() for the format of this
-"    argument. This function should only be used when the foldmethod of the
-"    file is manual. There is no error-checking done in this function, so it
-"    needs to be used responsibly.
-function! s:LoadView(foldInfo)
-	let row = s:Strntok(a:foldInfo, '#', 1)
-	let col = s:Strntok(a:foldInfo, '#', 2)
-	let folds = s:Strntok(a:foldInfo, '#', 3)
-	let fclosedinfo = s:Strntok(a:foldInfo, '#', 4)
-	
-	normal! zE
-
-	let i = 1
-	let foldi = s:Strntok(folds, '|', i)
-	let isclosed = s:Strntok(fclosedinfo, ',', i)
-
-	while foldi != ''
-		let n1 = s:Strntok(foldi, ',', 1)
-		let n2 = s:Strntok(foldi, ',', 2)
-		exe n1.','.n2.' fold'
-
-		if !isclosed
-			exe n1
-			normal! zo
-		end
-
-		let i = i + 1
-		let foldi = s:Strntok(folds, '|', i)
-		let isclosed = s:Strntok(fclosedinfo, ',', i)
-	endwhile
-
-	exe row
-	exe 'normal! '.col.'|'
-endfunction
-
-" Strntok:
-" extract the n^th token from s seperated by tok. 
-" example: Strntok('1,23,3', ',', 2) = 23
-fun! <SID>Strntok(s, tok, n)
-	return matchstr( a:s.a:tok[0], '\v(\zs([^'.a:tok.']*)\ze['.a:tok.']){'.a:n.'}')
-endfun
Index: b/scm.vim
deleted file mode 100644
===================================================================
--- a/scm.vim
+++ /dev/null
@@ -1,7 +0,0 @@
-" abbreviation "
-:abbr d define
-
-" inoremap "
-inoremap ( ()<left>
-
-match errormsg /[\t]/
